<div><blockquote>
  <h1>Choose: Grunt, Gulp, or npm?</h1>
  <div><p>Deciding on a technology is <em>always</em> hard. You don&#x2019;t want to make commitments you won&#x2019;t be able to back out of, but eventually you&#x2019;ll have to make a &#x2026;</p></div>
</blockquote></div>

<div><p>Deciding on a technology is <em>always</em> hard. You don&#x2019;t want to make commitments you won&#x2019;t be able to back out of, but eventually you&#x2019;ll have to make a choice and go for something that does what you need it to do. Committing to a build technology is no different in this regard: it&#x2019;s an important choice and you should treat it as such. Let&#x2019;s take <a href="http://gruntjs.com/" target="_blank">Grunt</a> for example.</p></div>

<div></div>

<div><ul> <li><a href="http://gruntjs.com/" target="_blank">Grunt</a> has a healthy community around it, even on Windows</li> <li>It <strong>isn&#x2019;t</strong> used almost exclusively by the Node community</li> <li>It&#x2019;s easy to learn, you just pick plugins and configure them</li> <li>There&#x2019;s no advanced concepts nor lots of prior knowledge needed</li> </ul> <p>These are all good reasons to use <a href="http://gruntjs.com/" target="_blank">Grunt</a> to teach build processes, but I want to make it clear that I don&#x2019;t think <a href="http://gruntjs.com/" target="_blank">Grunt</a> is the single best option out there, and that there are other popular build tools that might fit your needs better than <a href="http://gruntjs.com/" target="_blank">Grunt</a> will.</p> <p>I wrote this brief article to help you understand the differences between <a href="http://localhost:3000/2014/01/09/gulp-grunt-whatever">Grunt, Gulp, and npm</a>, which are the three build tools that I use most often in front-end development workflows. While we&#x2019;re at it, I&#x2019;ll lay out the situations in which a particular tool might be better than the others.</p></div>

<div><p>As a first step, let&#x2019;s discuss where Grunt excels at.</p> <h1 id="grunt-the-good-parts">Grunt: The Good Parts</h1> <p>The single best aspect of <a href="http://gruntjs.com/" target="_blank" aria-label="The JavaScript Task Runner">Grunt</a> is its ease of use. It enables programmers to develop build flows using JavaScript almost effortlessly. All that&#x2019;s required is searching for the appropriate plugin, reading its documentation, and then installing and configuring it. This ease of use means that members of large development teams, who are often of varying skill levels, don&#x2019;t have any trouble tweaking the build flow to meet the latest needs of the project. The team doesn&#x2019;t need to be fluent in Node either, they need to add properties to the configuration object, and task names to the different arrays that make up the build flow.</p> <p>There&#x2019;s a plugin base large enough that you&#x2019;ll rarely find yourself needing to develop your own build tasks, which also enables you and your team to rapidly develop a build process, which is crucial if you&#x2019;re going for a <a href="http://bevacqua.io/buildfirst" target="_blank" aria-label="JavaScript Application Design: A Build First Approach">Build First</a> approach, even when taking small steps and progressively developing your build flows.</p> <p>It&#x2019;s also feasible to manage deployments through Grunt, as many packages exist to accommodate for those tasks, such as <code class="md-code md-code-inline">grunt-git</code>, <code class="md-code md-code-inline">grunt-rsync</code>, or <a href="https://www.npmjs.org/package/grunt-ec2" target="_blank" aria-label="grunt-ec2 on npm"><code class="md-code md-code-inline">grunt-ec2</code></a>, to name a few.</p> <p>So where does Grunt fall short? It may get too verbose if you have a significantly large build flow. It&#x2019;s often hard to make sense of the build flow as a whole once it has been in development for a while. Once the task count in your build flows gets to the double digits, it&#x2019;s almost guaranteed that you&#x2019;ll find yourself having to run targets which belong to the same task individually, so that you&#x2019;re able to compose the flow in the right order. Since tasks are configured declaratively, you&#x2019;ll also have a hard time figuring out the order in which tasks get executed.</p> <p>Besides that, your team should be dedicated to writing maintainable code when it comes to your builds as well, and in the case of Grunt that means maintaining separate files for the configuration of each task, or at least for each of the build flows that your team uses.</p> <p>Now that we&#x2019;ve identified the good and the bad in Grunt, as well as the situations in which it might be a better fit for your project, let&#x2019;s talk about npm, how it can be leveraged as a build tool, and its differences with Grunt.</p> <h1 id="npm-as-a-build-tool">npm as a build tool</h1> <p>In order to use npm as a build tool, you&#x2019;ll need a <code class="md-code md-code-inline">package.json</code> file and <code class="md-code md-code-inline">npm</code> itself. Defining tasks for npm is as easy as adding properties to a <code class="md-code md-code-inline">scripts</code> object in your package manifest. The name of the property will be used as the task name, and the value will be the command you want to execute. The example shown below uses the JSHint command-line interface to run a linter through our JavaScript files and check for errors. You can run any shell command that you need.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">scripts</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">test</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;jshint . --exclude node_modules&quot;</span>
  </span>}</span>,
  &quot;<span class="md-code-attribute">devDependencies</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">jshint</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;^2.5.1&quot;</span>
  </span>}
</span>}
</code></pre> <p>Once the task is defined, it can be executed in your command-line by running the following command.</p> <pre class="md-code-block"><code class="md-code">npm run test
</code></pre> <p>Note that npm provides shortcuts for specific task names. In the case of <code class="md-code md-code-inline">test</code>, you could simply do <code class="md-code md-code-inline">npm test</code> and omit the <code class="md-code md-code-inline">run</code> verb. You can compose build flows by chaining <code class="md-code md-code-inline">npm run</code> commands together in your script declarations.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">scripts</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">lint</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;jshint . --exclude node_modules&quot;</span></span>,
    &quot;<span class="md-code-attribute">unit</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;tape test/*&quot;</span></span>,
    &quot;<span class="md-code-attribute">test</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;npm run lint &amp;&amp; npm run unit&quot;</span>
  </span>}</span>,
  &quot;<span class="md-code-attribute">devDependencies</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">jshint</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;^2.5.1&quot;</span></span>,
    &quot;<span class="md-code-attribute">tape</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;~2.10.2&quot;</span>
  </span>}
</span>}
</code></pre> <p>You could also schedule tasks as background jobs, making them asynchronous. Suppose we have the following package file, where we&#x2019;ll just copy a directory in our JavaScript build flow, and compile an Stylus stylesheet during our CSS build flow (Stylus is a CSS preprocessor). In this case, running the tasks asynchronously is ideal. You can achieve that using <code class="md-code md-code-inline">&amp;</code> as a separator, or after a command.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">scripts</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">build-js</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;cp -r src/js/vendor bin/js&quot;</span></span>,
    &quot;<span class="md-code-attribute">build-css</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;stylus src/css/all.styl -o bin/css&quot;</span></span>,
    &quot;<span class="md-code-attribute">build</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;npm run build-js &amp; npm run build-css&quot;</span>
  </span>}</span>,
  &quot;<span class="md-code-attribute">devDependencies</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">stylus</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;^0.45.0&quot;</span>
  </span>}
</span>}
</code></pre> <p>To learn more about npm as a build tool, you should try and learn how to write Bash commands instead.</p> <h2 id="installing-npm-task-dependencies">Installing npm task dependencies</h2> <p>The JSHint CLI is not necessarily available in your system, and there&#x2019;s two ways you could go about installing it. If you&#x2019;re looking to use the tool directly from your command-line, and not in an <code class="md-code md-code-inline">npm run</code> task, then you should install it globally, using the <code class="md-code md-code-inline">-g</code> flag as shown below.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">npm install -g jshint
</code></pre> <p>However, if you&#x2019;re using the package in an <code class="md-code md-code-inline">npm run</code> task, then you should be adding it as a <code class="md-code md-code-inline">devDependency</code>, as shown below. That&#x2019;ll allow npm to find the JSHint package on any system where the package dependencies are installed, rather than expecting the environment to have JSHint installed globally. This applies to any CLI tools that aren&#x2019;t readily available in operating systems.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">npm install --save-dev jshint
</code></pre> <p>You aren&#x2019;t limited to using just CLI tools. In fact, npm is able to run any shell script. Let&#x2019;s dig into that!</p> <h2 id="using-shell-scripts-in-npm-tasks">Using shell scripts in npm tasks</h2> <p>Below is an example script that runs on Node, and displays a random emoji string. The first line tells the environment that the script is in Node.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-comment">#!/usr/bin/env node</span>

var emoji = require(<span class="md-code-string">&apos;emoji-random&apos;</span>);
var emo = emoji.random();

console.log(emo);
</code></pre> <p>If you were to place that script in a file named <code class="md-code md-code-inline">emoji</code> at the root of our project, you&#x2019;d have to declare <code class="md-code md-code-inline">emoji-random</code> as a dependecy and add the command to the <code class="md-code md-code-inline">scripts</code> object in the package manifest.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">scripts</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">emoji</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;./emoji&quot;</span>
  </span>}</span>,
  &quot;<span class="md-code-attribute">devDependencies</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">emoji-random</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;^0.1.2&quot;</span>
  </span>}
</span>}
</code></pre> <p>Once that&#x2019;s out of the way, running the command is merely a matter of invoking <code class="md-code md-code-inline">npm run emoji</code> in your terminal.</p> <h2 id="the-good-and-the-bad">The good and the bad</h2> <p>Using <a href="http://substack.net/task_automation_with_npm_run" target="_blank" aria-label="Task automation with `npm run`">npm as a build tool</a> has several advantages over Grunt. You aren&#x2019;t constrained to Grunt plugins, and thus you can take advantage of all of npm, which hosts tens of thousands of packages. You won&#x2019;t need any additional CLI tooling or files other than <code class="md-code md-code-inline">npm</code>, which you are already using to manage dependencies, and your <code class="md-code md-code-inline">package.json</code> manifest, where dependencies and your build commands are listed. Since <code class="md-code md-code-inline">npm</code> runs CLI tools and Bash commands directly, it&#x2019;ll perform way better than Grunt could.</p> <p>Take into account that one of the biggest disadvantages of Grunt is the fact that it&#x2019;s I/O bound. This means that most Grunt tasks read from disk, and then write to disk. If you have several tasks working on the same files, then chances are the file is going to be read from disk multiple times. In Bash, commands can pipe the output of a command directly into the next one, avoiding the extra I/O overhead in Grunt.</p> <p>Probably the biggest disadvantage to npm is the fact that Bash doesn&#x2019;t play all that well with Windows environments. This means that open-source projects using <code class="md-code md-code-inline">npm run</code> might run into issues when people try to fiddle with them on Windows. In a similar light, it also means that Windows developers will try and use alternatives to <code class="md-code md-code-inline">npm</code>, instead. That drawback pretty much rules out <code class="md-code md-code-inline">npm</code> for projects that need to be able to run on Windows.</p> <p><a href="http://gulpjs.com/" target="_blank" aria-label="The Streaming Task Runner">Gulp</a>, another build tool, presents similarities with both Grunt and npm, as you&#x2019;ll discover in a moment.</p> <h1 id="gulp-the-streaming-build-tool">Gulp, the streaming build tool</h1> <p>Gulp is similar to Grunt in that it relies on plugins and it&#x2019;s cross-platform, supporting Windows users as well. Gulp is a code-driven build tool, in contrast with Grunt&#x2019;s declarative approach to task definition, making your task definitions a bit easier to read. Gulp is also similar to <code class="md-code md-code-inline">npm run</code> in that it uses Node streams to read files and pipe data through functions that transform it into output that will end up being written to disk. This means that Gulp doesn&#x2019;t have the disk-intensive I/O issues that you may observe in using Grunt. It&#x2019;s also faster than Grunt for the same reason, less time spent in I/O.</p> <p>The main disadvantage in using Gulp is that it relies heavily on streams, pipes, and asynchronous code. Don&#x2019;t get me wrong: if you&#x2019;re into Node, then that&#x2019;s definitely an advantage as well. But the issue with those concepts is that unless you and your team are well-versed in Node, you&#x2019;re probably going to run into issues dealing with streams, especially if you have to build your own Gulp task plugins.</p> <p>When working in teams, Gulp is not as prohibitive as <code class="md-code md-code-inline">npm</code>, because most of your front-end team probably knows JavaScript, while chances are they&#x2019;re not that fluent in Bash scripting, and some of them may be using Windows! That&#x2019;s why I usually suggest to keep <code class="md-code md-code-inline">npm run</code> to your personal projects, maybe use Gulp in projects where the team is comfy with Node, and Grunt everywhere else. Of course, that&#x2019;s my personal appreciation, you should think for yourself and figure out what works best for you and your team. Also, you shouldn&#x2019;t constrain yourself to Grunt, Gulp, or <code class="md-code md-code-inline">npm run</code> just because those are the tools that work for me. Try and do a little research, and maybe you&#x2019;ll find a tool that you like even better than those three.</p> <p>Let&#x2019;s walk through some examples to get a feel of how Gulp tasks look like.</p> <h2 id="running-tests-in-gulp">Running tests in Gulp</h2> <p>Gulp is quite similar to Grunt in its conventions. In Grunt there&#x2019;s a <code class="md-code md-code-inline">Gruntfile.js</code> file, used to define your build tasks, and in Gulp the file needs to be named <code class="md-code md-code-inline">Gulpfile.js</code> instead. The other minor difference is that in the case of Gulp, the CLI is contained in the same package as the task runner, so you&#x2019;ll have to install the <code class="md-code md-code-inline">gulp</code> package from npm both locally and globally.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">touch Gulpfile.js
npm install -g gulp
npm install --save-dev gulp
</code></pre> <p>To get started, I&#x2019;ll create a Gulp task to lint a JavaScript file, using JSHint just like you&#x2019;ve already seen with Grunt and <code class="md-code md-code-inline">npm run</code>. In the case of Gulp, you&#x2019;ll have to install the <code class="md-code md-code-inline">gulp-jshint</code> Gulp plugin for JSHint.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">npm install --save-dev gulp-jshint
</code></pre> <p>Now that you&#x2019;re fully equipped with the CLI, that you globally installed, the local <code class="md-code md-code-inline">gulp</code> instalation, and the <code class="md-code md-code-inline">gulp-jshint</code> plugin, you can put together the build task to run the linter. To define build tasks with Gulp, you&#x2019;ll have to write them programatically in the <code class="md-code md-code-inline">Gulpfile.js</code> file.</p> <p>First off you&#x2019;ll use <code class="md-code md-code-inline">gulp.task</code> passing it a task name and a function. The function contains all of the code necessary to run that task. Here you should use <code class="md-code md-code-inline">gulp.src</code> to create a read stream into your source files, using a globbing pattern like the ones you&#x2019;ve seen in our experiences learning about Grunt. That same stream should be piped into the JSHint plugin, which you can configure or just use with the defaults it comes with. Then all you&#x2019;d have to do is pipe the results of the JSHint task through a reporter, and have it print the results to your terminal. All of what I&#x2019;ve just described results in the Gulpfile presented below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> gulp = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp&apos;</span>);
<span class="md-code-keyword">var</span> jshint = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp-jshint&apos;</span>);

gulp.task(<span class="md-code-string">&apos;test&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> gulp
    .src(<span class="md-code-string">&apos;./sample.js&apos;</span>)
    .pipe(jshint())
    .pipe(jshint.reporter(<span class="md-code-string">&apos;default&apos;</span>));
});
</code></pre> <p>I should also mention that I&#x2019;m returning the stream so that Gulp understands that it should wait for the data to stop flowing before it considers the task to be completed. You could use a custom JSHint reporter in order to have the output be a bit more concise, and thus easier to read by humans. JSHint reporters don&#x2019;t need to be Gulp plugins, so you could use <code class="md-code md-code-inline">jshint-stylish</code> for example. Let&#x2019;s install it locally.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">npm install --save-dev jshint-stylish
</code></pre> <p>The updated Gulpfile should look as shown below. It&#x2019;ll load the <code class="md-code md-code-inline">jshint-stylish</code> module to format the reporting output.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> gulp = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp&apos;</span>);
<span class="md-code-keyword">var</span> jshint = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp-jshint&apos;</span>);

gulp.task(<span class="md-code-string">&apos;test&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> gulp
    .src(<span class="md-code-string">&apos;./sample.js&apos;</span>)
    .pipe(jshint())
    .pipe(jshint.reporter(<span class="md-code-string">&apos;jshint-stylish&apos;</span>));
});
</code></pre> <p>You&#x2019;re done! That&#x2019;s all there is to declaring a Gulp task named <code class="md-code md-code-inline">test</code>. It can be run using the command below, provided that you installed the <code class="md-code md-code-inline">gulp</code> CLI globally.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">gulp <span class="md-code-built_in">test</span>
</code></pre> <p>That was quite a trivial example. Just as well as ou can pipe the output of the JSHint linter through a reporter that will print the results of the linting test, you could also write output to disk by using <code class="md-code md-code-inline">gulp.dest</code>, which creates a write stream. Let&#x2019;s step through another build task.</p> <h2 id="building-a-library-in-gulp">Building a library in Gulp</h2> <p>To get started, let&#x2019;s do the bare minimum: read from disk with <code class="md-code md-code-inline">gulp.src</code> and write back to disk piping the contents of the source file into <code class="md-code md-code-inline">gulp.dest</code>, effectively just copying the file into another directory.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> gulp = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp&apos;</span>);

gulp.task(<span class="md-code-string">&apos;build&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> gulp
    .src(<span class="md-code-string">&apos;./sample.js&apos;</span>)
    .pipe(gulp.dest(<span class="md-code-string">&apos;./build&apos;</span>));
});
</code></pre> <p>Copying the file is nice, but it doesn&#x2019;t quite minify its contents. To do that, you&#x2019;ll have to use a Gulp plugin. In this case you could use <code class="md-code md-code-inline">gulp-uglify</code>, a plugin for the popular UglifyJS minifier.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> gulp = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp&apos;</span>);
<span class="md-code-keyword">var</span> uglify = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp-uglify&apos;</span>);

gulp.task(<span class="md-code-string">&apos;build&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> gulp
    .src(<span class="md-code-string">&apos;./sample.js&apos;</span>)
    .pipe(uglify())
    .pipe(gulp.dest(<span class="md-code-string">&apos;./build&apos;</span>));
});
</code></pre> <p>As you&#x2019;ve probably realized, streams enable you to add more plugins while only reading and writing to disk once. As an example, let&#x2019;s pipe through <code class="md-code md-code-inline">gulp-size</code> as well, which will calculate the size of the contents that are in the buffer, and print that to the terminal. Note that if you add it before Uglify then you&#x2019;d get the unminified size, and if you add it after, you&#x2019;ll get the minified size. You could also do both!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> gulp = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp&apos;</span>);
<span class="md-code-keyword">var</span> uglify = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp-uglify&apos;</span>);
<span class="md-code-keyword">var</span> size = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp-size&apos;</span>);

gulp.task(<span class="md-code-string">&apos;build&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> gulp
    .src(<span class="md-code-string">&apos;./sample.js&apos;</span>)
    .pipe(uglify())
    .pipe(size())
    .pipe(gulp.dest(<span class="md-code-string">&apos;./build&apos;</span>));
});
</code></pre> <p>Just to reinforce the point on composability, being able to add or remove pipes as needed, let&#x2019;s add one last plugin. This time I&#x2019;ll use <code class="md-code md-code-inline">gulp-header</code> to add some license information to the minified piece of code, such as the name, the package version, and the license type.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> gulp = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp&apos;</span>);
<span class="md-code-keyword">var</span> uglify = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp-uglify&apos;</span>);
<span class="md-code-keyword">var</span> size = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp-size&apos;</span>);
<span class="md-code-keyword">var</span> header = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp-header&apos;</span>);
<span class="md-code-keyword">var</span> pkg = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;./package.json&apos;</span>);
<span class="md-code-keyword">var</span> info = <span class="md-code-string">&apos;// &lt;%= pkg.name %&gt;@v&lt;%= pkg.version %&gt;, &lt;%= pkg.license %&gt;\n&apos;</span>;

gulp.task(<span class="md-code-string">&apos;build&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> gulp
    .src(<span class="md-code-string">&apos;./sample.js&apos;</span>)
    .pipe(uglify())
    .pipe(header(info, { pkg : pkg }))
    .pipe(size())
    .pipe(gulp.dest(<span class="md-code-string">&apos;./build&apos;</span>));
});
</code></pre> <p>Just like in Grunt, in Gulp you can define flows by passing in an array of task names to <code class="md-code md-code-inline">gulp.task</code>, instead of a function. The main difference between Grunt and Gulp in this regard is that Gulp will execute these dependencies asynchronously, while Grunt executes them synchronously.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">gulp.task(<span class="md-code-string">&apos;build&apos;</span>, [<span class="md-code-string">&apos;build-js&apos;</span>, <span class="md-code-string">&apos;build-css&apos;</span>]);
</code></pre> <p>In Gulp, if you want to run tasks synchronously you&#x2019;ll have to declare a task as a dependency and then define your own task. All dependencies are executed before your task starts.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">gulp.task(<span class="md-code-string">&apos;build&apos;</span>, [<span class="md-code-string">&apos;dep&apos;</span>], <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-comment">// here goes the task that depends on &apos;dep&apos;</span>
});
</code></pre> <p>If you take anything away from this article, have that be this quote.</p> <blockquote> <p><strong>It doesn&#x2019;t matter which tool you use, as long as it allows you to compose the build flows you need in a way that doesn&#x2019;t make you work too hard for it.</strong></p> </blockquote></div>
