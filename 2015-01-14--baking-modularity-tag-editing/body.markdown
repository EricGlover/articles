# Insignia

[Insignia][4] has the purpose to **make tag editing simple**. If you want to suggest tags to your humans, based on the results of an API endpoint or events over a WebSocket, you are certainly welcome to do that, but Insignia won't take any part of it.

If I needed something to suggest tags for humans using Insignia, I wouldn't create a plugin system. The DOM is the plugin system. **I would create a separate component to do just that**. It would also be a component that makes sense on its own, when paired with another input that deserves a suggestion mechanism. For instance, that theoretical component might work well enough to suggest dates on a field that's already using [Rome][3] for date input. This way, the composable small components I create could serve me well for other projects, and hooking them to my framework of choice shouldn't take a lot of effort.

The purpose then is to create a tag editor that's human friendly. Humans should be able to enter values into the field even when JavaScript hasn't finished loading. Once JavaScript loads, the tags that are already in the field should be extracted into a prettier visualization, but the human should still be _able to remove them, edit them, and walk through them_ with the arrow keys.

A minimal API would also go a long way towards being able to translate the altered visual representation into a collection of tags, something the implementation shouldn't have any problem putting together.

[![screenshot.png][1]][2]

Once I've settled for a purpose and I roughly understand how the interface should look like, there's one more pause we need to take before starting to smash our fingers on the keyboard.

> What kind of browser support will we offer?

This is an important question because there's nothing quite terrible as suddenly trying to support **IE7+** and finding out that even things like `Element.setAttribute` or `Array.prototype.indexOf` aren't even in the browser, let alone `Element.selectionStart` and `Element.selectionEnd`.

If you face module development with a _"take no API for granted"_ mentality, you'll be a significantly happier web developer than most people _"dealing with IE8"_. You won't just think of everything in terms of _"Is there a polyfill for this?"_ but rather you'll be able to see further along and say _"I'll just use a `for` loop, then"_.

# Initial Commit

Think of the following as a recipe. Set up an `index.html` page with usage examples before you have any working code. That's what you'll use as a playground for your component. It doesn't have to actually exist yet, but I find this works best when I also display code for how I want the API to look like.

This kind of preemptive design allows you to predict issues with the API and work your way from basic HTML elements _(in my case, just an `<input type='text' />`)_, towards the component you want. Effectively, this is the same progression that will be followed by user agents, allowing you to experience the same _"rollout"_ your humans will.

Once you've put together the HTML page, start adding the JavaScript and styling. Feel free to code up the examples in plain JavaScript and CSS _(basically consuming the API and styling the page itself)_, but do use whatever module system and pre-processor you feel comfortable with for the library code. These always come with a simple CLI to compile the code into a JavaScript or CSS bundle.

In my case, it just takes the command below to compile any number of CommonJS modules into a single bundle.

```shell
browserify main.js -o bundle.js
```

I usually use `watchify` during development, which is equivalent to `browserify`, except it incrementally rebuilds the bundle. For styles I use Stylus, which also comes with a CLI that can be used to watch for changes.

Here's [the entire build and deployment process][5] for `insignia`.

```js
"scripts": {
  "start": "watchify -s insignia -do dist/insignia.js insignia.js & stylus -w insignia.styl -o dist",
  "scripts": "jshint . && browserify -s insignia -do dist/insignia.js insignia.js && uglifyjs -m -c -o dist/insignia.min.js dist/insignia.js",
  "styles": "stylus insignia.styl -o dist && cleancss dist/insignia.css -o dist/insignia.min.css",
  "build": "npm run scripts && npm run styles",
  "deployment": "npm version ${BUMP:-\"patch\"} --no-git-tag-version && git add package.json && git commit -m \"Autogenerated pre-deployment commit\" && bower version ${BUMP:-\"patch\"} && git reset HEAD~2 && git add . && git commit -am \"Release $(cat package.json | jq -r .version)\" && git push --tags && npm publish && git push",
  "sync": "git checkout gh-pages ; git merge master ; git push ; git checkout master",
  "deploy": "npm run build && npm run deployment && npm run sync"
}
```

Throw in any assortment of `.gitignore`, `.editorconfig`, `license`, `changelog.markdown`, `readme.markdown`, `.jshintrc`, and `.jshintignore` you feel comfortable with, and you're ready to get started developing your module.

Make sure to _abstract potentially troublesome code into separate modules_, so that you can later brush off cross-browser inconsistencies. For instance, I created a `'./selection'` module for getting and setting the selected text range, even when I was initially just working on Google Chrome _(which has perfectly functional `Element.selectionStart` and `Element.selectionEnd` property getters and setters)_.

# Conclusion

If you approach component design thoughtfully you should have very little issue making a functioning cross-browser component that doesn't alienate your humans, does what you need, and has a focused API surface that allows you to compose several modules into a complex, scalable application.

[1]: https://i.imgur.com/d9M762N.png
[2]: http://bevacqua.github.io/insignia/ "Try a demo of Insignia online"
[3]: https://github.com/bevacqua/rome "bevacqua/rome on GitHub"
[4]: https://github.com/bevacqua/insignia "bevacqua/insignia on GitHub"
[5]: https://github.com/bevacqua/insignia/blob/master/package.json#L6-L12 "bevacqua/insignia/package.json on GitHub"
