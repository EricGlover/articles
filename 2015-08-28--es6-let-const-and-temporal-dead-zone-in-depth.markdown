<div><blockquote>
  <h1>ES6 Let, Const and the &#x201C;Temporal Dead Zone&#x201D; (TDZ) in Depth</h1>
  <div><p>This is yet another edition of <a href="http://localhost:3000/articles/tagged/es6-in-depth">ES6 in Depth</a>. First time here? Welcome! So far we covered <a href="http://localhost:3000/articles/es6-destructuring-in-depth">destructuring</a>, <a href="http://localhost:3000/articles/es6-template-strings-in-depth">template literals</a>, <a href="http://localhost:3000/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="http://localhost:3000/articles/es6-spread-and-butter-in-depth">spread operator and rest &#x2026;</a></p></div>
</blockquote></div>

<div><p>This is yet another edition of <a href="http://localhost:3000/articles/tagged/es6-in-depth">ES6 in Depth</a>. First time here? Welcome! So far we covered <a href="http://localhost:3000/articles/es6-destructuring-in-depth">destructuring</a>, <a href="http://localhost:3000/articles/es6-template-strings-in-depth">template literals</a>, <a href="http://localhost:3000/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="http://localhost:3000/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, <a href="http://localhost:3000/articles/es6-object-literal-features-in-depth">object literal features in ES6</a>, and last but not least: <a href="http://localhost:3000/articles/es6-classes-in-depth">what <em>&#x201C;classes&#x201D;</em> really mean in ES6</a>. Today is going to be about an assortment of simple language features coming our way in ES6 &#x2013; <code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the scary-sounding <em>&#x201C;Temporal Dead Zone&#x201D;</em>.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="http://localhost:3000/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p><em>Shall we?</em></p></div>

<div><h2 id="let-statement">Let Statement</h2> <p>The <code class="md-code md-code-inline">let</code> statement is one of the most well-known features in ES6, which is partly why I grouped it together with a few other new features. It works like a <code class="md-code md-code-inline">var</code> statement, but it has different scoping rules. JavaScript has always had a complicated ruleset when it came to scoping, driving many programmers crazy when they were first trying to figure out how variables work in JavaScript.</p> <p>Eventually, you discover this thing called <a href="http://localhost:3000/articles/javascript-variable-hoisting" aria-label="JavaScript Variable Hoisting on Pony Foo">hoisting</a>, and things start making a bit more sense to you. Hoisting means that variables get pulled from anywhere they were declared in user code to the top of their scope. For example, see the code below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">areTheyAwesome</span> <span class="md-code-params">(name)</span> </span>{
  <span class="md-code-keyword">if</span> (name === <span class="md-code-string">&apos;nico&apos;</span>) {
    <span class="md-code-keyword">var</span> awesome = <span class="md-code-literal">true</span>
  }
  <span class="md-code-keyword">return</span> awesome
}
areTheyAwesome(<span class="md-code-string">&apos;nico&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
areTheyAwesome(<span class="md-code-string">&apos;christian heilmann&apos;</span>)
<span class="md-code-comment">// &lt;- undefined</span>
</code></pre> <p>The reason why this doesn&#x2019;t implode into oblivion is, as we know, that <code class="md-code md-code-inline">var</code> is function-scoped. That coupled with hoisting means that what we&#x2019;re really expressing is something like the piece of code below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">areTheyAwesome</span> <span class="md-code-params">(name)</span> </span>{
  <span class="md-code-keyword">var</span> awesome
  <span class="md-code-keyword">if</span> (name === <span class="md-code-string">&apos;nico&apos;</span>) {
    awesome = <span class="md-code-literal">true</span>
  }
  <span class="md-code-keyword">return</span> awesome
}
</code></pre> <p>Whether we like it or not (or we&#x2019;re just used to it &#x2013; I know I am), this is plainly more confusing than having block-scoped variables would be. Block scoping works on the bracket level, rather than the function level.</p> <p>Instead of having to declare a new <code class="md-code md-code-inline">function</code> if we want a deeper scoping level, block scoping allows you to just leverage existing code branches like those in <code class="md-code md-code-inline">if</code>, <code class="md-code md-code-inline">for</code>, or <code class="md-code md-code-inline">while</code> statements; you could also create new <code class="md-code md-code-inline">{}</code> blocks arbitrarily. As you may or may not know, the JavaScript language allows us to create an indiscriminate number of blocks, just because we want to.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">{{{{{<span class="md-code-keyword">var</span> insane = <span class="md-code-string">&apos;yes, you are&apos;</span>}}}}}
<span class="md-code-built_in">console</span>.log(insane)
<span class="md-code-comment">// &lt;- &apos;yes, you are&apos;</span>
</code></pre> <p>With <code class="md-code md-code-inline">var</code>, though, one could still access the variable from outside those many, many, many blocks, and not get an error. Sometimes it can be very useful to get errors in these situations. Particularly if one or more of these is true.</p> <ul> <li>Accessing the inner variable breaks some sort of encapsulation principle in our code</li> <li>The inner variable doesn&#x2019;t belong in the outer scope at all</li> <li>The block in question has many siblings that would also want to use the same variable name</li> <li>One of the parent blocks already has a variable with the name we need, but it&#x2019;s still appropriate to use in the inner block</li> </ul> <h2 id="so-how-does-this-let-thing-work">So how does this <code class="md-code md-code-inline">let</code> thing work?</h2> <blockquote> <p>The <code class="md-code md-code-inline">let</code> statement is an alternative to <code class="md-code md-code-inline">var</code>. It follows block scoping rules instead of the default function scoping rules. This means you <strong>don&#x2019;t need entire functions</strong> to get a new scope &#x2013; <em>a simple <code class="md-code md-code-inline">{}</code> block will do!</em></p> </blockquote> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">let</span> outer = <span class="md-code-string">&apos;I am so eccentric!&apos;</span>
{
  <span class="md-code-keyword">let</span> inner = <span class="md-code-string">&apos;I play with neighbors in my block and the sewers&apos;</span>
  {
    <span class="md-code-keyword">let</span> innermost = <span class="md-code-string">&apos;I only play with neighbors in my block&apos;</span>
  }
  <span class="md-code-comment">// accessing innermost here would throw</span>
}
<span class="md-code-comment">// accessing inner here would throw</span>
<span class="md-code-comment">// accessing innermost here would throw</span>
</code></pre> <p>Here is where things got interesting. As I wrote this example I thought <em>&#x201C;well, but if we now declare a function inside a block and access it from outside that block, things will <strong>surely go awry</strong>&#x201D;</em>. Based on my existing knowledge of ES5 I fully expected the following snippet of code to work, and it does in fact <em>work in ES5</em> but it&#x2019;s <a href="http://www.2ality.com/2015/02/es6-scoping.html" target="_blank" aria-label="Variables and scoping in ECMAScript 6, see section 7">broken in ES6</a>. That would&#x2019;ve been a problem because it&#x2019;d make super easy to expose block-scoped properties through functions that become hoisted outside of the block. I didn&#x2019;t expect this to <code class="md-code md-code-inline">throw</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">{
  <span class="md-code-keyword">let</span> _nested = <span class="md-code-string">&apos;secret&apos;</span>
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">nested</span> <span class="md-code-params">()</span> </span>{
    <span class="md-code-keyword">return</span> _nested
  }
}
<span class="md-code-built_in">console</span>.log(nested())
<span class="md-code-comment">// nested is not defined</span>
</code></pre> <p>As it turns out, this wasn&#x2019;t a bug in Babel, but in fact a <em>(much welcome)</em> change in ES6 language semantics.</p> <blockquote class="twitter-tweet"><p><a href="https://twitter.com/nzgb">@nzgb</a> <a href="https://twitter.com/rauschma">@rauschma</a> <a href="https://twitter.com/sebmck">@sebmck</a> AFAIR, this is correct - ES6 finally specified functions in blocks to behave as block-scoped.</p>&#x2014; Ingvar Stepanyan (@RReverser) <a href="https://twitter.com/RReverser/status/637349812485099520">August 28, 2015</a></blockquote> <p>Note that you can still expose nested <code class="md-code md-code-inline">let</code> things to outer scopes simply by assigning them to a variable that has more access. I wouldn&#x2019;t recommend you do this however, as there probably are cleaner ways to write code in these situations &#x2013; such as <strong>not using <code class="md-code md-code-inline">let</code> when you don&#x2019;t want block scoping</strong>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> nested
{
  <span class="md-code-keyword">let</span> _nested = <span class="md-code-string">&apos;secret&apos;</span>
  nested = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
    <span class="md-code-keyword">return</span> _nested
  }
}
<span class="md-code-built_in">console</span>.log(nested())
<span class="md-code-comment">// &lt;- &apos;secret&apos;</span>
</code></pre> <p>In conclusion, block scoping can be quite useful in new codebases. Some people will tell you to drop <code class="md-code md-code-inline">var</code> forever and just use <code class="md-code md-code-inline">let</code> everywhere. Some will tell you to never use <code class="md-code md-code-inline">let</code> because that&#x2019;s not the <em>One True Way of JavaScript</em>. My position might change over time, but this is it &#x2013; for the time being:</p> <blockquote> <p>I plan on using <code class="md-code md-code-inline">var</code> most of the time, and <code class="md-code md-code-inline">let</code> in those situations where I would&#x2019;ve otherwise hoisted a variable to the top of the scope for no reason, when they actually belonged inside a conditional or iterator code branch.</p> </blockquote> <h2 id="the-temporal-dead-zone-and-the-deathly-hallows">The <em>Temporal Dead Zone</em> and the Deathly Hallows</h2> <p>One last thing of note about <code class="md-code md-code-inline">let</code> is a mystical concept called the <a href="http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/" target="_blank" aria-label="Temporal Dead Zone (TDZ) Demystified">&#x201C;Temporal Dead Zone&#x201D; <em>(TDZ)</em></a> <em>&#x2013; ooh&#x2026; so scary, I know.</em></p> <p><img alt="enter image description here" class="" src="https://i.imgur.com/79mp6As.jpg"></p> <p>In so many words: if you have code such as the following, it&#x2019;ll throw.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">there = <span class="md-code-string">&apos;far away&apos;</span>
<span class="md-code-comment">// &lt;- ReferenceError: there is not defined</span>
<span class="md-code-keyword">let</span> there = <span class="md-code-string">&apos;dragons&apos;</span>
</code></pre> <p>If your code tries to access <code class="md-code md-code-inline">there</code> in any way before the <code class="md-code md-code-inline">let there</code> statement is reached, the program will throw. Declaring a method that references <code class="md-code md-code-inline">there</code> before it&#x2019;s defined is okay, as long as the method doesn&#x2019;t get executed while <code class="md-code md-code-inline">there</code> is in the TDZ, and <code class="md-code md-code-inline">there</code> will be in the TDZ for as long as the <code class="md-code md-code-inline">let there</code> statement isn&#x2019;t reached <em>(while the scope has been entered)</em>. This snippet won&#x2019;t throw because <code class="md-code md-code-inline">return there</code> isn&#x2019;t executed until after <code class="md-code md-code-inline">there</code> leaves the TDZ.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">readThere</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> there
}
<span class="md-code-keyword">let</span> there = <span class="md-code-string">&apos;dragons&apos;</span>
<span class="md-code-built_in">console</span>.log(readThere())
<span class="md-code-comment">// &lt;- &apos;dragons&apos;</span>
</code></pre> <p>But this snippet will, because access to <code class="md-code md-code-inline">there</code> occurs <em>before leaving the TDZ for <code class="md-code md-code-inline">there</code></em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">readThere</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> there
}
<span class="md-code-built_in">console</span>.log(readThere())
<span class="md-code-comment">// ReferenceError: there is not defined</span>
<span class="md-code-keyword">let</span> there = <span class="md-code-string">&apos;dragons&apos;</span>
</code></pre> <p>Note that the semantics for these examples doesn&#x2019;t change when <code class="md-code md-code-inline">there</code> isn&#x2019;t actually assigned a value when initially declared. The snippet below still throws, as it still tries to access <code class="md-code md-code-inline">there</code> before leaving the TDZ.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">readThere</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> there
}
<span class="md-code-built_in">console</span>.log(readThere())
<span class="md-code-comment">// ReferenceError: there is not defined</span>
<span class="md-code-keyword">let</span> there
</code></pre> <p>This snippet still works because it still leaves the TDZ before accessing <code class="md-code md-code-inline">there</code> in any way.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">readThere</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> there
}
<span class="md-code-keyword">let</span> there
<span class="md-code-built_in">console</span>.log(readThere())
<span class="md-code-comment">// &lt;- undefined</span>
</code></pre> <p>The only tricky part is to remember that <em>(when it comes to the TDZ)</em> functions work sort of like blackboxes until they&#x2019;re actually executed for the first time, so it&#x2019;s okay to place <code class="md-code md-code-inline">there</code> inside functions that don&#x2019;t get executed until we leave the TDZ.</p> <blockquote> <p>The whole point of the TDZ is to make it easier to catch errors where accessing a variable before it&#x2019;s declared in user code leads to unexpected behavior. This happened a lot with ES5 due both to hoisting and poor coding conventions. In ES6 it&#x2019;s easier to avoid. Keep in mind that hoisting still applies for <code class="md-code md-code-inline">let</code> as well &#x2013; this just means that the variables will be created when we enter the scope, and the TDZ will be born, but they will be inaccessible until code execution hits the place where the variable was actually declared, at which point we leave the TDZ and are cleared to use the variable.</p> </blockquote> <h2 id="const-statement">Const Statement</h2> <p>Phew. I wrote more than I ever wanted to write about <code class="md-code md-code-inline">let</code>. Fortunately for both of us, <code class="md-code md-code-inline">const</code> is quite similar to <code class="md-code md-code-inline">let</code>.</p> <ul> <li><code class="md-code md-code-inline">const</code> is also <em>block-scoped</em></li> <li><code class="md-code md-code-inline">const</code> also enjoys the marvels of <em>TDZ semantics</em></li> </ul> <p>There&#x2019;s also a couple of major differences.</p> <ul> <li><code class="md-code md-code-inline">const</code> variables must be declared using an initializer</li> <li><code class="md-code md-code-inline">const</code> variables can only be assigned to once, in said initializer</li> <li><code class="md-code md-code-inline">const</code> variables <strong>don&#x2019;t</strong> make the assigned value immutable</li> <li>Assigning to <code class="md-code md-code-inline">const</code> will fail silently</li> <li>Redeclaration of a variable by the same name <em>will</em> throw</li> </ul> <p>Let&#x2019;s go to some examples. First, this snippet shows how it follows block-scoping rules just like <code class="md-code md-code-inline">let</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> cool = <span class="md-code-string">&apos;ponyfoo&apos;</span>
{
  <span class="md-code-keyword">const</span> cool = <span class="md-code-string">&apos;dragons&apos;</span>  
  <span class="md-code-built_in">console</span>.log(cool)
  <span class="md-code-comment">// &lt;- &apos;dragons&apos;</span>
}
<span class="md-code-built_in">console</span>.log(cool)
<span class="md-code-comment">// &lt;- &apos;ponyfoo&apos;</span>
</code></pre> <p>Once a <code class="md-code md-code-inline">const</code> is declared, you can&#x2019;t change the reference or literal that&#x2019;s assigned to it.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> cool = { people: [<span class="md-code-string">&apos;you&apos;</span>, <span class="md-code-string">&apos;me&apos;</span>, <span class="md-code-string">&apos;tesla&apos;</span>, <span class="md-code-string">&apos;musk&apos;</span>] }
cool = {}
<span class="md-code-comment">// &lt;- &quot;cool&quot; is read-only</span>
</code></pre> <p>You can however, change the reference itself. It does not become immutable. You&#x2019;d have to use <a href="https://i.imgur.com/79mp6As.jpg" target="_blank"><code class="md-code md-code-inline">Object.freeze</code></a> to make the value itself immutable.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> cool = { people: [<span class="md-code-string">&apos;you&apos;</span>, <span class="md-code-string">&apos;me&apos;</span>, <span class="md-code-string">&apos;tesla&apos;</span>, <span class="md-code-string">&apos;musk&apos;</span>] }
cool.people.push(<span class="md-code-string">&apos;berners-lee&apos;</span>)
<span class="md-code-built_in">console</span>.log(cool)
<span class="md-code-comment">// &lt;- { people: [&apos;you&apos;, &apos;me&apos;, &apos;tesla&apos;, &apos;musk&apos;, &apos;berners-lee&apos;] }</span>
</code></pre> <p>You can also make other references to the <code class="md-code md-code-inline">const</code> that <em>can</em>, in fact, change.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> cool = { people: [<span class="md-code-string">&apos;you&apos;</span>, <span class="md-code-string">&apos;me&apos;</span>, <span class="md-code-string">&apos;tesla&apos;</span>, <span class="md-code-string">&apos;musk&apos;</span>] }
<span class="md-code-keyword">var</span> uncool = cool
uncool = { people: [<span class="md-code-string">&apos;edison&apos;</span>] } <span class="md-code-comment">// so uncool he&apos;s all alone</span>
<span class="md-code-built_in">console</span>.log(uncool)
<span class="md-code-comment">// &lt;- { people: [&apos;edison&apos;] }</span>
</code></pre> <p>I think <code class="md-code md-code-inline">const</code> is great because it allows us to mark things that we really need to preserve as such. Imagine the following piece of code, which does come up in some situations <em>&#x2013; sorry about the extremely contrived example.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">code</span> <span class="md-code-params">(groceries)</span> </span>{
  <span class="md-code-keyword">return</span> {eat}
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">eat</span> <span class="md-code-params">()</span> </span>{
    <span class="md-code-keyword">if</span> (groceries.length === <span class="md-code-number">0</span>) {
      <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;All out. Please buy more groceries to feed the code.&apos;</span>)
    }
    <span class="md-code-keyword">return</span> groceries.shift()
  }
}
<span class="md-code-keyword">var</span> groceries = [<span class="md-code-string">&apos;carrot&apos;</span>, <span class="md-code-string">&apos;lemon&apos;</span>, <span class="md-code-string">&apos;potato&apos;</span>, <span class="md-code-string">&apos;turducken&apos;</span>]
<span class="md-code-keyword">var</span> eater = code(groceries)
<span class="md-code-built_in">console</span>.log(eater.eat())
<span class="md-code-comment">// &lt;- &apos;carrot&apos;</span>
</code></pre> <p>I sometimes come across code where someone is trying to add more <code class="md-code md-code-inline">groceries</code> to the list, and they figure that doing the following would <em>just work</em>. In many cases this does work. However, if we&#x2019;re passing a reference to groceries to something else, the re-assignment wouldn&#x2019;t be carried away to that other place, and hard to debug issues would ensue.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// a few hundred lines of code later...</span>
groceries = [<span class="md-code-string">&apos;heart of palm&apos;</span>, <span class="md-code-string">&apos;tomato&apos;</span>, <span class="md-code-string">&apos;corned beef&apos;</span>]
</code></pre> <p>If <code class="md-code md-code-inline">groceries</code> were a constant in the piece of code above, this re-assignment would&#x2019;ve been far easier to detect. Yay, ES6! I can definitely see myself using <code class="md-code md-code-inline">const</code> a lot in the future, but I haven&#x2019;t quite internalized it yet.</p> <blockquote> <p>I guess more coding is in order!</p> </blockquote></div>
