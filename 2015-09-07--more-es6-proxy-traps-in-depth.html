<div><blockquote>
  <h1>More ES6 Proxy Traps in Depth</h1>
  <div><p>Hey there! This is <a href="http://localhost:3000/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Traps? Again?&#x201D;</em> &#x2013; in Depth</a>. Looking for other ES6 goodness? Refer to <a href="http://localhost:3000/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your &#x2026;</p></div>
</blockquote></div>

<div><p>Hey there! This is <a href="http://localhost:3000/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Traps? Again?&#x201D;</em> &#x2013; in Depth</a>. Looking for other ES6 goodness? Refer to <a href="http://localhost:3000/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="http://localhost:3000/articles/es6-destructuring-in-depth">destructuring</a>, <a href="http://localhost:3000/articles/es6-template-strings-in-depth">template literals</a>, <a href="http://localhost:3000/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="http://localhost:3000/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="http://localhost:3000/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="http://localhost:3000/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="http://localhost:3000/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>, <a href="http://localhost:3000/articles/es6-iterators-in-depth">iterators</a>, <a href="http://localhost:3000/articles/es6-generators-in-depth">generators</a>, <a href="http://localhost:3000/articles/es6-symbols-in-depth">Symbols</a>, <a href="http://localhost:3000/articles/es6-maps-in-depth">Maps</a>, <a href="http://localhost:3000/articles/es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="http://localhost:3000/articles/es6-proxies-in-depth">proxies</a>, and <a href="http://localhost:3000/articles/es6-proxy-traps-in-depth">proxy traps</a>. We&#x2019;ll be discussing about <em><strong>more</strong> ES6 proxy <strong>traps</strong></em> today.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="http://localhost:3000/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> <p>Note that <code class="md-code md-code-inline">Proxy</code> is harder to play around with as Babel doesn&#x2019;t support it unless the underlying browser has support for it. You can check out the <a href="http://kangax.github.io/compat-table/es6/" target="_blank">ES6 compatibility table</a> for supporting browsers. At the time of this writing, you can use <em>Microsoft Edge</em> or <em>Mozilla Firefox</em> to try out <code class="md-code md-code-inline">Proxy</code>. Personally, I&#x2019;ll be verifying my examples using <em>Firefox</em>.</p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="http://localhost:3000/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for reading that, and let&#x2019;s go into even more <code class="md-code md-code-inline">Proxy</code> <em>traps</em> now! If you haven&#x2019;t yet, I encourage you to read the previous article on <a href="http://localhost:3000/articles/es6-proxies-in-depth">the <code class="md-code md-code-inline">Proxy</code> built-in</a> for an introduction to the subject and the one about the <a href="http://localhost:3000/articles/es6-proxy-traps-in-depth">first few traps I covered</a>.</p></div>

<div><h2 id="but-wait-there-s-more-proxy-trap-handlers">But Wait! There&#x2019;s More&#x2026; <em>(Proxy Trap Handlers)</em></h2> <p>This article covers all the trap handlers that weren&#x2019;t covered by the two previous articles on proxies. For the most part, the traps that we discussed yesterday had to do with property manipulation, while the first five traps we&#x2019;ll dig into today have mostly to do with the object being proxied <em>itself</em>. The last two have to do with properties once again &#x2013; but they&#x2019;re a bit more involved than yesterday&#x2019;s traps, which were much easier to &#x201C;fall into&#x201D; <em>(the trap &#x2013; muahaha)</em> in your everyday code.</p> <ul> <li><a href="http://localhost:3000/#construct"><code class="md-code md-code-inline">construct</code></a> &#x2013; traps usage of the <code class="md-code md-code-inline">new</code> operator</li> <li><a href="http://localhost:3000/#getprototypeof"><code class="md-code md-code-inline">getPrototypeOf</code></a> &#x2013; traps internal calls to <code class="md-code md-code-inline">[[GetPrototypeOf]]</code></li> <li><a href="http://localhost:3000/#setprototypeof"><code class="md-code md-code-inline">setPrototypeOf</code></a> &#x2013; traps calls to <code class="md-code md-code-inline">Object.setPrototypeOf</code></li> <li><a href="http://localhost:3000/#isextensible"><code class="md-code md-code-inline">isExtensible</code></a> &#x2013; traps calls to <code class="md-code md-code-inline">Object.isExtensible</code></li> <li><a href="http://localhost:3000/#preventextensions"><code class="md-code md-code-inline">preventExtensions</code></a> &#x2013; traps calls to <code class="md-code md-code-inline">Object.preventExtensions</code></li> <li><a href="http://localhost:3000/#getownpropertydescriptor"><code class="md-code md-code-inline">getOwnPropertyDescriptor</code></a> &#x2013; traps calls to <code class="md-code md-code-inline">Object.getOwnPropertyDescriptor</code></li> </ul> <h3 id="construct"><code class="md-code md-code-inline">construct</code></h3> <p>You can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/construct" target="_blank" aria-label="handler.construct() on MDN"><code class="md-code md-code-inline">handler.construct</code></a> method to trap usage of the <code class="md-code md-code-inline">new</code> operator. Here&#x2019;s a quick <em>&#x201C;default implementation&#x201D;</em> that doesn&#x2019;t alter the behavior of <code class="md-code md-code-inline">new</code> at all. <em>Remember our friend the <a href="http://localhost:3000/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread operator</a>?</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  construct (target, args) {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">new</span> target(<mark class="md-mark md-code-mark">...args</mark>)
  }
}
</code></pre> <p>If you use the <code class="md-code md-code-inline">handler</code> options above, the <code class="md-code md-code-inline">new</code> behavior you&#x2019;re already used to would remain unchanged. That&#x2019;s great because it means whatever you&#x2019;re trying to accomplish you can still fall back to the <strong>default behavior</strong> <em>&#x2013; and that&#x2019;s always important.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">target</span> <span class="md-code-params">(a, b, c)</span> </span>{
  <span class="md-code-keyword">this</span>.a = a
  <span class="md-code-keyword">this</span>.b = b
  <span class="md-code-keyword">this</span>.c = c
}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-built_in">console</span>.log(<span class="md-code-keyword">new</span> proxy(<span class="md-code-number">1</span>,<span class="md-code-number">2</span>,<span class="md-code-number">3</span>))
<span class="md-code-comment">// &lt;- { a: 1, b: 2, c: 3 }</span>
</code></pre> <p>Obvious use cases for <code class="md-code md-code-inline">construct</code> traps include data massaging in the arguments, doing things that should always be done around a call to <code class="md-code md-code-inline">new proxy()</code>, logging and tracking object creation, and swapping implementations entirely. Imagine a proxy like the following in situations where you have inheritance <em>&#x201C;branching&#x201D;</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Automobile {}
<span class="md-code-keyword">class</span> Car extends Automobile {}
<span class="md-code-keyword">class</span> SurveillanceVan extends Automobile {}
<span class="md-code-keyword">class</span> SUV extends Automobile {}
<span class="md-code-keyword">class</span> SportsCar extends Car {}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">target</span> <span class="md-code-params">()</span> </span>{}
<span class="md-code-keyword">var</span> handler = {
  construct (target, args) {
    <span class="md-code-keyword">var</span> <mark class="md-mark md-code-mark">[status]</mark> = args
    <span class="md-code-keyword">if</span> (status === <span class="md-code-string">&apos;nsa&apos;</span>) {
      <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">new SurveillanceVan(...args)</mark>
    }
    <span class="md-code-keyword">if</span> (status === <span class="md-code-string">&apos;single&apos;</span>) {
      <span class="md-code-keyword">return</span> <span class="md-code-keyword">new</span> SportsCar(...args)
    }
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">new</span> SUV(...args) <span class="md-code-comment">// family</span>
  }
}
</code></pre> <p>Naturally, you could&#x2019;ve used a regular method for the branching part, but using the <code class="md-code md-code-inline">new</code> operator also makes sense in these types of situations, as you&#x2019;ll end up creating a new object in all code branches anyways.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-keyword">new</span> proxy(<span class="md-code-string">&apos;nsa&apos;</span>).constructor.name)
<span class="md-code-comment">// &lt;- `SurveillanceVan`</span>
</code></pre> <p>The most common use case for <code class="md-code md-code-inline">construct</code> traps yet may be something simpler, and that&#x2019;s extending the <code class="md-code md-code-inline">target</code> object right after creation, <em>&#x2013; and before anything else happens &#x2013;</em> in such a way that it better supports the <code class="md-code md-code-inline">proxy</code> gatekeeper. You might have to add a <code class="md-code md-code-inline">proxied</code> flag to the <code class="md-code md-code-inline">target</code> object, or something akin to that.</p> <h3 id="getprototypeof"><code class="md-code md-code-inline">getPrototypeOf</code></h3> <p>You can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getPrototypeOf" target="_blank" aria-label="handler.getPrototypeOf() on MDN"><code class="md-code md-code-inline">handler.getPrototypeOf</code></a> method as a trap for all of the following.</p> <ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" aria-label="__proto__ on MDN"><code class="md-code md-code-inline">Object.prototype.__proto__</code></a> property</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf" target="_blank" aria-label="Object.prototype.isPrototypeOf() on MDN"><code class="md-code md-code-inline">Object.prototype.isPrototypeOf()</code></a> method</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" aria-label="Object.getPrototypeOf() on MDN"><code class="md-code md-code-inline">Object.getPrototypeOf()</code></a> method</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf" target="_blank" aria-label="Reflect.getPrototypeOf() on MDN"><code class="md-code md-code-inline">Reflect.getPrototypeOf()</code></a> method</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" aria-label="instanceof on MDN"><code class="md-code md-code-inline">instanceof</code></a> operator</li> </ul> <p>You could use this <em>trap</em> to make an object pretend it&#x2019;s an <code class="md-code md-code-inline">Array</code>, when accessed through the proxy. However, note that that on its own isn&#x2019;t sufficient for the <code class="md-code md-code-inline">proxy</code> to be an actual <code class="md-code md-code-inline">Array</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  getPrototypeOf: <mark class="md-mark md-code-mark">target =&gt; <span class="md-code-built_in">Array</span>.prototype</mark>
}
<span class="md-code-keyword">var</span> target = {}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-built_in">console</span>.log(proxy <span class="md-code-keyword">instanceof</span> <span class="md-code-built_in">Array</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(proxy.push)
<span class="md-code-comment">// &lt;- undefined</span>
</code></pre> <p>Naturally, you could keep on patching your <code class="md-code md-code-inline">proxy</code> until you get the behavior you want. In this case, you may want to use a <code class="md-code md-code-inline">get</code> trap to mix the <code class="md-code md-code-inline">Array.prototype</code> with the actual back-end <code class="md-code md-code-inline">target</code>. Whenever a property isn&#x2019;t found on the <code class="md-code md-code-inline">target</code>, we&#x2019;ll use reflection to look it up on <code class="md-code md-code-inline">Array.prototype</code>. It turns out, this is <strong>good enough</strong> for most operations.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  getPrototypeOf: target =&gt; <span class="md-code-built_in">Array</span>.prototype,
  get (target, key) {
    <span class="md-code-keyword">return</span> Reflect.get(target, key) || <mark class="md-mark md-code-mark">Reflect.get(<span class="md-code-built_in">Array</span>.prototype, key)</mark>
  }
}
<span class="md-code-keyword">var</span> target = {}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-built_in">console</span>.log(proxy.push)
<span class="md-code-comment">// &lt;- function push () { [native code] }</span>
<mark class="md-mark md-code-mark">proxy.push(<span class="md-code-string">&apos;a&apos;</span>, <span class="md-code-string">&apos;b&apos;</span>)</mark>
<span class="md-code-built_in">console</span>.log(proxy)
<span class="md-code-comment">// &lt;- { 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 }</span>
</code></pre> <p>I definitely see some advanced use cases for <code class="md-code md-code-inline">getPrototypeOf</code> traps in the future, but it&#x2019;s too early to tell what patterns may come out of it.</p> <h3 id="setprototypeof"><code class="md-code md-code-inline">setPrototypeOf</code></h3> <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" aria-label="Object.setPrototypeOf() on MDN"><code class="md-code md-code-inline">Object.setPrototypeOf</code></a> method does exactly what its name conveys: it sets the prototype of an object to a reference to another object. It&#x2019;s considered the proper way of setting the prototype as opposed to using <code class="md-code md-code-inline">__proto__</code> which is a legacy feature <em>&#x2013; and now standarized as such.</em></p> <p>You can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/setPrototypeOf" target="_blank" aria-label="handler.setPrototypeOf() on MDN"><code class="md-code md-code-inline">handler.setPrototypeOf</code></a> method to set up a <em>trap</em> for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" aria-label="Object.setPrototypeOf() on MDN"><code class="md-code md-code-inline">Object.setPrototypeOf</code></a>. The snippet of code shown below doesn&#x2019;t alter the default behavior of changing a prototype to the value of <code class="md-code md-code-inline">proto</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  setPrototypeOf (target, proto) {
    <mark class="md-mark md-code-mark">Object.setPrototypeOf(target, proto)</mark>
  }
}
<span class="md-code-keyword">var</span> proto = {}
<span class="md-code-keyword">var</span> target = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
proxy.setPrototypeOf(proxy, proto)
<span class="md-code-built_in">console</span>.log(proxy.prototype === proto)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>The field for <code class="md-code md-code-inline">setPrototypeOf</code> is pretty open. You could simply not call <code class="md-code md-code-inline">Object.setPrototypeOf</code> and the trap would sink the call into a <em>no-op</em>. You could <code class="md-code md-code-inline">throw</code> an exception making the failure more explicit &#x2013; for instance if you deem the new prototype to be invalid or you don&#x2019;t want consumers pulling the rug from under your feet.</p> <p>This is a nice <em>trap</em> to have if you want proxies to have limited access to what they can do with your <code class="md-code md-code-inline">target</code> object. I would definitely implement a trap like the one below if I had any security concerns at all in a proxy I&#x2019;m passing away to third party code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  setPrototypeOf (target, proto) {
    <mark class="md-mark md-code-mark">throw <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;Changing the prototype is forbidden&apos;</span>)</mark>
  }
}
<span class="md-code-keyword">var</span> proto = {}
<span class="md-code-keyword">var</span> target = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
proxy.setPrototypeOf(proxy, proto)
<span class="md-code-comment">// &lt;- Error: Changing the prototype is forbidden</span>
</code></pre> <p>Then again, you may want to fail silently with no error being thrown at all if you&#x2019;d rather confuse the consumer &#x2013; and that may just make them go away.</p> <h3 id="isextensible"><code class="md-code md-code-inline">isExtensible</code></h3> <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible" target="_blank" aria-label="handler.isExtensible() on MDN"><code class="md-code md-code-inline">handler.isExtensible</code></a> method can be mostly used for logging or auditing calls to <code class="md-code md-code-inline">Object.isExtensible</code>. This <em>trap</em> is subject to a harsh invariant that puts a hard limit to what you can do with it.</p> <blockquote> <p>If <code class="md-code md-code-inline">Object.isExtensible(proxy) !== Object.isExtensible(target)</code>, then a <code class="md-code md-code-inline">TypeError</code> is thrown.</p> </blockquote> <p>You could use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible" target="_blank" aria-label="handler.isExtensible() on MDN"><code class="md-code md-code-inline">handler.isExtensible</code></a> trap to <code class="md-code md-code-inline">throw</code> if you don&#x2019;t want consumers to know whether the original object is extensible or not, but there seem to be limited situations that would warrant such an <strong>incarnation of evil</strong>. For completeness&#x2019; sake, the piece of code below shows a trap for <code class="md-code md-code-inline">isExtensible</code> that throws errors every once in a while, but otherwise behaves as expected.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  isExtensible (target) {
    <span class="md-code-keyword">if</span> (<span class="md-code-built_in">Math</span>.random() &gt; <span class="md-code-number">0.1</span>) {
      <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;gotta love sporadic obscure errors!&apos;</span>)
    }
    <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">Object.isExtensible(target)</mark>
  }
}
<span class="md-code-keyword">var</span> target = {}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.isExtensible(proxy))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.isExtensible(proxy))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.isExtensible(proxy))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.isExtensible(proxy))
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">Error: gotta love sporadic obscure errors!</mark></span>
</code></pre> <p>While this <em>trap</em> is nearly useless other than for auditing purposes and to cover all your bases, the <em>hard-to-break</em> invariant makes sense because there&#x2019;s also the <code class="md-code md-code-inline">preventExtensions</code> <em>trap</em>. <strong>That one is a little bit more useful!</strong></p> <h3 id="preventextensions"><code class="md-code md-code-inline">preventExtensions</code></h3> <p>You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/preventExtensions" target="_blank" aria-label="handler.preventExtensions() on MDN"><code class="md-code md-code-inline">handler.preventExtensions</code></a> to <em>trap</em> the <code class="md-code md-code-inline">Object.preventExtensions</code> method. When extensions are prevented on an object, new properties can&#x2019;t be added any longer <em>&#x2013; it can&#x2019;t be extended.</em></p> <p>Imagine a scenario where you want to selectively be able to <code class="md-code md-code-inline">preventExtensions</code> on some objects &#x2013; but not all of them. In this scenario, you could use a <code class="md-code md-code-inline">WeakSet</code> to keep track of the objects that should be extensible. If an object is in the set, then the <code class="md-code md-code-inline">preventExtensions</code> <em>trap</em> should be able to capture those requests and discard them. The snippet below does exactly that. Note that the <em>trap</em> always returns the opposite of <code class="md-code md-code-inline">Object.isExtensible(target)</code>, because it should report whether the object has been made non-extensible.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> mustExtend = <mark class="md-mark md-code-mark">new WeakSet()</mark>
<span class="md-code-keyword">var</span> handler = {
  preventExtensions (target) {
    <span class="md-code-keyword">if</span> (<mark class="md-mark md-code-mark">!mustExtend.has(target)</mark>) {
      <span class="md-code-built_in">Object</span>.preventExtensions(target)
    }
    <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">!<span class="md-code-built_in">Object</span>.isExtensible(target)</mark>
  }
}
</code></pre> <p>Now that we&#x2019;ve set up the <code class="md-code md-code-inline">handler</code> and our <code class="md-code md-code-inline">WeakSet</code>, we can create a back-end object, a <code class="md-code md-code-inline">proxy</code>, and add the back-end to our set. Then, you can try <code class="md-code md-code-inline">Object.preventExtensions</code> on the proxy and you&#x2019;ll notice it fails to prevent extensions to the object. This is the intended behavior as the <code class="md-code md-code-inline">target</code> can be found in the <code class="md-code md-code-inline">mustExtend</code> set.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = {}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<mark class="md-mark md-code-mark">mustExtend.add(target)</mark>
<span class="md-code-built_in">Object</span>.preventExtensions(proxy)
<span class="md-code-comment">// &lt;- TypeError: proxy preventExtensions handler returned false</span>
</code></pre> <p>If we removed the <code class="md-code md-code-inline">target</code> from the <code class="md-code md-code-inline">mustExtend</code> set before calling <code class="md-code md-code-inline">Object.preventExtensions</code>, then <code class="md-code md-code-inline">target</code> would be made non-extensible as originally intended.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = {}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
mustExtend.add(target)
<mark class="md-mark md-code-mark">mustExtend.delete(target)</mark>
<span class="md-code-built_in">Object</span>.preventExtensions(proxy)
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">Object.isExtensible(proxy)</mark>)
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>Naturally, you could use this distinction to prevent <code class="md-code md-code-inline">proxy</code> consumers from making the proxy non-extensible in cases where that could lead to undesired behavior. In most cases, you probably won&#x2019;t have to deal with this <em>trap</em>, though. That&#x2019;s because you&#x2019;re usually going to be working with the <em>back-end <code class="md-code md-code-inline">target</code></em> for the most part, and not so much with the <code class="md-code md-code-inline">proxy</code> object itself.</p> <h3 id="getownpropertydescriptor"><code class="md-code md-code-inline">getOwnPropertyDescriptor</code></h3> <p>You can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor" target="_blank" aria-label="handler.getOwnPropertyDescriptor()"><code class="md-code md-code-inline">handler.getOwnPropertyDescriptor</code></a> method as a trap for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" aria-label="Object.getOwnPropertyDescriptor() on MDN"><code class="md-code md-code-inline">Object.getOwnPropertyDescriptor</code></a>. It may return a property descriptor, such as the result from <code class="md-code md-code-inline">Object.getOwnPropertyDescriptor(target, key)</code>; or <code class="md-code md-code-inline">undefined</code>, signaling that the property doesn&#x2019;t exist. As usual, you also have the third option of throwing an exception, aborting the operation entirely.</p> <p>If we go back to our canonical <em>&#x201C;private property space&#x201D;</em> example, we could implement a <em>trap</em> such as the one seen below to prevent consumers from learning about property descriptors of private properties.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  <mark class="md-mark md-code-mark">getOwnPropertyDescriptor (target, key) {</mark>
    invariant(key, <span class="md-code-string">&apos;get property descriptor for&apos;</span>)
    <span class="md-code-keyword">return</span> <span class="md-code-built_in">Object</span>.getOwnPropertyDescriptor(target, key)
  }
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">invariant</span> <span class="md-code-params">(key, action)</span> </span>{
  <span class="md-code-keyword">if</span> (key[<span class="md-code-number">0</span>] === <span class="md-code-string">&apos;_&apos;</span>) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`Invalid attempt to ${action} private <span class="md-code-string">&quot;${key}&quot;</span> property`)
  }
}
<span class="md-code-keyword">var</span> target = {}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="md-code-string">&apos;_foo&apos;</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">Error: Invalid attempt to get property descriptor for private &quot;_foo&quot; property</mark></span>
</code></pre> <p>The problem with that approach is that you&#x2019;re effectively telling consumers that properties with the <code class="md-code md-code-inline">_</code> prefix are somehow off-limits. It might be best to conceal them entirely by returning <code class="md-code md-code-inline">undefined</code>. This way, your private properties will behave no differently than properties that are <em>actually absent</em> from the <code class="md-code md-code-inline">target</code> object.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  getOwnPropertyDescriptor (target, key) {
    <span class="md-code-keyword">if</span> (key[<span class="md-code-number">0</span>] === <span class="md-code-string">&apos;_&apos;</span>) {
      <mark class="md-mark md-code-mark">return</mark>
    }
    <span class="md-code-keyword">return</span> <span class="md-code-built_in">Object</span>.getOwnPropertyDescriptor(target, key)
  }
}
<span class="md-code-keyword">var</span> target = { <mark class="md-mark md-code-mark">_foo</mark>: <span class="md-code-string">&apos;bar&apos;</span>, baz: <span class="md-code-string">&apos;tar&apos;</span> }
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="md-code-string">&apos;wat&apos;</span>))
<span class="md-code-comment">// &lt;- undefined</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">Object.getOwnPropertyDescriptor(proxy, <span class="md-code-string">&apos;_foo&apos;</span>)</mark>)
<span class="md-code-comment">// &lt;- undefined</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="md-code-string">&apos;baz&apos;</span>))
<span class="md-code-comment">// &lt;- { value: &apos;tar&apos;, writable: true, enumerable: true, configurable: true }</span>
</code></pre> <p>Usually when you&#x2019;re trying to hide things it&#x2019;s best to have them try and behave as if they fell in some other category than the category they&#x2019;re actually in. Throwing, however, just sends the <em>&#x201C;there&#x2019;s something sketchy here, but we can&#x2019;t quite tell you what that is&#x2026;&#x201D;</em> message &#x2013; and the consumer will eventually find out why that is.</p> <blockquote> <p>Keep in mind that if debugging concerns outweight security concerns, you probably should go for the <code class="md-code md-code-inline">throw</code> statement.</p> </blockquote> <h1 id="conclusions">Conclusions</h1> <p>This has certainly been fun. I now have a much better understanding of what proxies can do for me, and I think they&#x2019;ll be an instant hit once ES6 starts gaining more traction. I for one can&#x2019;t be more excited about them becoming well-supported in more browsers soon. I wouldn&#x2019;t hold out my hopes about proxies for Babel, as many of the traps are <strong>ridiculously hard</strong> <em>(or downright impossible)</em> to implement in ES5.</p> <p>As we&#x2019;ve learned over the last few days, there&#x2019;s <strong>a myriad use cases</strong> for proxies. Off the top of my head, we can use <code class="md-code md-code-inline">Proxy</code> for all of the following.</p> <ul> <li>Add validation rules <em>&#x2013; and enforce them &#x2013;</em> on plain old JavaScript objects</li> <li>Keep track of every interaction that goes through a proxy</li> <li>Decorate objects without changing them at all</li> <li>Make certain properties on an object completely invisible to the consumer of a proxy</li> <li>Revoke access <em>at will</em> when the consumer should no longer be able to use a proxy</li> <li>Modify the arguments passed to a proxied method</li> <li>Modify the result produced by a proxied method</li> <li>Prevent deletion of specific properties through the proxy</li> <li>Prevent new definitions from succeeding, according to the desired property descriptor</li> <li>Shuffle arguments around in a constructor</li> <li>Return a result other than the object being <code class="md-code md-code-inline">new</code>-ed up in a constructor</li> <li>Swap out the prototype of an object for something else</li> </ul> <p>I can say without a shadow of a doubt that there&#x2019;s <strong>hundreds more of use cases</strong> for proxies. I&#x2019;m sure many libraries will adopt a pattern we&#x2019;ve discussed here in the series where a <em>&#x201C;back-end&#x201D;</em> <code class="md-code md-code-inline">target</code> object is created and used for storage purposes but the consumer is only provided with a <em>&#x201C;front-end&#x201D;</em> <code class="md-code md-code-inline">proxy</code> object with <em>limited and audited interaction</em> with the back-end.</p> <blockquote> <p>What would <em>you</em> use <code class="md-code md-code-inline">Proxy</code> for?</p> </blockquote> <p>Meet me tomorrow at&#x2026; say &#x2013; <em>same time?</em> We can talk about <code class="md-code md-code-inline">Reflect</code> then.</p></div>
