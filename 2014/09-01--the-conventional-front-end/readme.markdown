<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/the-conventional-front-end">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/the-conventional-front-end"><div></div></a>

<h1>The Conventional Front-End</h1>

<p><kbd>conventional</kbd> <kbd>front-end</kbd> <kbd>javascript</kbd> <kbd>measly</kbd> <kbd>xhr</kbd></p>

<blockquote><p>Conventions are a great thing. Frameworks such as Ruby on Rails and <a href="http://asp.net/" target="_blank">ASP.NET</a> MVC are good examples of conventional MVC implementations. Conventions are essentially &#x2026;</p></blockquote>

<div><p>Conventions are a great thing. Frameworks such as Ruby on Rails and <a href="http://asp.net/" target="_blank">ASP.NET</a> MVC are good examples of conventional MVC implementations. Conventions are essentially sensible defaults. For example, when you call <code class="md-code md-code-inline">return View()</code> without any arguments in <a href="http://asp.net/" target="_blank">ASP.NET</a> MVC, the framework does the reasonable thing: render the default view that maps to the controller action. This type of behavior can be observed throughout the framework.</p></div>

<div></div>

<div><p>When it comes to the front-end, conventions aren&#x2019;t as popular as I&#x2019;d like. In this article we&#x2019;ll take a look at <a href="https://github.com/bevacqua/measly" target="_blank"><code class="md-code md-code-inline">measly</code></a>, a conventional layer on top of <code class="md-code md-code-inline">XMLHttpRequest</code> you can use to get started in the conventional world.</p></div>

<div><blockquote> <p><strong>Everything is about context.</strong></p> </blockquote> <p>How many times have you seen or worked on web applications where dozens of <code class="md-code md-code-inline">XMLHttpRequest</code> objects were used to make AJAX requests? Pretty much any web application, right? What about doing the right thing when those requests fail? Not so many perhaps, but I&#x2019;d be willing to bet you still worked on quite a few where at least <code class="md-code md-code-inline">404</code> or <code class="md-code md-code-inline">500</code> status codes were handled. That&#x2019;s still not good enough if you are handling them every time, whenever you made a request.</p> <p>Maybe something like the piece of pseudo-code below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">$.get(<span class="md-code-string">&apos;/api/cats&apos;</span>).then(meow).fail(MEOWWW);
</code></pre> <p>A much better alternative is to centralize this kind of error checking, so that the rest of the application can live happily ever after without a worry in the world about status codes other than <code class="md-code md-code-inline">2xx</code>. That&#x2019;s where <a href="https://github.com/bevacqua/measly" target="_blank"><code class="md-code md-code-inline">measly</code></a> comes in. Measly allows you to easily define a layered hierarchy for your components. It&#x2019;s able to handle requests on any of these layers, or on the request itself.</p> <p>To get you started, the first thing you&#x2019;ll need to do is create a layer whenever a view or partial view is rendered. If you were using <a href="https://github.com/bevacqua/taunus" target="_blank">Taunus</a>, then that would be pretty easy. <a href="https://github.com/bevacqua/taunus" target="_blank">Taunus</a> let&#x2019;s you hook into the rendering engine and listen for views being rendered. You can use this hook to create a <code class="md-code md-code-inline">measly</code> layer associated to each view&#x2019;s container.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">taunus.on(<span class="md-code-string">&apos;render&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(container, model)</span> </span>{
  model.measly = measly.layer({ context: container });
});
</code></pre> <p>Once every view has it&#x2019;s own <code class="md-code md-code-inline">measly</code> layer, you could create a global hook to render error messages in the context for the layer where the failed request originated. Note that if I created the hook on <code class="md-code md-code-inline">model.measly</code> instead of just <code class="md-code md-code-inline">measly</code>, it would&#x2019;ve only affected requests on an specific view.</p> <p>The <code class="md-code md-code-inline">render</code> method shown below uses some code written in <a href="https://github.com/bevacqua/dominus" target="_blank"><code class="md-code md-code-inline">Dominus</code></a>, a jQuery-like library, to render the error messages. Since we&#x2019;re using the context of the partial where the request originated, the error will be displayed close to whatever the user was interacting with, at the top of that partial view. However, you could easily change the rendering logic if you wanted to.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">measly.on(<span class="md-code-number">404</span>, render);

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">render</span> <span class="md-code-params">(err, body)</span> </span>{
  <span class="md-code-keyword">var</span> context = $(<span class="md-code-keyword">this</span>.context);
  <span class="md-code-keyword">var</span> messages = $(<span class="md-code-string">&apos;&lt;ul&gt;&apos;</span>).addClass(<span class="md-code-string">&apos;vw-validation&apos;</span>);

  $(body.messages.map(dom)).appendTo(messages);

  context.find(<span class="md-code-string">&apos;.vw-validation&apos;</span>).remove();
  context.prepend(messages);
}

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">dom</span> <span class="md-code-params">(message)</span> </span>{
  <span class="md-code-keyword">return</span> $(<span class="md-code-string">&apos;&lt;li&gt;&apos;</span>).text(message).addClass(<span class="md-code-string">&apos;vw-validation-message&apos;</span>)[<span class="md-code-number">0</span>];
}
</code></pre> <p>Note that this approach to error reporting in the DOM forces you to have some sort of convention when it comes to JSON responses. That is a good thing, though!</p> <p>You&#x2019;re now able to make requests through measly and never again worry about failure responses. The example below shows how you could do that with access to the model, presumably in a partial view controller.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(model)</span> </span>{
  $(<span class="md-code-string">&apos;.ca-save&apos;</span>).on(<span class="md-code-string">&apos;click&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
    model.measly.put(<span class="md-code-string">&apos;/api/cats&apos;</span>, model.cat);
  });
}
</code></pre> <p>What other kinds of conventional tactics would you apply to your front-end architecture?</p></div>
