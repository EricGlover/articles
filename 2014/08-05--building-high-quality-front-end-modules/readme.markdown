<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/master/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/building-high-quality-front-end-modules">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/building-high-quality-front-end-modules"><div></div></a>

<h1>Building High-Quality Front-End Modules</h1>

<p><kbd>front-end</kbd> <kbd>open-source</kbd> <kbd>javascript</kbd> <kbd>jquery</kbd> <kbd>gulp</kbd> <kbd>modularity</kbd></p>

<blockquote><p>Lately I&#x2019;ve been developing front-end modules solely based on <a href="http://browserify.org/" target="_blank">Browserify</a>, the latest being <a href="https://github.com/bevacqua/rome" target="_blank">rome</a>. Rome is a calendar component that has an extensive feature-set. &#x2026;</p></blockquote>

<div><p>Lately I&#x2019;ve been developing front-end modules solely based on <a href="http://browserify.org/" target="_blank">Browserify</a>, the latest being <a href="https://github.com/bevacqua/rome" target="_blank">rome</a>. Rome is a calendar component that has an extensive feature-set. I&#x2019;ve compiled a list of highlights below.</p></div>

<div></div>

<div><ul> <li>Date <em>and time</em> picker</li> <li><em>Fancy</em> <a href="http://bevacqua.github.io/rome" target="_blank">demo site</a></li> <li>Use it on its own, or dedicated to an input</li> <li>Concise API and sensible defaults</li> <li>Date range just means validating two calendars against each other</li> <li><a href="https://ponyfoo.com/2013/07/09/getting-over-jquery">Doesn&#x2019;t rely on jQuery</a></li> <li>Works on <strong>IE7+</strong></li> </ul> <p>Rome wasn&#x2019;t conceived with all of these features out-of-the-box, though. When I released it for the first time, it was <em>just a native date-time picker</em> with a reasonable API, but it complete lacked IE support, date validation, and the ability to be used without an input field.</p> <p><a href="http://bevacqua.github.io/rome" target="_blank"><img src="https://i.imgur.com/jU8JmSs.jpg" alt="colosseum.png"></a></p> <p><em>Rome wasn&#x2019;t built in a day.</em></p></div>

<div><p>One of the <strong>core drivers</strong> for high-quality modules is <strong>open-source</strong>. Open-source <em>forces</em> you to <a href="https://ponyfoo.com/2014/01/20/how-to-design-great-programs" aria-label="How to Design Great Programs">think hard about the API</a> you&#x2019;re going to provide for your components, as well as put yourself in the shoes of an API consumer, and learn what you would like the API to be. Another module quality booster can be found in documentation. I love to thoroughly document the modules I build. This doesn&#x2019;t merely help outsiders, which would be too self-less. It also helps you pour your thoughts into words that explain the behavior of your API. If it&#x2019;s hard to describe, then chances are your API is hard to use as well.</p> <p><a href="http://bevacqua.io/buildfirst" target="_blank" aria-label="JavaScript Application Design: A Build First Approach">Automating your build process</a> is another crucial piece of the high-quality module puzzle. An <a href="https://ponyfoo.com/2014/01/27/my-first-gulp-adventure" aria-label="My First Gulp Adventure">automated build <strong>(and release)</strong> process</a> allows you to easily deploy new releases to <a href="http://npmjs.org/" target="_blank" aria-label="npmjs.org"><code class="md-code md-code-inline">npm</code></a>, <a href="http://bower.io/" target="_blank" aria-label="bower.io"><code class="md-code md-code-inline">Bower</code></a>, as well as creating a git tag on your public repository. Maintaining <a href="https://github.com/bevacqua/rome/blob/master/CHANGELOG.md" target="_blank" aria-label="CHANGELOG.md for bevacqua/rome on GitHub">a changelog</a> is almost a requirement when you are trying to keep your consumers up to date regarding your latest changes. Changes to your API should be reflected in both the documentation as well as the changelog, while internal code quality refactorings don&#x2019;t necessarily need to be reflected in the documentation.</p> <p>Remember: documentation should be relevant to the consumer, not the module author. This means that implementation details shouldn&#x2019;t be included in the documentation, because the consumer is only concerned about the public-facing API.</p> <h1 id="staying-away-from-jquery">Staying Away From jQuery</h1> <p>I developed Rome out of frustration, because I couldn&#x2019;t find a single date picker that had a reasonable API, didn&#x2019;t depend on jQuery, and still had good browser support. Every single component I found had something I disliked, maybe they didn&#x2019;t allow the human to change the date by typing into the input, they had a <code class="md-code md-code-inline">&lt;select&gt;</code> for the hour, another one for the minutes, and another for the period <em>(AM or PM)</em>. If features weren&#x2019;t the issue, their API was wildly incoherent, like the ones you find in jQuery UI components, or the component depended on jQuery.</p> <p>Don&#x2019;t get me wrong, <a href="http://jquery.com/" target="_blank">jQuery</a> is great if you&#x2019;re into it, but you must understand that <a href="https://ponyfoo.com/2013/06/10/uncovering-the-native-dom-api" aria-label="Uncovering the native DOM API">it isn&#x2019;t the be-all and end-all of JavaScript</a>. When it comes to components, abusing jQuery is even worse, because every dependency you decide on means that it&#x2019;s another dependency you are burdening the consumers with. This, in turn, signifies that the consumer will have to consider whether your library is worth adding that dependency for. Maybe you&#x2019;ve developed <a href="https://github.com/tonytomov/jqGrid" target="_blank" aria-label="jqGrid on GitHub">a great JavaScript grid component</a>, but deciding on jQuery meant that anyone who doesn&#x2019;t want jQuery in their project is unable to leverage your library. This issue is intensified if we consider libraries that depend on jQuery UI just for its dragging or resizing capabilities. I&#x2019;ve also seen things that depended on jQuery UI just because it adds animation and CSS color functionality into the core jQuery feature-set. That&#x2019;s just plain wrong, inadmissible.</p> <blockquote> <p>As module authors, we should be more thoughtful with regards to the consumer.</p> </blockquote> <p>What if someone wants to use your component with Angular? Angular already comes with <a href="https://github.com/angular/angular.js/blob/master/src/jqLite.js" target="_blank" aria-label="jqLite source for angular/angular.js on GitHub">a &#x201C;lite&#x201D; version</a> of jQuery, why would they use jQuery as well? What if they are already using one of the myriad of other jQuery-like libraries out there? Are they supposed to use two of those now, because your stubborn component expects them to use just-such bloated library? I don&#x2019;t think so. A better approach is to learn about the native DOM API across different browsers, and use that to your advantage. I&#x2019;m not saying you should re-implement jQuery from scratch, but at the very least do your consumers a favor and use <a href="http://projects.jga.me/jquery-builder/" target="_blank" aria-label="jQuery Builder">a custom build</a>, or go for a module that just <a href="http://sizzlejs.com/" target="_blank" aria-label="Sizzle.js JavaScript Selector Engine">does what you actually need</a> out of jQuery.</p> <p>Now that that rant is out of the way, let&#x2019;s talk API.</p> <h1 id="api-design-is-tough">API Design is Tough</h1> <p>The best way to produce a high-quality API is to start with that. Ask yourself what API you would like to use.</p> <blockquote> <p>Ask yourself what an attractive API should behave like, and <em>implement that!</em></p> </blockquote> <p>The API isn&#x2019;t only about what methods to expose, but also about being consistent throughout all of those methods, and making it terribly simple to use. A great API is intuitive, meaning that the consumer is able to <em>correctly</em> guess what a method is called, or how an option is going to be named, or how the component is going to react to different configuration. Designing an API to be intuitive takes using lots of different APIs and learning over time what makes them tick.</p> <p>In the case of Rome I started with a single <code class="md-code md-code-inline">index.html</code> file with some CSS and JS in it that contained what the API should look like.</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">id</span>=<span class="md-code-value">&apos;foo&apos;</span> /&gt;</span>
</code></pre> <pre class="md-code-block"><code class="md-code md-lang-javascript">rome(foo);
</code></pre> <p>Making that available on a <code class="md-code md-code-inline">github.io</code> page was just a matter of creating a <code class="md-code md-code-inline">gh-pages</code> branch and pushing to it.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">git checkout -b gh-pages
git push -u origin gh-pages
</code></pre> <p>Now the demo is up at <code class="md-code md-code-inline">{user-name}.github.io/{repo-name}</code>, which in this case is <a href="http://bevacqua.github.io/rome" target="_blank" aria-label="Rome on GitHub Pages"><code class="md-code md-code-inline">bevacqua.github.io/rome</code></a>. A nice screenshot on the <strong>README</strong> always helps drive people to the demo page, as well as signaling some seriousness applies to the project. This is a great testing ground for both consumers and ourselves, when testing out new pieces of functionality.</p> <p><a href="http://bevacqua.github.io/rome" target="_blank" aria-label="Rome on GitHub Pages"><img alt="gh-pages.png" class="" src="https://cloud.githubusercontent.com/assets/934293/3803583/387125ea-1c1c-11e4-974e-467984e4d1f0.png"></a></p> <p>The great thing of having a live demo page readily available is that fellow open-sorcerers will help you with blatant bugs, even if they&#x2019;re only mildly interested on your project. Better yet, you yourself will be able to spot bugs such as inconsistencies in your API, or irritatingly missing portions of functionality. For example, when I first put together <code class="md-code md-code-inline">rome</code> it was barely a date-time picker that latched itself onto input fields. Then I realized people may want it decoupled from an input field, maybe for read-only purposes. Later, I added date ranges and validation that allows you to deem specific dates invalid, in those cases where you want to disallow holidays or just sundays, for example.</p> <h3 id="flexible-yet-consistent"><em>Flexible</em>, yet consistent</h3> <p>I consider flexibility to be <strong>one of the qualities all great APIs seem to have</strong>. Take a look at the <a href="http://api.jquery.com/" target="_blank" aria-label="jQuery API Documentation">jQuery API</a>. It almost feels like you could throw anything at it and it&#x2019;ll just work, most often doing what you want it to. The key is to be flexible on the inputs, and consistent on the outputs. This means that when you&#x2019;re taking input from the API consumer, you should allow them to throw anything at you, within reason. In the case of <code class="md-code md-code-inline">rome</code>, I allow input dates as native <code class="md-code md-code-inline">Date</code> objects, <a href="http://momentjs.com/" target="_blank" aria-label="moment.js: Parse, validate, manipulate, and display dates in javascript."><code class="md-code md-code-inline">moment</code></a> objects, or date strings. Internally, I always use <code class="md-code md-code-inline">moment</code> objects, because of their sheer power when it comes to computing date arithmetics, <em>something I didn&#x2019;t want to burden myself with</em>. Date manipulation is <a href="http://stackoverflow.com/q/6841333/389745" target="_blank" aria-label="Why is subtracting these two times (in 1927) giving a strange result?">incredibly hard to get right</a>.</p> <p>Being flexible is great for inputs, but in the case of outputs its <strong>consistency</strong> what you want. This means that if you allow chaining, then any method that doesn&#x2019;t have an explicit return value should return the API object instance itself. Whatever the return value for any given method, it should be properly documented so that consumers aren&#x2019;t surprised. You may want to blow their minds with what your library can do, but you definitely don&#x2019;t want to blow anyone&#x2019;s mind with an unstable API producing varying results depending on the provided inputs.</p> <h3 id="flexible-yet-reasonable"><em>Flexible</em>, yet reasonable</h3> <p>Being flexible doesn&#x2019;t mean being insanely hard to configure. I think this is where most API designers get it wrong. It&#x2019;s not just about providing a bunch of options for every single action your library can take, but it&#x2019;s also about being able to determine sensible defaults that the consumer can accept most of the time. This way, if you do things right, people won&#x2019;t have to modify the default behavior unless they want to reach a more complex functionality quota.</p> <p>Once you&#x2019;ve bolted down a basic API, you can start defining what the default functionality should look like. In this case I decided choosing both a date and a time would be reasonable defaults, while being able to turn either off setting <code class="md-code md-code-inline">date: false</code> or <code class="md-code md-code-inline">time: false</code> in the <em>(also optional)</em> options object that you can provide to the component.</p> <p>Another sign of being reasonable is leaving room for composability. Face it, <strong>your API shouldn&#x2019;t be able to do just about anything</strong>. It should be able to do <em>just enough</em>, but just enough in ways that can be put together and interact with each other.</p> <p>Consider as an example how you could create a link between two calendars, where one is a start date and the other is an end date. Here&#x2019;s how you would do it with <code class="md-code md-code-inline">rome</code>. Just like I mentioned earlier about flexible inputs, these validators accept a DOM element associated with a calendar, a <code class="md-code md-code-inline">Date</code>, a <code class="md-code md-code-inline">moment</code>, or a date string.</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">id</span>=<span class="md-code-value">&apos;start&apos;</span> /&gt;</span>
<span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">id</span>=<span class="md-code-value">&apos;end&apos;</span> /&gt;</span>
</code></pre> <pre class="md-code-block"><code class="md-code md-lang-javascript">rome(start, { dateValidator: rome.val.beforeEq(end) });
rome(end, { dateValidator: rome.val.afterEq(start) });
</code></pre> <p>This is how jQuery achieves the same functionality.</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">id</span>=<span class="md-code-value">&apos;start&apos;</span> /&gt;</span>
<span class="md-code-tag">&lt;<span class="md-code-title">input</span> <span class="md-code-attribute">id</span>=<span class="md-code-value">&apos;end&apos;</span> /&gt;</span>
</code></pre> <pre class="md-code-block"><code class="md-code md-lang-javascript">$(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  $(<span class="md-code-string">&apos;#start&apos;</span>).datepicker({
    onClose: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(value)</span> </span>{
      $(<span class="md-code-string">&apos;#end&apos;</span>).datepicker(<span class="md-code-string">&apos;option&apos;</span>, <span class="md-code-string">&apos;minDate&apos;</span>, value);
    }
  });
  $(<span class="md-code-string">&apos;#end&apos;</span>).datepicker({
    onClose: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(value)</span> </span>{
      $(<span class="md-code-string">&apos;#start&apos;</span>).datepicker(<span class="md-code-string">&apos;option&apos;</span>, <span class="md-code-string">&apos;maxDate&apos;</span>, value);
    }
  });
});
</code></pre> <p>What if the calendar is inline? Surely there won&#x2019;t be any <code class="md-code md-code-inline">&apos;close&apos;</code> events in that case, and you&#x2019;d have to look for other examples to achieve the same functionality. Suppose that now you want to ignore some dates, with a raw approach like the <code class="md-code md-code-inline">dateValidator</code> used in Rome, you would just have to return <code class="md-code md-code-inline">false</code> for invalid dates. In the case of jQuery datepicker, the API leaks knowledge about the inner workings of the calendar, exposing a <code class="md-code md-code-inline">beforeShowDay</code> method for which I&#x2019;ll just paste their API documentation here rather than <em>try to explain it</em> myself.</p> <blockquote> <p>A function that takes a date as a parameter and must return an array with:</p> <p><code class="md-code md-code-inline">[0]</code>: <code class="md-code md-code-inline">true</code> or <code class="md-code md-code-inline">false</code> indicating whether or not this date is selectable<br> <code class="md-code md-code-inline">[1]</code>: a CSS class name to add to the date&#x2019;s cell or <code class="md-code md-code-inline">&apos;&apos;</code> for the default presentation<br> <code class="md-code md-code-inline">[2]</code>: an optional popup tooltip for this date</p> </blockquote> <p>So, in order to determine that a date is invalid I&#x2019;d have to do <code class="md-code md-code-inline">return [false, &apos;&apos;]</code>. <strong>Eww!</strong></p> <p>In contrast, having something like <code class="md-code md-code-inline">dateValidator</code> which <strong>the calendar just knows to call whenever it needs to validate a date</strong>, you could centralize date validation and let the consumer blissfully ignore internal implementation details such as that you&#x2019;ll call that method whenever a day is rendered on the calendar to know whether it&#x2019;s a valid date for the human to pick. Nevertheless, this is probably <em>the least</em> of <strong>jQuery UI&#x2019;s API problems</strong>, especially when pitted against jQuery, which has quite a pleasant API.</p> <blockquote> <p>The bottom line is that your API shouldn&#x2019;t be an assortment of corner-case-handling options, but rather provide a few concise solutions to abstract problems. Abstract enough that you can get away with defining a few of those and still allow consumers to use it for a variety of different use cases.</p> </blockquote> <p>This brings me back to ditching jQuery, which leaves us with a grab-bag filled with browser quirks you&#x2019;ll need to take care of.</p> <h1 id="browsers-are-hard-but-worth-learning">Browsers Are Hard, But Worth Learning</h1> <p>Time and again jQuery has come up as an excuse for completely ignoring the <a href="https://ponyfoo.com/2013/06/10/uncovering-the-native-dom-api" aria-label="Uncovering the native DOM API">API provided natively</a> by different browsers, but the truth is that nothing is going to replace learning about what jQuery does under the hood. There&#x2019;s a few ways you could go about that. You could delve into the jQuery source, and familiarize yourself with what and why jQuery does things the way it does, <a href="https://github.com/bevacqua?tab=activity" target="_blank" aria-label="My Open-Source Activity on GitHub">you could try to develop a cross-platform component or website</a> that doesn&#x2019;t rely on jQuery to work out the kinks across different browsers, or you could simply <a href="https://developer.mozilla.org/en-US/" target="_blank" aria-label="Mozilla Developer Network">read about those things online</a>.</p> <p>Some of the most common quirks you&#x2019;ll have to deal with along the way to becoming a cross-platform module-hurling ninjasaur legend, <em>&#x2014; many of which I had to deal with when putting together <code class="md-code md-code-inline">rome</code> and others before it &#x2014;</em> are listed below.</p> <h3 id="polyfills">Polyfills</h3> <p>Rome started as cutting-edge browser material, <strong>breaking every rule about <a href="http://en.wikipedia.org/wiki/Progressive_enhancement" target="_blank" aria-label="Progressive Enhancement on Wikipedia">progressive enhancement</a> out there</strong>, but it eventually made its way into the dark heart of <strong>IE7</strong>. One of the most straightforward changes you have to make to support old browsers are <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/" target="_blank" aria-label="What is a Polyfill?">polyfills</a>, which are drop-in pieces of code that can <em>&#x201C;turn on&#x201D;</em> new functionality in older browsers that don&#x2019;t natively support it.</p> <p>In the case of Rome, I required <a href="https://github.com/bevacqua/rome/tree/master/src/polyfills" target="_blank" aria-label="Polyfills in bevacqua/rome@master on GitHub">quite a few of these</a> polyfills, as I happen to be quite fond of the functional array methods introduced in ES6. You don&#x2019;t always have it that easy.</p> <p>Some times new functionality demands special behavior, such as implementing getters or setters, but most of the time you&#x2019;ll find that there are ways to work around these limitations even in the oldest of browsers.</p> <blockquote> <p>What you <strong>can&#x2019;t polyfill</strong>, You can <em>work around!</em></p> </blockquote> <h3 id="working-around-new-behavior">Working Around New Behavior</h3> <p>DOM events are a clear example of this case. In some versions of IE, DOM nodes don&#x2019;t even share a prototype, and in these cases it&#x2019;s just best to take the few cases where you were attaching event listeners through the <a href="http://mdn.beonex.com/en/DOM/element.addEventListener.html" target="_blank" aria-label="addEventListener on MDN"><code class="md-code md-code-inline">addEventListener</code></a> API and replace that with a cross-browser method that doesn&#x2019;t have to be a polyfill.</p> <p>The difference lies in that using a polyfill shouldn&#x2019;t require you to change any of your existing code that currently functions on newer browser implementations. Meanwhile, by changing your existing code you could simply create a wrapper around the native browser APIs in a cross-browser fashion, just like jQuery does <em>&#x2014; but at a smaller scale &#x2014;</em> <strong>only for the desired browser API, and not for all the things</strong>. In the case of Rome I implemented <a href="https://github.com/bevacqua/rome/blob/master/src/events.js" target="_blank" aria-label="Cross-browser event handling in Rome">my own cross-browser event handling</a> implementation and adjusted the places I used <a href="http://mdn.beonex.com/en/DOM/element.addEventListener.html" target="_blank" aria-label="addEventListener on MDN"><code class="md-code md-code-inline">addEventListener</code></a> to use that instead.</p> <h3 id="shaving-off-implementation-discrepancies">Shaving Off Implementation Discrepancies</h3> <p>There&#x2019;s quite a few issues that arise when trying to attain a cross-platform module. Most of which, you could work around just like I mentioned in the previous paragraph: centralize your utilization of the piece of functionality, and fix the issue in that centralized location. I listed a few below.</p> <h4 id="innertext-vs-textcontent"><code class="md-code md-code-inline">innerText</code> vs <code class="md-code md-code-inline">textContent</code></h4> <p>This one shows how often browser vendors can&#x2019;t even agree on a property name, or a spec. In this case, Mozilla decided to implement <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node.textContent" target="_blank" aria-label="textContent on MDN"><code class="md-code md-code-inline">textContent</code></a>, whereas IE went for a propietary <a href="http://msdn.microsoft.com/en-us/library/ie/ms533899(v=vs.85).aspx" target="_blank" aria-label="innerText on MSDN"><code class="md-code md-code-inline">innerText</code></a>. Besides the name, there&#x2019;s also some corner-cases where the resulting text isn&#x2019;t always what you&#x2019;d expect, and <a href="http://stackoverflow.com/q/6272767/389745" target="_blank" aria-label="Firefox&apos;s textContent doesn&apos;t match Chrome&apos;s innerText">some people recommend walking the DOM tree</a> and generating the results oneself.</p> <h4 id="the-touchend-event">The <code class="md-code md-code-inline">&apos;touchend&apos;</code> event</h4> <p>This one is quite awkward, but as it turns out iOS isn&#x2019;t very fond of clicks on focused input fields, and as a result they won&#x2019;t fire any <code class="md-code md-code-inline">&apos;click&apos;</code> events on a field that&#x2019;s already focused when tapped again. For my calendar component, this meant that tapping on an input field would only work before selecting a date for the first time, and if the focus didn&#x2019;t change you wouldn&#x2019;t be able to get the calendar to show up ever again. Typically, you can <a href="https://github.com/bevacqua/rome/commit/fb8fc070fd4bc8b49009bff4b34c1b904f80a025" target="_blank" aria-label="&apos;touchend on input to show&apos; commit on GitHub">get rid of this issue</a> by listening for the <code class="md-code md-code-inline">&apos;touchend&apos;</code> event as well, which fires when the finger is lifted, as expected.</p> <h3 id="compromising-on-known-limitations">Compromising On Known Limitations</h3> <p>Another useful take on implementing unsupported functionality is knowing your limitations well. In Rome I needed a clone function that was used across the codebase for cloning the options object the consumer passes in, so that they can&#x2019;t inadvertently change an option after passing them to the API. To this end I implemented <a href="https://github.com/bevacqua/rome/blob/master/src/clone.js" target="_blank" aria-label="clone.js for bevacqua/rome on GitHub">a na&#xEF;ve clone method</a> that knows exactly what to expect, since it&#x2019;s only used for that purpose. If you can&#x2019;t define the limitations of a method, then you&#x2019;ll have to implement it as broadly as possible, and definitely not as a polyfill, which should cover corner cases too, because it could potentially be used by third-parties.</p> <h1 id="bottom-line-the-bare-minimum">Bottom Line: The Bare Minimum</h1> <p>The bottom line is that you should be doing the bare minimum that needs to be done to support browsers as lowly as least graced one you are willing to support. In this case, it made sense to go all the way down to IE7, because the component was popular enough that it made supporting the oldest browsers worth it. This isn&#x2019;t always the case, maybe your component is an MVC library that just can&#x2019;t picture itself being used in a world without <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history" target="_blank" aria-label="Manipulating the browser history">a history API</a>. If this is a centerpiece of your component, then it&#x2019;s okay not to support browsers older than that, or alternatively to provide a graceful degradation fallback such as the [URL hash router] that you can see in Backbone or Angular when the <em>&#x201C;HTML5 mode&#x201D;</em> is turned off. If this piece of functionality isn&#x2019;t central to your component, maybe you could consider creating a separate library that adds that functionality, and that way consumers could still benefit from the rest, even if they need to support older browsers.</p> <p>The bare minimum rule doesn&#x2019;t only apply to browser support, but also to everything you do when it comes to modules. This is your bottom line. You can see this <a href="http://codepen.io/bevacqua/pen/vExbd" target="_blank" aria-label="Rome being used in a demo on CodePen">portrayed in a demo on CodePen</a>, where you&#x2019;ll notice that you may not even need the stylesheet that comes with it, if you decide to roll a few styles of your own. This kind of simplicity enables the consumer to do great things with the software you produce, <strong>by extending it and adapting it to their needs</strong>.</p> <blockquote> <p>Every great piece of open-source software I&#x2019;ve come across has simplicity written all over it.</p> </blockquote> <p>Open source is <strong>such fun</strong>, are you <em>willing</em> to give it a try?</p></div>
