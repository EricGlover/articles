<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/taunus-micro-isomorphic-mvc-framework">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/taunus-micro-isomorphic-mvc-framework"><div><img src="https://i.imgur.com/ZcDBhjW.jpg" alt="Taunus: Micro Isomorphic MVC Framework"></div></a>

<h1>Taunus: Micro Isomorphic MVC Framework</h1>

<p><kbd>isomorphic</kbd> <kbd>taunus</kbd> <kbd>browserify</kbd> <kbd>npm-run</kbd></p>

<blockquote><p>I&#x2019;ve mentioned <a href="https://github.com/bevacqua/taunus" target="_blank">Taunus</a> in <a href="https://ponyfoo.com/2014/05/16/modularizing-your-front-end">one of my latest articles</a>. I believe Taunus <em>is interesting</em>, not because it introduces innovative paradigm shifts or the like, but rather, &#x2026;</p></blockquote>

<div><p>I&#x2019;ve mentioned <a href="https://github.com/bevacqua/taunus" target="_blank" rel="noopener noreferrer">Taunus</a> in <a href="https://ponyfoo.com/2014/05/16/modularizing-your-front-end">one of my latest articles</a>. I believe Taunus <em>is interesting</em>, not because it introduces innovative paradigm shifts or the like, but rather, because it takes a proven concept, and iterates upon it. Bluntly put, Taunus builds upon the design of <a href="https://github.com/rendrjs/rendr" target="_blank" rel="noopener noreferrer">Rendr</a>. By all accounts, Rendr was amazing. I read a lot about Rendr before even trying it out. I was really excited about it. What could be wrong? I mean, you had convention over configuration, shared rendering, and reused modules. If you tried either Ruby on Rails or <em><a href="http://asp.net/" target="_blank" rel="noopener noreferrer">ASP.NET</a> MVC 3+</em>, both of those are pretty conventional as well. Eventually, I had to use Rendr in order to determine if it was <em>&#x201C;good enough&#x201D;</em> to recommend it in <a href="http://bevacqua.io/buildfirst" target="_blank" rel="noopener noreferrer">JavaScript Application Design</a>, as the &#x201C;go-to&#x201D; approach for shared-rendering in large scale applications.</p></div>

<blockquote></blockquote>

<div><p>That would set me up to write about Rendr in my book and forget about shared rendering. I figured it&#x2019;d be mostly a drop-in plugin for Backbone. I was thorougly wrong. Getting started with the bare minimum viable Rendr is <strong>nothing short of painful</strong>. You can check it out for yourself. The <a href="https://github.com/rendrjs/rendr/tree/master/examples/00_simple" target="_blank" rel="noopener noreferrer">so-called &#x201C;simple&#x201D; example</a> in Rendr&#x2019;s repository on GitHub almost rendered me to tears. I get it. Rendr requires Backbone. Backbone requires jQuery. Fine, I accept those terms. Rendr takes a <strong>&#x201C;Convention over Configuration&#x201D;</strong> approach. That&#x2019;s awesome! I loved that back when I was involved in C# MVC application development. Well, yeah. Except Rendr isn&#x2019;t so much about <strong>&#x201C;Convention over Configuration&#x201D;</strong>, but more about <strong>&#x201C;Convention, deal with it&#x201D;</strong>. To the point where you must conform to multiple different rules.</p> <ul> <li>You <a href="https://github.com/rendrjs/rendr/blob/master/examples/00_simple/Gruntfile.js#L66-L98" target="_blank" rel="noopener noreferrer"><strong>must</strong> browserify</a> your client-side code in <strong>obscure ways</strong> <ul> <li><a href="https://github.com/substack/brfs" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">brfs</code></a> won&#x2019;t work at all</li> <li>jQuery must be shimmed even though it&#x2019;s available on <code class="md-code md-code-inline">npm</code></li> <li>Furthermore, the server-side piece of Rendr uses a hard-coded version of jQuery, independently of the one you pick for the client-side</li> <li>You must define aliases in a so-and-so way (<a href="http://www.amazon.com/Surely-Feynman-Adventures-Curious-Character/dp/0393316041" target="_blank" rel="noopener noreferrer">Richard Feynmann tainted my writing style</a>, so be it)</li> </ul> </li> <li>Your templates <strong>must</strong> be placed into <code class="md-code md-code-inline">app/templates/compiledTemplates.js</code>. Seriously?</li> <li>Handlebars. Backbone. jQuery. Deal with it.</li> <li>Awkward APIs like <code class="md-code md-code-inline">this.app.fetch</code></li> <li><strong>Thorough lack of documentation</strong></li> </ul> <p>After asking <a href="https://twitter.com/spikebrehm" target="_blank" rel="noopener noreferrer">Spike Brehm</a> about it on Twitter, and figuring out <a href="https://twitter.com/spikebrehm/status/461939437585190912" target="_blank" rel="noopener noreferrer">he&#x2019;s pretty much moved on</a> from Rendr, I&#x2019;ve decided not to adopt it, and strike out on my own. I&#x2019;m really looking forward to the <strong>Building Isomorphic Apps</strong> talk, which he&#x2019;ll be giving in JSConf next week.</p> <figure class="figure-has-loaded"><a href="https://github.com/bevacqua/taunus" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/b98a5dc441b3a71a01e2e46639ddf57737c2c721/68747470733a2f2f7261772e6769746875622e636f6d2f62657661637175612f7461756e75732f6d61737465722f7265736f75726365732f7461756e75732e706e67" alt="taunus.png"></a></figure></div>

<div><p>Putting together a client-side MVC framework is no easy feat. <a href="https://ponyfoo.com/2012/12/29/single-page-design-madness" aria-label="Single Page Design Madness (2012)">I should know</a>. I tried back in the day, when putting together this blog engine. I failed misreably back then. This time, though, I made an effort to mix the best of both worlds. I decided to go back to basics and write a framework that was built around modularity, MVC, events, and shared-rendering.</p> <h2 id="taunus-architecture-overview">Taunus Architecture Overview</h2> <p>The hardest dependency you&#x2019;ll find in Taunus is on Express. Taunus itself doesn&#x2019;t utilize Express, but it expects routes to be in the same format that Express expects, and it also expects you to pass it an object with a <code class="md-code md-code-inline">get</code> method, which will be called once for every route, with a few middleware functions. As long as you&#x2019;re able to comply with those terms, Taunus will work well for you. The routing constraint is particularly interesting, because Taunus uses <a href="https://github.com/aaronblohowiak/routes.js" target="_blank" rel="noopener noreferrer" aria-label="Minimalist routing library, extracted from connect">the Express router</a> on the client-side. Thus, using that same router in the server-side becomes a necessity for consistency.</p> <p>That being said, there&#x2019;s nothing to stop you from making use of <code class="md-code md-code-inline">routes</code> on an <code class="md-code md-code-inline">http</code> server instance, pass a <code class="md-code md-code-inline">{ get: fn }</code> object to <code class="md-code md-code-inline">taunus.mount</code>, and ditch Express!</p> <p>Taunus deals mainly in the four components explained below. When Taunus is hit with a request, the router will call your controller action in the server-side. Once the controller action method is done, the view renderer will take the model provided by the action, and render the view. The server is now done. When the client-side starts up, it&#x2019;ll invoke the client-side controller for that view. Suppose now that another page is requested. Taunus will query that same endpoint using an <code class="md-code md-code-inline">Accepts: &apos;application/json&apos;</code> header, and the server will return JSON instead of the fully rendered page. Taunus uses that JSON data in the client-side to render your view, and then calls the client-side controller, just like it did on page load.</p> <figure><img alt="architecture.png" title="Taunus Stack" class="" src="https://i.imgur.com/cHacWdA.png"></figure> <p>It&#x2019;s easiest to explain how Taunus works with an example walk-through.</p> <ol> <li>Incoming request <code class="md-code md-code-inline">/articles/taunus-is-awesome</code></li> <li>Router matches <code class="md-code md-code-inline">/articles/:slug</code>, and invokes the controller for that action</li> <li>The <code class="md-code md-code-inline">articles/slug</code> action controller fetches a model from the database</li> <li>In the controller action, we assign a model to <code class="md-code md-code-inline">res.viewModel</code>, and call <code class="md-code md-code-inline">next()</code></li> <li>Taunus renders the partial for this view, and wraps it with the view layout</li> <li>The client-side takes over, and it figures out its the first time around, so it doesn&#x2019;t re-render the view</li> <li>The client-side view controller gets invoked</li> </ol> <p>That&#x2019;s as far as first-time execution goes. Let&#x2019;s move on.</p> <ol> <li>You click on &#x201C;About this blog&#x201D;, which is a link to <code class="md-code md-code-inline">/about</code></li> <li>Taunus captures that click and issues an XHR request for <code class="md-code md-code-inline">/about</code>, asking for JSON data</li> <li>Incoming request <code class="md-code md-code-inline">/about</code></li> <li>Router matches <code class="md-code md-code-inline">/about</code>, and invokes the controller for that action</li> <li>The <code class="md-code md-code-inline">home/about</code> action controller fetches a model from the database</li> <li>In the controller action, we assign a model to <code class="md-code md-code-inline">res.viewModel</code>, and call <code class="md-code md-code-inline">next()</code></li> <li>Taunus responds with the JSON model as-is</li> <li>The client-side takes over, this time it renders the view, using the model from the AJAX call</li> <li>The client-side view controller gets invoked</li> </ol> <p>Note how steps 3 through 6 are exactly the same in both cases. Note how the last step is the same, too. Also note that the steps that are different are dealt with by Taunus, so you don&#x2019;t have to worry about them.</p> <p>The cool part about Taunus is that it doesn&#x2019;t rely on Backbone, or jQuery, or any client-side libraries. That&#x2019;s up to you. Taunus only handles view routing and the purely MVC aspect of you application. Since it&#x2019;s Common.JS you get dependency injection for free, and the conventional approach means that you won&#x2019;t have to worry about routing in more than one place. You can use the browser&#x2019;s native APIs for pretty much everything you want, so <strong>Taunus doesn&#x2019;t want you to marry it</strong>. That&#x2019;s a pretty good thing, because it&#x2019;s <a href="http://en.wikipedia.org/wiki/Ford_Taunus" target="_blank" rel="noopener noreferrer" aria-label="Ford Taunus on Wikipedia">a car model line</a>, and that&#x2019;d be awkward.</p> <p>It doesn&#x2019;t really break apart from what you&#x2019;re used to do in Express. You just do your thing, set a view model on the response, and call <code class="md-code md-code-inline">next()</code>. Let&#x2019;s see how Taunus is actually used.</p> <h2 id="taunus-on-the-server">Taunus On The Server</h2> <p>Taunus provides three different components that operate together, offering a sane development model that doesn&#x2019;t get in your way. Let&#x2019;s start with the routes. In a typical Express application, you&#x2019;d register routes by hand, like below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">app.get(<span class="md-code-string">&apos;/pony/foo&apos;</span>, pony.foo);
app.get(<span class="md-code-string">&apos;/pony/bar&apos;</span>, pony.bar);
app.get(<span class="md-code-string">&apos;/author/moo&apos;</span>, author.authenticated, author.moo);
</code></pre> <p>With Taunus, you&#x2019;re expected to define your view routes in a JSON format instead. It&#x2019;s recommended you put these into an individual module, like below. Note that, under the default module path resolver, controllers are expected to be defined on a per-action basis, and the same goes for views. In fact, the <code class="md-code md-code-inline">action</code> property in the route is used to infer which view should get rendered by Taunus.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> authorAuthenticated = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;./author/authenticated&apos;</span>);

<span class="md-code-built_in">module</span>.exports = [
  { route: <span class="md-code-string">&apos;/pony/foo&apos;</span>, action: <span class="md-code-string">&apos;pony/foo&apos;</span> },
  { route: <span class="md-code-string">&apos;/pony/bar&apos;</span>, action: <span class="md-code-string">&apos;pony/bar&apos;</span> },
  { route: <span class="md-code-string">&apos;/author/moo&apos;</span>, action: <span class="md-code-string">&apos;author/moo&apos;</span>, middleware: authorAuthenticated }
]
</code></pre> <p>Once you&#x2019;ve created the routes module, you can boot up <code class="md-code md-code-inline">taunus</code>. Here&#x2019;s a module which takes an Express instance and creates routes in it. Note how I&#x2019;m perfectly able to mix my Taunus view routes with any other routes I have, such as API routes or error handling middleware.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> taunus = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;taunus&apos;</span>);
<span class="md-code-keyword">var</span> routes = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;./routes&apos;</span>);
<span class="md-code-keyword">var</span> articleList = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;./article/list&apos;</span>);
<span class="md-code-keyword">var</span> errors = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;../lib/errors&apos;</span>);

<span class="md-code-built_in">module</span>.exports = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(app)</span> </span>{
  app.get(<span class="md-code-string">&apos;/api/articles&apos;</span>, articleList);
  taunus.mount(app, routes);
  app.use(errors.handler);
};
</code></pre> <p>A controller action might look like the snippet below. The <code class="md-code md-code-inline">model</code> property on the view model is what gets passed to partial view template functions. The layout will get the full <code class="md-code md-code-inline">viewModel</code>, instead.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">module</span>.exports = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(req, res, next)</span> </span>{

  <span class="md-code-comment">// fetch data from somewhere</span>
  <span class="md-code-comment">// var user = ...</span>

  <span class="md-code-comment">// assign it to the view model</span>
  res.viewModel: {
    model: {
      title: <span class="md-code-string">&apos;User Profile&apos;</span>,
      user: user
    }
  };

  <span class="md-code-comment">// we&apos;re done, yield control over to the renderer</span>
  next();
}
</code></pre> <h4 id="sharing-routes-and-view-templates">Sharing Routes and View Templates</h4> <p>The client-side portion of your application is where things get a bit more interesting. Like I explained back in the architecture section, the client-side will use the same routes and view templates that the server-side uses. Here&#x2019;s where we run into trouble. Browserify is awesome. Seriously, ragingly awesome. It does come with certain limitations, such as the inability to parse dynamically composed <code class="md-code md-code-inline">require(expr)</code> expressions at compile time. Browserify is only smart enough to figure out how to unwrap <code class="md-code md-code-inline">require(&apos;expr&apos;)</code> calls. The issue is that you want to initialize Taunus on the client-side as well, and for that you&#x2019;ll need a <code class="md-code md-code-inline">routes</code> object which looks somewhat like the snippet of code below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">module</span>.exports = [{
  route: <span class="md-code-string">&apos;/&apos;</span>,
  template: <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;../views/home/index&apos;</span>),
  controller: <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;../../client/js/controllers/home/index&apos;</span>)
}, {
  route: <span class="md-code-string">&apos;/author/compose&apos;</span>,
  template: <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;../views/author/compose&apos;</span>),
  controller: <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;../../client/js/controllers/author/compose&apos;</span>)
}];
</code></pre> <p>The above might look fine for two routes, but imagine maintaining that by hand? It&#x2019;s pointless! You already have a routes module, the one you used on the server. Surely you can build a small script that turns your server-side routes into these client-side routes in a heartbeat! That&#x2019;s what I did!</p> <h2 id="taunus-on-the-command-line">Taunus On The Command-Line</h2> <p>Taunus comes with a small CLI interface that can compile your routes. Without any options, the program will print a client-side routing module to standard out.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">taunus
</code></pre> <p>The CLI comes with a few options. Currently, these options are available, among others that aren&#x2019;t worth mentioning in this article.</p> <table> <thead> <tr> <th>Option</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="md-code md-code-inline">-o</code></td> <td>Instead of <code class="md-code md-code-inline">stdout</code>, the output is dumped to the <code class="md-code md-code-inline">client_routes</code> file, as defined in <code class="md-code md-code-inline">.taunusrc</code></td> </tr> <tr> <td><code class="md-code md-code-inline">-w</code></td> <td>Watch for changes to the server-side routes and recalculate the output. Works well with <code class="md-code md-code-inline">-o</code></td> </tr> <tr> <td><code class="md-code md-code-inline">--standalone path/to/file</code></td> <td>Export <code class="md-code md-code-inline">taunus</code> as a global, and your routes, using a single stand-alone bundle file</td> </tr> </tbody> </table> <p><strong>Taunus wants you to use Browserify really bad</strong>, although you have the option of not using Common.JS in your own code, and that&#x2019;s okay.</p> <blockquote> <p>Can I avoid using Browserify?</p> <p>&#x2013; <strong>Yes!</strong> However, you&#x2019;d still have to compile Taunus using Browserify, like below. This command won&#x2019;t just Browserify Taunus, but it&#x2019;ll also compile your route definitions into client-side routes, and place them in <code class="md-code md-code-inline">taunus.routes</code>! The <code class="md-code md-code-inline">-w</code> flag still works just fine. <code class="md-code md-code-inline">-o</code> is implied.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">taunus --standalone client/js/vendor/taunus.js -w
</code></pre> </blockquote> <p>Once you&#x2019;ve compiled your routes and browserified your bundle, you can set up Taunus on the client-side.</p> <h2 id="taunus-on-the-browser">Taunus on the Browser</h2> <p>If you went for Browserify, the code will be nicely modular. <em><a href="https://ponyfoo.com/2014/05/16/modularizing-your-front-end" aria-label="Modularizing Your Front-End">Precious, <em>precious modularity</em></a></em>. Pat yourself on the back. <a href="https://github.com/bevacqua/ponyfoo/blob/158a1a130d35f77b2d6f0c22f8651a6f21334083/build/debug" target="_blank" rel="noopener noreferrer" aria-label="`npm start`!">Click here for an example build file</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> taunus = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;taunus&apos;</span>);
<span class="md-code-keyword">var</span> routes = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;path/to/client-side/routes&apos;</span>);
<span class="md-code-keyword">var</span> elem = <span class="md-code-built_in">document</span>.querySelector(<span class="md-code-string">&apos;main&apos;</span>);
taunus.mount(elem, routes);
</code></pre> <p>If you&#x2019;ve decided to ditch Browserify, then it&#x2019;ll be even easier to set up!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> elem = <span class="md-code-built_in">document</span>.querySelector(<span class="md-code-string">&apos;main&apos;</span>);
taunus.mount(elem, taunus.routes);
</code></pre> <p>Once that&#x2019;s set up, all you&#x2019;ll need to do is create your routes, view templates, server-side and client-side controllers! Taunus will be mostly be out of your way. You can, however, get in the way of Taunus, by listening to the <a href="https://github.com/bevacqua/taunus#events" target="_blank" rel="noopener noreferrer" aria-label="Taunus Events on GitHub">events it emits</a> and reacting to them.</p> <p>There&#x2019;s still a long way to go, but I&#x2019;m sure it&#x2019;ll drastically improve as I toy with it and learn about its weaknesses!</p> <blockquote> <p>What do you think about Taunus?</p> </blockquote></div>
