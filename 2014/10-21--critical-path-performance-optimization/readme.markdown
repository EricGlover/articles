<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/critical-path-performance-optimization">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/critical-path-performance-optimization"><div><img src="https://i.imgur.com/1XZDJai.jpg" alt="Critical Path Performance Optimization at Pony Foo"></div></a>

<h1>Critical Path Performance Optimization at Pony Foo</h1>

<p><kbd>ponyfoo</kbd> <kbd>critical-path</kbd> <kbd>performance</kbd> <kbd>nginx</kbd> <kbd>pagespeed</kbd></p>

<blockquote><p>This article aims to cover the performance gains I&#x2019;ve attained in the redesign of Pony Foo, <em>deployed last week</em> to production. I&#x2019;ll be covering a few &#x2026;</p></blockquote>

<div><p>This article aims to cover the performance gains I&#x2019;ve attained in the redesign of Pony Foo, <em>deployed last week</em> to production. I&#x2019;ll be covering a few different topics throughout the article. <strong>I&#x2019;ll explain what each optimization entails, the reasoning behind these choices, how to implement the solution, and the observed improvements</strong>. We&#x2019;ll cover the approaches listed below. Note that these are sorted in terms of <em>potential gains</em>.</p></div>

<blockquote></blockquote>

<div><ul> <li>Moving away from client-side rendering</li> <li>Backing your application front-end servers with <a href="http://nginx.org/en/docs/" target="_blank" rel="noopener noreferrer">nginx</a></li> <li>Optimizing images</li> <li>Deferring non-critical asset loading</li> <li>Inlining critical assets</li> <li>Ditching large libraries and frameworks</li> </ul> <figure class="figure-has-loaded"><img src="https://i.imgur.com/GeyKmn9.jpg" alt="lightning-bolt.jpg" title="Overly dramatic imagery depicting outstanding performance"></figure> <p>If this article feels too <em>&#x201C;out of the blue&#x201D;</em> to you, maybe you&#x2019;d like to read the <a href="https://gist.github.com/bevacqua/18768dcc95d5c40434d8" target="_blank" rel="noopener noreferrer">introductory email</a> that was sent out to subscribers a few days ago.</p> <p>Are <strong>blazing fast web applications</strong> of interest to you? Read on!</p></div>

<div><h1 id="where-we-left-off">Where we left off&#x2026;</h1> <p>Before getting into the redesign, I want to talk about what I used to have. I wrote my <a href="https://ponyfoo.com/articles/pony-foo-begins" aria-label="Pony Foo begins">first article for this blog</a> during Christmas, in 2012. Eventually, I finished writing the engine and deployed it to production around mid-January in 2013.</p> <p>It was my first time writing code under Node.js, it was exhilarating! I learned a lot while putting together the blog, and it encouraged me to keep on teaching myself <a href="http://nodeschool.io/" target="_blank" rel="noopener noreferrer" aria-label="Did you know nodeschool.io teaches beginners how to Node?">&#x201C;how to Node&#x201D;</a>. I also got greedy and ended up <strong>rolling out my own framework</strong> for dealing with view rendering and routing in the client-side, like the god-lords commanded of me.</p> <p>Naturally, rolling out my own client-side MVC framework taught me a lot about them. It taught me about <em>the internals of how these frameworks work</em> in the client-side. But most importantly, I&#x2019;ve learned that <strong>you probably shouldn&#x2019;t write one yourself!</strong></p> <blockquote> <p>As it turns out, <strong>these things are pretty hard to develop!</strong> Particularly if you have no experience whatsoever with client-side MVC, nor Node.</p> <p>You&#x2019;d probably end up with something like what I had, a system that&#x2019;s only capable of doing client-side rendering, with a poor back-end architecture to boot!</p> </blockquote> <p>To be fair, developing that <em>&#x201C;framework&#x201D;</em> is also what got me interested in learning more about <a href="https://angularjs.org/" target="_blank" rel="noopener noreferrer" aria-label="AngularJS.org">Angular</a>, <a href="http://backbonejs.org/" target="_blank" rel="noopener noreferrer" aria-label="Backbone.js">Backbone</a>, <a href="http://facebook.github.io/react/" target="_blank" rel="noopener noreferrer" aria-label="React: A JavaScript Library for building User Interfaces">React</a>, and all those cools things. To learn how other people did these things, and go over their code, taking everything in.</p> <h2 id="the-honeymoon-phase">The Honeymoon Phase</h2> <p>Back then though, <strong>everything was part of the learning process</strong>. I was learning more and more about Node, Express, client-side MVC, Jade, Stylus, and Grunt. <em>Sweet, sweet Grunt.</em> Meanwhile I was actively writing articles and slowly adding improvements to the engine.</p> <p>An RSS feed was pretty much a must, I despise blogs I can&#x2019;t track over RSS. You&#x2019;ve got to have RSS. I had to have <a href="http://schema.org/docs/gs.html" target="_blank" rel="noopener noreferrer" aria-label="Getting started with schema.org">microdata</a>, of course. Otherwise why go through the trouble of even supporting search engines? A sitemap, yes, yes! Search engines love these. I think? Nobody really knows, but <strong>I <em>had</em> to have one</strong>. Ooh, <code class="md-code md-code-inline">robots.txt</code>! Obviously that <strong>wasn&#x2019;t enough procrastinating</strong>, so I just had to throw in <a href="https://ponyfoo.com/articles/implementing-opensearch" aria-label="Implementing OpenSearch">OpenSearch</a> and <a href="https://ponyfoo.com/humans.txt" aria-label="humans.txt on Pony Foo">humans.txt</a>, for good measure.</p> <p>Did I mention I spent an inordinate amount of time developing a tool for asset management? It was called <a href="https://github.com/assetify/assetify" target="_blank" rel="noopener noreferrer" aria-label="assetify/assetify on GitHub"><code class="md-code md-code-inline">assetify</code></a>, and you could use it to map static assets, bundle them, minify them, run pre-processors like <a href="http://lesscss.org/" target="_blank" rel="noopener noreferrer" aria-label="LESSCSS.org">LESS</a>. Sounds familiar? It was like Grunt&#x2019;s awkward brother nobody wanted to talk to.</p> <p>Meanwhile an overly complicated commenting system was born. People were allowed to log into the blog, because <strong>who doesn&#x2019;t</strong> want yet another little piece of Internet real-estate! I also implemented a <em>pretty neat emailing functionality</em> that would notify people about comments, new articles, and let them subscribe and unsubscribe painlessly from the mailing list. That was probably the first thing I did well, and it was also the first one I took out of the main codebase <a href="https://github.com/bevacqua/campaign" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/campaign on GitHub">and into its own</a>.</p> <p>All that meaningless feature-writing intoxicated me, and it was <strong>only downhill from there</strong>.</p> <h2 id="downhill-from-here">Downhill From Here</h2> <p>Things got worse when I figured the platform should allow anyone to create a blog, something that never happened. Still, I adjusted the codebase so that it would support multiple blogs running on the same single front-end node, for no apparent reason.</p> <p>By that point, Heroku was complaining pretty much daily that the server box was running out of memory, but I never bothered to fix those issues. I had much more important things to do! Like add support for <a href="http://en.wikipedia.org/wiki/Pingback" target="_blank" rel="noopener noreferrer" aria-label="Pingback defined on Wikipedia">pingbacks</a> and <a href="http://en.wikipedia.org/wiki/Trackback" target="_blank" rel="noopener noreferrer" aria-label="Trackback on Wikipedia">trackbacks</a>!</p> <p>Not long thereafter <strong>I completely stopped development</strong> of Pony Foo. I even had introduced a bug at some point that broke the obscure code which served web crawlers, and I just rolled back to an older version that didn&#x2019;t sport the bug.</p> <h2 id="hatred">Hatred!</h2> <p>Eventually, and for obvious reasons, I <em>started to hate the engine</em>. I hated the fact that I had to <a href="https://ponyfoo.com/articles/introduction-to-seo-and-content-indexing" aria-label="Introduction to SEO and Content Indexing">jump through all those hoops</a> just to get search engines to understand what was going on, and <em>they seemed oh-so-clever when I first put them together</em>!</p> <blockquote> <p>I was more than aware of how obnoxious it was that some clippy-style <em>&#x201C;hey, over here!&#x201D;</em> reading estimates would scroll right beside articles, keeping you up to date on how long you should&#x2019;ve been taking to finish the article. I can figure that out on my own, thanks. <strong>What was I thinking!?</strong></p> </blockquote> <p>Oh, then there were the hiragana bullet list items. Some thought those were interesting, but most people felt those were super confusing and unwarranted. Fonts were also an issue, even though nobody commented on that. They even rendered differently on Windows vs Mac because I didn&#x2019;t bother relying on <a href="http://cssfontstack.com/" target="_blank" rel="noopener noreferrer" aria-label="Complete collection of web safe CSS font stacks">web safe fonts</a>, or a font service like <a href="https://www.google.com/fonts" target="_blank" rel="noopener noreferrer" aria-label="Google Fonts">Google Web Fonts</a>.</p> <p><strong>I definitely needed to change things up.</strong></p> <p>I must note that these changes weren&#x2019;t applied overnight. The codebase was in such poor shape, <em>considering it was my landing strip into the Node.js continent</em>, that I decided a full rewrite would&#x2019;ve been more beneficial than attempting to fix what I had. The only code that lived through the rewrite was <a href="https://github.com/bevacqua/campaign" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/campaign on GitHub">campaign</a>, because it was extracted into its very own email-sending module, and <a href="https://github.com/bevacqua/ultramarked" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/ultramarked on GitHub">ultramarked</a>, although it was adjusted to be leaner on the client-side.</p> <h1 id="client-side-rendering">Client-Side Rendering?</h1> <p>The loading indicator seemed to take forever, and in <strong>the last year it pretty much did</strong>. Sometimes I would think it was stuck there forever, only to get a response a few seconds later. If I couldn&#x2019;t bear to open my own site, how do you think others must&#x2019;ve felt about it? It was beyond unacceptable.</p> <figure><img alt="page-load-nightmare-old.png" title="The good old times!" class="" src="https://i.imgur.com/1VaFf31.png"></figure> <p><sub><em>Ah, the good old times! Do you miss the loading indicator? How about the &#x201C;remaining reading time&#x201D; indicator?</em></sub></p> <p>The largest contributor to the painful Pony Foo experience was rendering views exclusively on the client-side. That was a terrible mistake, and one that troubled me for a long time, until I got around to fixing it. This is <em>not an easy issue to resolve</em>, and I think we&#x2019;re really missing the target here. <strong>We, as web workers, should be doing better.</strong> We&#x2019;ve been relying on client-side rendering for far too long, and fancy frameworks shouldn&#x2019;t be a valid excuse.</p> <p>I love <a href="https://angularjs.org/" target="_blank" rel="noopener noreferrer" aria-label="AngularJS.org">Angular</a>, I really do, but in my opinion it&#x2019;s nearly useless in any use case where performance is critical. As we all know, performance is critical in pretty much any application that has a practical goal <em>(like, you know, making you money)</em>. The same holds true for any client-side MVC framework that&#x2019;s <strong>incapable of rendering views on the server-side</strong> without resorting to complex gimmicks such as using <a href="http://phantomjs.org/" target="_blank" rel="noopener noreferrer" aria-label="Full Stack Headless Browser">PhantomJS</a> against your own site in production.</p> <p>This realization left me to choose between <a href="http://backbonejs.org/" target="_blank" rel="noopener noreferrer" aria-label="Backbone.js">Backbone</a> (using <a href="https://github.com/rendrjs/rendr" target="_blank" rel="noopener noreferrer" aria-label="Rendr">Rendr</a>), <a href="http://facebook.github.io/react/" target="_blank" rel="noopener noreferrer" aria-label="React: A JavaScript Library for building User Interfaces">React</a>, or <em>&#x201C;doing nothing&#x201D;</em>. React felt like overkill, I really disliked the JSX syntax. The DOM tree diffing algorithm is brilliant, but that alone didn&#x2019;t tip me over. I invested a couple of days toying with <a href="https://github.com/rendrjs/rendr" target="_blank" rel="noopener noreferrer" aria-label="Rendr">Rendr</a>, but it was <a href="https://ponyfoo.com/articles/shared-rendering-with-rendr" aria-label="Shared Rendering with Rendr">far too constrained</a> for my taste. I ended up going for a custom solution yet again.</p> <p>This time however I had decided to learn from the many mistakes I made in the past, and I implemented a shared-rendering library that would work with any Node.js server, view templating engine, and client-side libraries that I needed. That&#x2019;s when I built <a href="https://ponyfoo.com/articles/taunus-micro-isomorphic-mvc-framework" aria-label="Taunus: Micro Isomorphic MVC Framework">Taunus</a>.</p> <h1 id="shared-rendering">Shared-Rendering!</h1> <p>Rendering views on the server-side means that you&#x2019;re able to get the content that matters to the <strong>human first</strong>. What would you rather do?</p> <ul> <li>Have them <strong>download a blank page</strong>, wait for CSS and JavaScript to load, before even being able to render content that&#x2019;s <em>meaningful</em> to them</li> <li>Render the <strong>full view on the server-side</strong> and serve a completely usable page, and then sprinkle some JavaScript sugar on top of your creamy content?</li> </ul> <p>I&#x2019;m quite perplexed that we as a community have been consistently choosing the former. Why is it so enticing to push all of our magical unicorns down our humans&#x2019; throats <em>before they get an even usable experience</em>? I&#x2019;m pretty sure humans don&#x2019;t care for <code class="md-code md-code-inline">{{item.name}}</code> placeholders everywhere!</p> <p>The fact that people don&#x2019;t consider this to be <strong>a big deal</strong> baffles me even more. As an example, here&#x2019;s an extract of <a href="https://medium.com/este-js-framework/whats-wrong-with-angular-js-97b0a787f903" target="_blank" rel="noopener noreferrer" aria-label="What&#x2019;s wrong with Angular.js">&#x201C;What&#x2019;s wrong with Angular.js?&#x201D;</a>: to date, this paragraph hasn&#x2019;t received a single comment, while every other point was bashed to death by angry <code class="md-code md-code-inline">ng-adept</code>s.</p> <blockquote> <p>6. No server side rendering without obscure hacks. Never. You can&#x2019;t fix broken design. Bye bye <a href="http://nerds.airbnb.com/isomorphic-javascript-future-web-apps/" target="_blank" rel="noopener noreferrer" aria-label="Isomorphic JavaScript: The Future of Web Apps">isomorphic web apps</a>.</p> </blockquote> <p>This has nothing to do with me being a <em>&#x201C;purist&#x201D;</em> of any sort, and everything to do with page speed and performance. We&#x2019;ve been telling ourselves that we should push <code class="md-code md-code-inline">&lt;script&gt;</code> tags to the bottom of our pages, defer loading using <code class="md-code md-code-inline">async</code> and <code class="md-code md-code-inline">onload</code> event listeners, and yet a lot of <strong>modern applications simply won&#x2019;t work until JavaScript is downloaded, parsed, and interpreted</strong>.</p> <p><strong>Strive for getting meaningful content to your humans as quickly as possible.</strong> Then, once they have something they can read or interact with, add more content on top. Throw in the rest of the styles, fetch the JavaScript needed to obtain a fancier experience, but always provide them with <em>something to do other than stare at a loading indicator!</em></p> <p>It doesn&#x2019;t matter whether you actually use <a href="https://ponyfoo.com/articles/taunus-micro-isomorphic-mvc-framework" aria-label="Taunus: Micro Isomorphic MVC Framework">Taunus</a> itself or not. It just enables shared rendering and better code reuse, then gets out of the way. The concept underlying Taunus is really simple. These are the steps you should be aiming for, in order to get content to your humans as quickly as possible, <a href="https://ponyfoo.com/articles/taunus-micro-isomorphic-mvc-framework" aria-label="Taunus: Micro Isomorphic MVC Framework">Taunus</a> or not.</p> <ul> <li>Define <code class="md-code md-code-inline">function(model)</code>s for your views</li> <li>Put these views in both the server and the client</li> <li>Define routes for your application</li> <li>Put those routes in both the server and the client</li> <li>Ensure route matches work the same way on both ends</li> <li>Create server-side controllers that yield the model for your views</li> <li>Create client-side controllers if you need to add client-side functionality to a particular view</li> <li>For the first request, always render views on the server-side</li> <li>When rendering a view on the server-side, include the full layout as well!</li> <li>Once the client-side code kicks in, <strong>hijack link clicks</strong> and make AJAX requests instead</li> <li>When you get the JSON model back, render views on the client-side</li> <li>If the <code class="md-code md-code-inline">history</code> API is unavailable, fall back to good old request-response. <strong>Don&#x2019;t confuse your humans with obscure hash routers!</strong></li> </ul> <p>Most view templating engines allow you to compile your views into plain JavaScript functions. In the case of Jade I wrote <a href="https://github.com/bevacqua/jadum" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/jadum on GitHub">Jadum</a>, which goes the extra mile of adding <code class="md-code md-code-inline">require</code> statements rather than inlining <code class="md-code md-code-inline">include</code>s, saving <em>quite a few extra bytes</em> when it comes to client-side views. As far as routing goes, that&#x2019;s up to you. In the case of Taunus I&#x2019;m currently using <a href="https://www.npmjs.org/package/routes" target="_blank" rel="noopener noreferrer" aria-label="routes on npm">routes</a> to fulfill its routing needs, since it&#x2019;s really close to what Express has, but that&#x2019;s just for convenience.</p> <p>If you&#x2019;re careful about following this outline, you might be well on your way to a progressively enhanced site.</p> <p>One that doesn&#x2019;t come down crumbling when humans disable JavaScript.</p> <p><strong>One that doesn&#x2019;t come down crumbling when JavaScript takes forever to download.</strong> Yes. You should care about that, because of mobile devices and poor connectivity under 2G and 3G connections.</p> <p>If you don&#x2019;t care about <a href="https://ponyfoo.com/articles/taunus-micro-isomorphic-mvc-framework" aria-label="Taunus: Micro Isomorphic MVC Framework">Taunus</a>, which is perfectly expected, you should still definitely give <a href="http://facebook.github.io/react/" target="_blank" rel="noopener noreferrer" aria-label="React: A JavaScript Library for building User Interfaces">React</a> or <a href="https://github.com/rendrjs/rendr" target="_blank" rel="noopener noreferrer" aria-label="Rendr">Rendr</a> a shot. Shared-rendering is crucial to fast web applications. In fact <em>you can quote me</em> on the following statement.</p> <blockquote> <p>If you&#x2019;re going to pick one, use server-side rendering. Using only client-side rendering is slow, inaccessible, and <strong>one of the worst aspects of modern web application development</strong>.</p> </blockquote> <h1 id="use-nginx">Use <code class="md-code md-code-inline">nginx</code></h1> <p>The second worst offender when it came to performance on Pony Foo was the fact that there was <strong>barely any caching</strong> going on, as evidenced by this <a href="http://www.webpagetest.org/" target="_blank" rel="noopener noreferrer" aria-label="WebPageTest.org Performance Testing and Measurement">WebPageTest.org speed test</a> report.</p> <figure><a href="http://www.webpagetest.org/" target="_blank" rel="noopener noreferrer" aria-label="WebPageTest.org Performance Testing and Measurement"><img alt="webpagetest.png" class="" src="https://i.imgur.com/Awzpnnd.png"></a></figure> <blockquote> <p>Keep in mind that, <em>while the benchmark might look not-that-terrible</em>, this was <strong>just getting humans to a loading indicator</strong>, and they had to wait around a while longer if they wanted to read any meaningful content!</p> <p>This gets me wondering how on earth people kept coming to my blog!</p> </blockquote> <p>Using <code class="md-code md-code-inline">nginx</code>, all of your static assets will be properly cached with far-future <code class="md-code md-code-inline">Expires</code> headers, Gzip compressed, and none of those requests will be hitting your application servers! Application servers are simply not very well suited to handle lots of requests for static assets. Do yourself a favor and put an <a href="http://nginx.org/en/docs/" target="_blank" rel="noopener noreferrer" aria-label="nginx documentation">nginx server</a> in front of them.</p> <p>The current iteration fares much better on <a href="http://www.webpagetest.org/" target="_blank" rel="noopener noreferrer" aria-label="WebPageTest.org Performance Testing and Measurement">WebPageTest</a>. Granted, I&#x2019;m still not using a CDN, but a simple blog doesn&#x2019;t really <em>need</em> to serve static assets near the edge of the network. Note how both compression and caching got a higher rating as a result of using <a href="http://nginx.org/en/docs/" target="_blank" rel="noopener noreferrer" aria-label="nginx documentation">nginx</a>.</p> <figure><a href="http://www.webpagetest.org/" target="_blank" rel="noopener noreferrer" aria-label="WebPageTest.org Performance Testing and Measurement"><img alt="webpagetest2.png" class="" src="https://i.imgur.com/f49lwPp.png"></a></figure> <p>When putting together <a href="http://bevacqua.io/" target="_blank" rel="noopener noreferrer" aria-label="bevacqua.io is my personal site">bevacqua.io</a> I came up with <a href="https://github.com/bevacqua/grunt-ec2" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/grunt-ec2 on GitHub">grunt-ec2</a> as a way to easily provision <a href="http://aws.amazon.com/ec2/" target="_blank" rel="noopener noreferrer" aria-label="Amazon Elastic Compute Cloud">AWS EC2</a> instances and have them setup an <a href="http://nginx.com/resources/admin-guide/reverse-proxy/" target="_blank" rel="noopener noreferrer" aria-label="nginx Reverse Proxy">nginx reverse proxy</a> in front of my Node application, which ran on a cluster for failover and hot code reloads.</p> <p>Keep in mind that heavy caching demands that you perform <em>asset hashing</em> on your static resources. For this purpose I&#x2019;ve developed <a href="https://github.com/bevacqua/reaver" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/reaver on GitHub">reaver</a>, which performs the actual asset hashing, turning files like <code class="md-code md-code-inline">all.js</code> into something like <code class="md-code md-code-inline">all.db340cff.js</code>. I&#x2019;ve also developed <a href="https://github.com/bevacqua/scourge" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/scourge on GitHub">scourge</a>, which helps you replace references like <code class="md-code md-code-inline">&lt;script src=&apos;/js/all.js&apos;&gt;&lt;/script&gt;</code> with their properly hashed counterparts.</p> <h2 id="a-faster-build-process">A faster build process</h2> <p>This time around, I&#x2019;ve implemented the same functionality using <a href="https://github.com/ponyfoo/ponyfoo/tree/master/build/ec2" target="_blank" rel="noopener noreferrer" aria-label="Bash scripts for AWS EC2 instance management">Bash scripts</a>, which is <em>significantly faster</em> and <strong>way less error-prone</strong>. In particular, deployments are way faster than they ever were under <code class="md-code md-code-inline">grunt-ec2</code>.</p> <p>With <code class="md-code md-code-inline">npm run</code> and Bash, I was able to use build tools directly, rather than indirectly via means of plugins on top of a task runner, like Grunt or Gulp propose. This reduced latency in the &#x201C;critical path&#x201D; of my builds quite dramatically, leading me to a very <a href="https://github.com/ponyfoo/ponyfoo/blob/master/build/debug" target="_blank" rel="noopener noreferrer" aria-label="npm start build script at ponyfoo/ponyfoo on GitHub">fast npm start experience</a> that enabled continuous development.</p> <p>The build process is a topic <em>for a different article</em>, though. You came here for the performance!</p> <h1 id="defer-non-critical-asset-loading">Defer non-critical asset loading</h1> <p>Before getting into the deferring aspect of this improvement, we must define a <em>&#x201C;critical asset&#x201D;</em>.</p> <blockquote> <p>Critical assets are everything that&#x2019;s absolutely required to present the user with a minimally usable web page. The HTML itself is a required asset because the page can&#x2019;t be rendered without it. Images can probably be deferred. So can JavaScript! Fonts? Those <strong>take too long</strong>, deferring is probably wiser. Styles? We&#x2019;ll get there soon enough.</p> <p>If you&#x2019;re doing client-side rendering alone, then you won&#x2019;t be able to defer anything, since pretty much everything becomes &#x201C;a critical asset&#x201D;.</p> </blockquote> <p>Many of these insights can be inferred from a tool such as <a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener noreferrer" aria-label="Google PageSpeed Insights">PageSpeed insights</a>. Here&#x2019;s how badly Pony Foo used to perform on PageSpeed.</p> <figure><a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener noreferrer" aria-label="Google PageSpeed Insights"><img alt="pagespeed.png" class="" src="https://i.imgur.com/raU3zgV.png"></a></figure> <p>As a complement, consider reading <a href="http://chimera.labs.oreilly.com/books/1230000000545" target="_blank" rel="noopener noreferrer" aria-label="High Performance Browser Networking">High Performance Browser Networking</a>, as it&#x2019;ll give you a great understanding of how browser networking behaves, and why. This will give you a good perspective on how your actions affect your humans, when it comes to performance and hurting their feelings.</p> <figure><a href="http://chimera.labs.oreilly.com/books/1230000000545" target="_blank" rel="noopener noreferrer" aria-label="High Performance Browser Networking"><img alt="hpbn.jpg" class="" src="https://i.imgur.com/W9nllKd.jpg"></a></figure> <p>Among other topics, the book will give you a thorough understanding of the protocols underlying the web: <strong>TCP, UDP, HTTP, TLS</strong>, and also gives you a deep analysis of the current state of mobile networks. You&#x2019;ll learn about <strong>networking opportunities in modern browsers</strong>, such as Server-Sent Events <em>(SSE)</em>, WebSockets, and WebRTC. Meanwhile, it&#x2019;ll teach you about how to <strong>optimize HTTP 1.x connections</strong>, as well as explain how <strong>SPDY</strong> <em>(and at some point, HTTP 2.0)</em> will fix most of the issues we currently observe in <strong>HTTP 1.x</strong>.</p> <h2 id="defer-most-image-loading">Defer <em>Most</em> Image Loading</h2> <p>This one is probably the easiest ways to ensure the relevant pieces of content get to your humans as quickly as possible. In the case of Pony Foo, I chose to defer image loading for <strong>every image except the first one</strong>: chances are, every image after that <strong>won&#x2019;t be in the human&#x2019;s viewport</strong> until after a while, giving us time to load them in the background.</p> <p>Implementing the image deferral involved a two step process. The idea is to alter image tags so that they won&#x2019;t immediately load the associated images. Then, once the <code class="md-code md-code-inline">onload</code> event fires, you assign the <code class="md-code md-code-inline">src</code> property back to what it was supposed to be!</p> <p>This can be done simply by using a different attribute, and then setting the <code class="md-code md-code-inline">src</code> after load. Of course, a <code class="md-code md-code-inline">&lt;noscript&gt;</code> fallback is necessary, we wouldn&#x2019;t want to leave our humans stranded!</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">img</span> <span class="md-code-attribute">data-src</span>=<span class="md-code-value">&apos;/foo.png&apos;</span> <span class="md-code-attribute">class</span>=<span class="md-code-value">&apos;js-only&apos;</span> /&gt;</span>
<span class="md-code-tag">&lt;<span class="md-code-title">noscript</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">img</span> <span class="md-code-attribute">src</span>=<span class="md-code-value">&apos;/foo.png&apos;</span> /&gt;</span>
<span class="md-code-tag">&lt;/<span class="md-code-title">noscript</span>&gt;</span>
</code></pre> <p>The <code class="md-code md-code-inline">js-only</code> class is meant to act as a reverse <code class="md-code md-code-inline">&lt;noscript&gt;</code> tag for HTML. It&#x2019;s very easy to set up.</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">noscript</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">style</span>&gt;</span><span>
    <span class="md-code-class">.js-only</span> <span class="md-code-rules">{ <span><span class="md-code-attribute">display</span>:<span class="md-code-value"> none <span class="md-code-important">!important</span></span></span>; <span>}</span></span>
  </span><span class="md-code-tag">&lt;/<span class="md-code-title">style</span>&gt;</span>
<span class="md-code-tag">&lt;/<span class="md-code-title">noscript</span>&gt;</span>
</code></pre> <p>Unwrapping images should happen after load, and it&#x2019;s super easy to set up. Note that in the example below, <code class="md-code md-code-inline">$</code> is a reference to <a href="https://github.com/bevacqua/dominus" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/dominus on GitHub">Dominus</a>, and not <a href="https://github.com/jquery/jquery" target="_blank" rel="noopener noreferrer" aria-label="jquery/jquery on GitHub">jQuery</a>. More on that later!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">unwrapImages</span> <span class="md-code-params">(container)</span> </span>{
  $(container).find(<span class="md-code-string">&apos;img[data-src]&apos;</span>).forEach(unwrap);
}

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">unwrap</span> <span class="md-code-params">(img)</span> </span>{
  img.src = img.getAttribute(<span class="md-code-string">&apos;data-src&apos;</span>);
  img.removeAttribute(<span class="md-code-string">&apos;data-src&apos;</span>);
}
</code></pre> <p>Deferring all images such as gravatars and many others that won&#x2019;t be visible until the human scrolls further down enables us to prioritize the content that matters, enabling me to <strong>deliver a reasonable human experience more quickly</strong>.</p> <p>Obviously you&#x2019;ll have to take this little hack into account when putting together an email <em>(or RSS feed entry, etc.)</em> that uses the same piece of HTML! The effects on social media crawlers are mitigated by the use of metadata <em>(e.g: open graph, microdata)</em> containing links to the images.</p> <h2 id="use-image-sprites">Use Image Sprites</h2> <p>Spritesheets are a widely known and easy-to-implement technique that <a href="https://ponyfoo.com/articles/spritesheets-grunt-and-you" aria-label="Spritesheets, Grunt,  and you">help you concatenate images in one bundle</a>. Those icons can then be individually added to your pages by using CSS class names to single them out.</p> <p>While the human-facing side of Pony Foo doesn&#x2019;t have a lot of icons, the technique still deserved a mention in this article!</p> <h2 id="optimize-images">Optimize Images!</h2> <p>Image optimization is often <em>overlooked or underestimated</em>, but <strong>critical in enabling fast-loading sites</strong>. In the case of Pony Foo most imagery comes from uploads made to <a href="http://imgur.com/" target="_blank" rel="noopener noreferrer" aria-label="imgur is the simple image sharer">imgur</a> over the Markdown editor. Unfortunately, imgur doesn&#x2019;t optimize images, other than acting as a CDN.</p> <p>For that reason, I&#x2019;ve had to take image optimization upon myself, using <a href="https://github.com/imagemin/imagemin" target="_blank" rel="noopener noreferrer" aria-label="imagemin/imagemin on GitHub">imagemin</a> to optimize image uploads on the fly before handing them over to imgur. Using imagemin I managed to get <strong>savings of around 50-80%</strong> for most images I&#x2019;ve uploaded, easily resulting in some of the largest byte-size savings attained while boosting the overall performance of the site.</p> <figure><img alt="imagemin.png" title="imagemin your images for much gain" class="" src="https://i.imgur.com/6bRHTi0.png"></figure> <p>Of course, this is only meaningful if you&#x2019;re actually planning on serving images. As Ilya observes time and again in <a href="http://chimera.labs.oreilly.com/books/1230000000545" target="_blank" rel="noopener noreferrer" aria-label="High Performance Browser Networking">High Performance Browser Networking</a>:</p> <blockquote> <p><strong>The fastest byte is a byte not sent.</strong></p> </blockquote> <h2 id="defer-expensive-font-loading">Defer Expensive Font Loading</h2> <p>If you&#x2019;ve read <a href="https://ponyfoo.com/smashingmagazine.com/2014/09/08/improving-smashing-magazine-performance-case-study/" aria-label="Improving Smashing Magazine&#x2019;s Performance: A Case Study">Vitaly Friedman&#x2019;s article on performance optimization</a> published last month, you probably know of the techniques they&#x2019;ve used to defer font loading. I&#x2019;ve also tried quite a few different alternatives, and eventually settled for a simpler approach to theirs. I&#x2019;m not sure why they felt the need to use <code class="md-code md-code-inline">localStorage</code>, so I just deferred the creation of a <code class="md-code md-code-inline">&lt;link&gt;</code> tag pointing to the fonts served by Google servers.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">~<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(document)</span> </span>{
  <span class="md-code-keyword">var</span> elem = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">&apos;link&apos;</span>);
  <span class="md-code-keyword">var</span> head = <span class="md-code-built_in">document</span>.getElementsByTagName(<span class="md-code-string">&apos;head&apos;</span>)[<span class="md-code-number">0</span>];
  elem.rel = <span class="md-code-string">&apos;stylesheet&apos;</span>;
  elem.href = <span class="md-code-string">&apos;http://fonts.googleapis.com/css?family=Cardo:700|Merriweather:400italic,400,700&apos;</span>;
  elem.media = <span class="md-code-string">&apos;only x&apos;</span>;
  head.appendChild(elem);
  setTimeout(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
    elem.media = <span class="md-code-string">&apos;all&apos;</span>;
  });
}(<span class="md-code-built_in">document</span>);
</code></pre> <p>Note how I explicitly hand-pick the fonts and styles that I need, so that humans won&#x2019;t download font faces they won&#x2019;t be using. Letting Google do their thing works best for me in this case, rather than inlining the font face statements. Google does their own optimizations on their end, including figuring out <code class="md-code md-code-inline">font-face</code> statements to serve, according to the <code class="md-code md-code-inline">user-agent</code> in the HTTP request.</p> <p>The script shown above is minified and inlined in the layout, preventing an unnecessary extra HTTP request. Of course, never forget the <code class="md-code md-code-inline">&lt;noscript&gt;</code> fallback!</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">noscript</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">link</span> <span class="md-code-attribute">rel</span>=<span class="md-code-value">&apos;stylesheet&apos;</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&apos;text/css&apos;</span> <span class="md-code-attribute">href</span>=<span class="md-code-value">&apos;http://fonts.googleapis.com/css?family=Cardo:700|Merriweather:400italic,400,700&apos;</span>&gt;</span>
<span class="md-code-tag">&lt;/<span class="md-code-title">noscript</span>&gt;</span>
</code></pre> <h2 id="fetch-javascript-onload">Fetch JavaScript <code class="md-code md-code-inline">onload</code></h2> <p>Deferring JavaScript loading can help push the experience over the edge, as it should be already usable before JavaScript kicks in. That&#x2019;s the crucial aspect of all of this, right? <strong>JavaScript should be complementary, not mandatory!</strong></p> <p>Here&#x2019;s the snippet I used in Pony Foo to load all the JavaScript code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">~<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(window, document)</span> </span>{
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">inject</span> <span class="md-code-params">()</span> </span>{
    <span class="md-code-keyword">var</span> elem = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">&apos;script&apos;</span>);
    elem.src = <span class="md-code-string">&apos;/js/all.js&apos;</span>;
    <span class="md-code-built_in">document</span>.body.appendChild(elem);
  }

  <span class="md-code-keyword">if</span> (<span class="md-code-built_in">window</span>.addEventListener) {
    <span class="md-code-built_in">window</span>.addEventListener(<span class="md-code-string">&apos;load&apos;</span>, inject, <span class="md-code-literal">false</span>);
  } <span class="md-code-keyword">else</span> <span class="md-code-keyword">if</span> (<span class="md-code-built_in">window</span>.attachEvent) {
    <span class="md-code-built_in">window</span>.attachEvent(<span class="md-code-string">&apos;onload&apos;</span>, inject);
  } <span class="md-code-keyword">else</span> {
    <span class="md-code-built_in">window</span>.onload = inject;
  }
}(<span class="md-code-built_in">window</span>, <span class="md-code-built_in">document</span>);
</code></pre> <p>Deferring it to until after <code class="md-code md-code-inline">onload</code> fires helps drive down the cost of requesting a large piece of JavaScript even further.</p> <p>This has all been great to the performance of the site, but another technique that also must be looked into is <strong>inlining critical assets</strong>, besides deferring non-critical ones!</p> <h1 id="inline-critical-assets">Inline Critical Assets</h1> <p>Namely, I&#x2019;m talking about above-the-fold CSS. By now it&#x2019;s becoming increasingly well known that Google is pushing for <a href="http://css-tricks.com/authoring-critical-fold-css/" target="_blank" rel="noopener noreferrer" aria-label="Authoring Critical Above the Fold CSS, on CSS-Tricks">inlining CSS in the critical path</a>.</p> <p>The basic idea is that you fire up PhantomJS with a large_-ish_ window size, find all the elements that are visible on the viewport, and collect the CSS class names they use. Then, you take those class names and your page&#x2019;s stylesheet to <strong>figure out all the styles that are needed immediately</strong>. Once you have those styles, you can inline them in a <code class="md-code md-code-inline">&lt;style&gt;</code> tag, and <strong>defer the rest</strong> until after <code class="md-code md-code-inline">onload</code>. This technique works <em>surprisingly well</em>. In fact, you probably didn&#x2019;t notice it, but it&#x2019;s used in this blog!</p> <p>Of course, manually doing all of what I mentioned in the last paragraph would be super painful, but you can automate it. In fact, someone else already did! There&#x2019;s <a href="https://github.com/pocketjoso/penthouse" target="_blank" rel="noopener noreferrer" aria-label="pocketjoso/penthouse on GitHub">penthouse</a>, which if you ask me, is not being used by enough sites.</p> <p>Penthouse will do most of the work detailed above, although it&#x2019;s up to you to inline those styles in your page. That&#x2019;s where <a href="https://github.com/addyosmani/critical" target="_blank" rel="noopener noreferrer" aria-label="addyosmani/critical on GitHub">Addy Osmani&#x2019;s critical</a> comes into play, doing the inlining for you.</p> <p>At this point I went into super-hardcore mode and ended up writing <a href="https://github.com/bevacqua/cave" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/cave on GitHub">cave</a>, a play on <em>&#x201C;penthouse&#x201D;</em> that takes the critical CSS and your original stylesheets, and gives you a new stylesheet that doesn&#x2019;t have the critical CSS in it, avoiding to serve those styles twice!</p> <p>As you can see in the snippet of Bash shown below, this part of the process can get quite unpleasant to look at, but it works and it&#x2019;s pleasant to humans, so that makes up for the code! Note that I&#x2019;m inlining the critical CSS in the layout, which is a Jade template that was previously compiled into a JavaScript function.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-comment"># critical css inlining. many slash, very escape.</span>
LOGGING_LEVEL=info PORT=<span class="md-code-variable">$PORT</span> APP_REBUILD=<span class="md-code-number">0</span> node app &amp;
APP_PID=$(procfinder --wait --port <span class="md-code-variable">$PORT</span>)
CRITICAL=<span class="md-code-string">&quot;<span class="md-code-variable">$(phantomjs node_modules/penthouse/penthouse.js http://localhost:$PORT $ALL_CSS)</span>&quot;</span>
CRITICAL_ESCAPED=$(<span class="md-code-built_in">echo</span> <span class="md-code-variable">$CRITICAL</span> | sed <span class="md-code-operator">-e</span> <span class="md-code-string">&apos;s/[\/#&amp;]/\\&amp;/g&apos;</span> <span class="md-code-operator">-e</span> <span class="md-code-string">&apos;s/&quot;/\\\\&quot;/g&apos;</span>)
LAYOUT=<span class="md-code-string">&quot;.bin/views/server/layout/layout.js&quot;</span>
<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;Gathered critical CSS, killing node app (<span class="md-code-variable">$APP_PID</span>)&quot;</span>
<span class="md-code-built_in">echo</span> <span class="md-code-variable">$CRITICAL</span> &gt; <span class="md-code-variable">$CRITICAL_CSS</span>
<span class="md-code-built_in">kill</span> <span class="md-code-variable">$APP_PID</span>
sed -i <span class="md-code-operator">-e</span> <span class="md-code-string">&quot;s#&lt;style&gt;&lt;/style&gt;#&lt;style&gt;<span class="md-code-variable">$CRITICAL_ESCAPED</span>&lt;/style&gt;#&quot;</span> <span class="md-code-variable">$LAYOUT</span>
CSS_DIFF=$(cave <span class="md-code-variable">$ALL_CSS</span> --css <span class="md-code-variable">$CRITICAL_CSS</span>)
<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;<span class="md-code-variable">$CSS_DIFF</span>&quot;</span> &gt; <span class="md-code-variable">$ALL_CSS</span>
cleancss <span class="md-code-variable">$ALL_CSS</span> -o <span class="md-code-variable">$ALL_CSS</span> -<span class="md-code-operator">-s</span>0
rm <span class="md-code-variable">$CRITICAL_CSS</span>
</code></pre> <p>Once the critical CSS has been extracted, removed, and inlined in your pages, you can safely defer CSS loading! This yields improvements on the critical path as <strong>CSS blocks rendering</strong>.</p> <p>Deferring style loading is <em>basically the same</em> as what we had done with fonts, a dozen of paragraphs ago.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">~<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(document)</span> </span>{
  <span class="md-code-keyword">var</span> elem = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">&apos;link&apos;</span>);
  <span class="md-code-keyword">var</span> head = <span class="md-code-built_in">document</span>.getElementsByTagName(<span class="md-code-string">&apos;head&apos;</span>)[<span class="md-code-number">0</span>];
  elem.rel = <span class="md-code-string">&apos;stylesheet&apos;</span>;
  elem.href = <span class="md-code-string">&apos;/css/all.css&apos;</span>;
  elem.media = <span class="md-code-string">&apos;only x&apos;</span>;
  head.appendChild(elem);
  setTimeout(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
    elem.media = <span class="md-code-string">&apos;all&apos;</span>;
  });
}(<span class="md-code-built_in">document</span>);
</code></pre> <p>Naturally, you must remember to add the fallback <code class="md-code md-code-inline">&lt;link&gt;</code> tag!</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">noscript</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">link</span> <span class="md-code-attribute">rel</span>=<span class="md-code-value">&apos;stylesheet&apos;</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&apos;text/css&apos;</span> <span class="md-code-attribute">href</span>=<span class="md-code-value">&apos;/css/all.css&apos;</span>&gt;</span>
<span class="md-code-tag">&lt;/<span class="md-code-title">noscript</span>&gt;</span>
</code></pre> <h1 id="ditch-large-libraries">Ditch Large Libraries</h1> <p>As a last resort, getting rid of the fat provided by large libraries will help you make your sites leaner. The JavaScript used in Pony Foo <strong>fits in less than 60K minified and gzipped</strong>. That&#x2019;s even smaller than some <em>&#x201C;lean and fast&#x201D;</em> frameworks!</p> <figure><img alt="resources.png" class="" src="https://i.imgur.com/hkeYKdJ.png"></figure> <p>Some examples of cruft-cutting that allowed me to fit the entire client-side JavaScript in less than 60K are detailed below.</p> <ul> <li>No <a href="https://github.com/jquery/jquery" target="_blank" rel="noopener noreferrer" aria-label="jquery/jquery on GitHub">jQuery</a>, which is 33K on its own. <a href="https://github.com/bevacqua/dominus" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/dominus on GitHub">Dominus</a> fits in 3.6K and has a nicer API dedicated to DOM querying and manipulation</li> <li><a href="https://ponyfoo.com/articles/taunus-micro-isomorphic-mvc-framework" aria-label="Taunus: Micro Isomorphic MVC Framework">Taunus</a> is very small, even when you add client-side view templates! This is possible thanks to <a href="https://github.com/bevacqua/jadum" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/jadum on GitHub">Jadum</a>, which optimizes <code class="md-code md-code-inline">include</code>s to use <code class="md-code md-code-inline">require</code> statements instead of inlining the included template</li> <li>When in doubt, measure!</li> </ul> <p>In the case of Pony Foo, I <a href="https://github.com/ponyfoo/ponyfoo/blob/master/build/diagnose" target="_blank" rel="noopener noreferrer" aria-label="`npm run diagnose` for ponyfoo on GitHub">created a script</a> that lets me quickly visually identify which client-side components are growing out of proportions, by using the <a href="https://github.com/hughsk/disc" target="_blank" rel="noopener noreferrer" aria-label="hughsk/disc on GitHub">disc</a> package.</p> <figure><img alt="disc.png" title="Measuring performance is just as important as trying to improve it directly!" class="" src="https://i.imgur.com/2FFGh5t.png"></figure> <p><sub>The <strong>super long dependency tree</strong> to the right was a <a href="https://www.npmjs.org/package/lodash.find" target="_blank" rel="noopener noreferrer" aria-label="lodash.find on npmjs.org">lodash.find</a> dependency in <a href="https://github.com/bevacqua/dominus" target="_blank" rel="noopener noreferrer" aria-label="bevacqua/dominus on GitHub">Dominus</a>, and it was <a href="https://github.com/bevacqua/dominus/commit/1d0e97f9143e3050d84decfd1d32bc7332b133d5" target="_blank" rel="noopener noreferrer" aria-label="Getting rid of lodash.find">erased</a> while writing this article!</sub></p> <p>Almost unsurprisingly, Pony Foo now fares <em>much better</em> on <a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener noreferrer" aria-label="Google PageSpeed Insights">PageSpeed Insights</a> as a result. The issues noted in the mobile version are because cache headers used by external origins, such as <code class="md-code md-code-inline">imgur.com</code> or <code class="md-code md-code-inline">gravatar.com</code>, don&#x2019;t set far-future <code class="md-code md-code-inline">Expires</code> headers and instead set them to short spans of time like 5 minutes.</p> <figure><a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener noreferrer" aria-label="Google PageSpeed Insights"><img alt="pagespeed-now.png" class="" src="https://i.imgur.com/whHDV9Z.png"></a></figure> <p>Of course, that rating is a <em>&#x201C;best-case scenario&#x201D;</em>, because images are not optimized as aggressively as they could be, and long comment threads also damage performance, but we can all agree that Pony Foo is much more pleasant to read today than it was a year ago.</p> <blockquote> <p>Yes, the site looks <strong>a bit better overall</strong>, as I&#x2019;ve worked a bit on the <em>design and UX</em> aspects as well; and I plan on writing an article about those topics as well!</p> </blockquote> <p>What kinds of performance optimizations have worked best for you and your sites?</p></div>
