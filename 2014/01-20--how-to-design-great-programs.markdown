<h1>How to Design Great Programs</h1>

<blockquote><p>This article is a recollection of common-sense application design practices I usually follow when building things. I felt like grouping them together in a blog post, for &#x2026;</p></blockquote>

<div><kbd>best-practices</kbd> <kbd>api</kbd> <kbd>open-source</kbd> <kbd>program-design</kbd></div>

<div><p>This article is a recollection of common-sense application design practices I usually follow when building things. I felt like grouping them together in a blog post, for future reference. I&#x2019;ll talk not so much about implementation, but more about <strong>program design theory</strong>.</p></div>

<div></div>

<div><p>Below are the central arguments I&#x2019;ll touch on in the article.</p> <ol> <li><strong>Do one thing</strong>, and <em>do it well</em></li> <li>Provide excellent API interfaces</li> <li><code class="md-code md-code-inline">README</code> Driven Development</li> <li>Open-Source</li> <li>Write Tests</li> </ol> <p>Let&#x2019;s go over each of these in turn.</p> <p><img src="https://i.imgur.com/LuHFbbN.jpg" alt="freebeer.jpg" title="No, seriously. There&apos;s no beer. Go away."></p></div>

<div><h1 id="1-one-goal">1. One Goal</h1> <p>Great programs are designed with <strong>a single goal</strong>. Whether we&#x2019;re talking about a CLI, desktop, mobile, web application, or even an API, doesn&#x2019;t matter. The principle remains the same: one goal. A program that&#x2019;s focused on doing a single thing has far better chances of doing it well, being reusable, and being better at it. There are quite a few good examples, such as <a href="https://github.com/dominictarr/through" target="_blank" aria-label="dominictarr/through on GitHub">through</a>, or <a href="https://github.com/sindresorhus/ansi-styles" target="_blank" aria-label="sindresorhus/ansi-styles on GitHub">ansi-styles</a> in the Node community of packages which do exactly one thing well.</p> <p>Programs don&#x2019;t have to be a just a few lines long in order to comply. Both <a href="https://github.com/npm/npm" target="_blank" aria-label="npm/npm on GitHub">npm</a> and <a href="https://github.com/senchalabs/connect" target="_blank" aria-label="senchalabs/connect on GitHub">connect</a> are great examples of programs which do just one thing well. The goal for <code class="md-code md-code-inline">npm</code> is to provide a package manager which just works. It does double as a development productivity tool, but that&#x2019;s just a side-effect of being a well rounded package manager. On the other hand, <code class="md-code md-code-inline">connect</code>provides a middleware layer for Node&#x2019;s native <a href="http://nodejs.org/api/http.html" target="_blank" aria-label="HTTP module documentation for Node"><code class="md-code md-code-inline">http</code></a>. It enables middleware and provides a few basic ones.</p> <p><img alt="bullseye.jpg" title="Have a single, specific purpose" class="" src="https://i.imgur.com/m4IXGsC.jpg"></p> <p>I built <a href="https://github.com/bevacqua/campaign" target="_blank" aria-label="bevacqua/campaign on GitHub">campaign</a>, which provides a pluggable email sending layer with a <a href="http://en.wikipedia.org/wiki/Convention_over_configuration" target="_blank" aria-label="Convention over Configuration on Wikipedia">convention over configuration</a> approach, reducing configuration bloat for a basic email sending service. It doesn&#x2019;t even do any email sending, other modules can already do that, and so <a href="https://github.com/bevacqua/campaign" target="_blank" aria-label="bevacqua/campaign on GitHub">campaign</a> uses those for that purpose. Recently, I started putting together <a href="https://github.com/bevacqua/contra" target="_blank" aria-label="bevacqua/contra on GitHub"><code class="md-code md-code-inline">&#x3BB;</code></a>, a tiny asynchronous flow control meant for the browser, which I&#x2019;m really proud of. It currently sits at below <code class="md-code md-code-inline">3kb</code> when minified, and it&#x2019;s capable of most of what I find useful in <a href="https://github.com/caolan/async" target="_blank" aria-label="caolan/async on GitHub"><code class="md-code md-code-inline">async</code></a>, while staying <em>10 times smaller</em>.</p> <p>If your design has a single goal, then it will be that much easier to make it into a reusable component which you can utilize across projects, and maybe even open-source if you feel so inclined. One of the features of developing open-source software is that you force your programs into <strong>focused things</strong>. You or others can benefit from that reusability in other projects. Developing open-source projects also forces you to <strong>document the API</strong>, helping you think about the purpose of each API member.</p> <blockquote> <p>At any scale, do <em>one thing</em> and do it well.</p> </blockquote> <h1 id="2-excellent-api">2. Excellent API</h1> <p>Let us define API interfaces as a <strong>consumer-facing interface for a component</strong>, regardless of <em>transport</em>. An API might be any of:</p> <ul> <li>The methods exported by a JavaScript package</li> <li>Those exposed by a module in that package</li> <li>The CLI interface to a command-line program</li> <li>REST API endpoints provided by a web application</li> </ul> <p>I find that these translate quite nicely to human interaction design as well, and I find that I treat both with the same kind of respect more and more, even if I strive to meet different goals in each case. Design the interface as if consumers didn&#x2019;t have a clue about your code. <strong>They really don&#x2019;t.</strong> Most people won&#x2019;t even look at the code you write, and thus the interface should be intuitive and easy to use. Similarly, it should be documented well enough that people don&#x2019;t have a reason to look at your code. I&#x2019;ll add more thoughts on documentation in the next section.</p> <h5 id="not-so-hot">Not So Hot</h5> <p>Consider, as an example, <a href="https://ponyfoo.com/2014/01/09/gulp-grunt-whatever" aria-label="Gulp, Grunt, Whatever">Gulp, Grunt, Whatever</a>, from last week, where we analyzed the trade-offs between the simplicity in Gulp, compared with the <em>overload-pandemonium</em> in Grunt. While Grunt provides lots of functionality, it also provides many different ways to accomplish the same goal. This is not necessarily a good thing. Due to Grunt&#x2019;s <strong>configuration juggernaut model</strong>, consumers aren&#x2019;t able to properly separate task targets, even if they belong to entirely different workflows. Grunt is pretty well documented, but their API could use some love, and that has proved to be very damaging, as witnessed on Stack Overflow where people repeatedly ask basic questions such as how globbing works. Why <code class="md-code md-code-inline">files</code> should be this, or that, etc.</p> <p>Twitter&#x2019;s REST API is a remarkable example of <strong>an API I vigorously despised</strong> when I had to work with it a couple of years ago. I&#x2019;m not familiar with recent developments, but back then you had the streaming API, the search API, and some other API, and they where abundantly inconsistent. API to API, and sometimes method to method, the response types and request parameter names didn&#x2019;t match. Even the status codes were inconsistent, sometimes returning <code class="md-code md-code-inline">200 OK</code> for errors, sometimes a detailed JSON with the error, and some other times, plain text responses when an error occurred. No one C# library consistently &#x201C;just worked&#x201D; seamlessly with these API, and they seemed to be <a href="http://stackoverflow.com/questions/6587176/tweetsharp-where-did-fluenttwitter-go" target="_blank" aria-label="Where did FluentTwitter go?">at least as poorly documented</a> as the Twitter API themselves. Generally a pain to deal with.</p> <p>These days, <a href="http://docs.seleniumhq.org/projects/webdriver/" target="_blank" aria-label="Selenium WebDriver Browser Automation">Selenium WebDriver</a> has become my go-to <a href="http://blog.ponyfoo.com/2013/12/20/is-webdriver-as-good-as-it-gets" target="_blank" aria-label="Is WebDriver as Good as it Gets?">hated API of choice</a>. Also really confusing, with methods inconsistently named, and implementations which let you write tests using <a href="https://github.com/admc/wd" target="_blank" aria-label="admc/wd on GitHub"><code class="md-code md-code-inline">wd</code></a> suck, and are <em>marginally documented</em>, regardless of what language they&#x2019;re written in.</p> <p>Middle-tier implementations such as Twitter API clients and Selenium drivers aren&#x2019;t to blame for their poor design or even documentation. Implementation suffers if the API is bad. They suffer just as much if the API is decent but the documentation is lacking or non-existent.</p> <h5 id="consistency-consistency-consistency">Consistency, consistency, consistency</h5> <p>There&#x2019;s lots of things you can do to provide a better API than most. Above all, I think the most important factor is naming. The way you name your public API members says a lot about the kind of experience your package is set to deliver. Is it <code class="md-code md-code-inline">UserService.getUser</code>, <code class="md-code md-code-inline">Users.get</code>, <code class="md-code md-code-inline">User.find</code>? Whatever your choice, be consistent about it. API member naming consistency is <em>crucial</em>. Think about PHP, how much of it&#x2019;s perceived suck comes from inconsistent API naming and argument overloading?</p> <p>Only provide <strong>methods which add value.</strong> If you don&#x2019;t have a good reason to provide an API method, then <em>don&#x2019;t</em>. It&#x2019;s always easier to add later on, than it is to deprecate, and then remove. On a similar note, you should try to be consistent in the way in which you take parameters. Always take them in the same order, and if you feel like you might add parameters in the future, consider a configuration object. That way, you won&#x2019;t break the API each time you add a new parameter, and all of them become optional!</p> <p>Whenever you&#x2019;re adding a member to your public interface, think. <em>Ask yourself these questions.</em></p> <ul> <li>Does this member advance the purpose of my API?</li> <li>How does it add value?</li> <li>Does it fight for value with another member?</li> <li>Is it named consistently with the rest of the API?</li> <li>Are the arguments arranged in a consistent manner?</li> <li>Are the arguments future-proof?</li> </ul> <blockquote> <p><strong>The interface makes or breaks the user experience</strong>, and this holds true when talking about a GUI, a CLI, or any other API.</p> </blockquote> <h1 id="3-readme-driven-development-17">3. <a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html" target="_blank" aria-label="Readme Driven Development"><code class="md-code md-code-inline">README</code> Driven Development</a></h1> <p>Over time, I&#x2019;ve developed a habit for writing API documentation which is both extensive and useful, and I&#x2019;ve found that my code gets better because of it. Here are some of the most recent packages I&#x2019;ve distributed and extensively documented.</p> <ul> <li><a href="https://github.com/bevacqua/grunt-ec2" target="_blank" aria-label="Create, deploy to, and shutdown Amazon EC2 instances">grunt-ec2</a></li> <li><a href="https://github.com/bevacqua/buildfirst" target="_blank" aria-label="JavaScript Application Design Code Samples">buildfirst</a></li> <li><a href="https://github.com/bevacqua/campaign" target="_blank" aria-label="Compose responsive email templates easily, fill them with models, and send them out">campaign</a></li> <li><a href="https://github.com/bevacqua/suchjs" target="_blank" aria-label="Provides essential jQuery-like methods for your evergreen browser, in under 200 lines of code">suchjs</a></li> <li><a href="https://github.com/bevacqua/contra" target="_blank" aria-label="Asynchronous flow control for the browser">contra</a></li> </ul> <p>In all of these cases, typing away at the documentation was a great way to think about the API design and how it could be improved. Or in the case of <a href="https://github.com/bevacqua/buildfirst" target="_blank" aria-label="JavaScript Application Design Code Samples">buildfirst</a>, how the sample code could&#x2019;ve made better. Pointing people to your unit tests as a learning resource on how to use your library is <em>a sign of early onset dementia</em>. What works for me is briefly describing the goals of a library, and provide a complete list of API methods, arguments they take, and results they produce. Often, it&#x2019;s best to pair API method documentation with usage examples, to make it clear exactly what a method can be used for, and how <em>you</em>, the package author, think it should be used. That helps people use the library, and it helps you shape it.</p> <p>If you think documentation is obsolete as soon as you push, <strong>you&#x2019;re doing it wrong</strong>. That may be true for print documentation, manuals, and such. This day and age, libraries are distributed under source-control, and most of us use <a href="http://semver.org/" target="_blank" aria-label="Semantic Versioning, or semver">semantic versioning</a> for their libraries. Providing documentation alongside the code is required, but it isn&#x2019;t enough. <strong>You need to actively update that documentation, at least every time you publish a new release</strong>, to reflect the latest API changes in your package. Likewise, providing a <a href="https://github.com/bevacqua/grunt-ec2/blob/master/CHANGELOG.markdown" target="_blank" aria-label="Sample CHANGELOG, as seen in grunt-ec2">CHANGELOG</a> is awesome at letting people know what&#x2019;s going on in terms of active development around your package.</p> <blockquote> <p>Allowing documentation to become stale is, in effect, even worse than not providing any documentation at all. <strong>Misleading documentation is worse than no documentation.</strong></p> </blockquote> <p>There are a couple of things to keep in mind when writing great README documentation. You need to have a plan. Start with an outline, what questions does your README intend to answer? Is there going to be any documentation besides the README? <em>Tests don&#x2019;t count.</em> Who are you writing the documentation for? Is it clients? Fellow developers? The open-source community? What do they need to know? I like creating documents that start with the name or logo of my package. Then I&#x2019;ll provide a quote with a sentence or two which briefly state the goal or purpose, and afterwards I may provide a paragraph describing the module in a little more detail. Once that&#x2019;s out of the way I get to installation, where I describe how the module can be installed from each source that&#x2019;s available to consumers, package managers, straight from GitHub, and whatnot.</p> <p>Lastly, I like going through each API member and documenting their name and method signature, describing the method as well as each argument it takes, and the result it produces. In all cases I love providing self-contained usage examples for each method. I try not to mix examples with multiple parts of an API too much, since people don&#x2019;t necessarily read the whole thing at once, they might just navigate to specific bits and pieces at a time. For those people, going through a piece of code that uses 3+ API methods starts getting hard to understand. You want usage examples to be as simple as possible. They describe how your API is used, and if they look complicated, it probably means your API is complicated, or that your documentation is poor. Your API shouldn&#x2019;t be complicated. <strong>A complicated API is a bad API.</strong> Your documentation should be elegant, poor documentation isn&#x2019;t pretty to look at. That gets people upset. It&#x2019;s also a waste of time to type out poor documentation. <em>Write good API usage examples!</em></p> <h5 id="you-might-want-to-consider-answering-these-questions">You might want to consider answering these questions</h5> <ul> <li>What is this program?</li> <li>How do I get it?</li> <li>How do I use it?</li> <li>What are the methods I can use?</li> <li>Can you provide me with any usage examples?</li> <li>What license type do you use?</li> <li>How can I contribute?</li> </ul> <h1 id="4-open-source-it">4. Open Source It</h1> <p>Some of the best software I&#x2019;ve written is open-source. That&#x2019;s not bragging, it&#x2019;s just that you have to be more careful about it. I already stated that open-source forces you to write documentation, which in turn helps you write better interfaces. But open-source doesn&#x2019;t stop at that. Counter-intuitively, <strong>open-source makes your code more secure</strong>. You can&#x2019;t merely distribute API secrets with an OSS piece of code, you might need to <a href="https://github.com/bevacqua/buildfirst/tree/master/ch03/02_rsa-config-encryption" target="_blank" aria-label="RSA Configuration Encryption">encrypt it</a>, or exclude it from your codebase altogether.</p> <p><img alt="oss.jpg" title="Open-Source Software" class="" src="https://i.imgur.com/PhNCOO1.jpg"></p> <p>Open makes you want to write <a href="https://github.com/bevacqua/campaign" target="_blank" aria-label="bevacqua/campaign on GitHub">decoupled code</a>, so that other people can consume it. That also means you&#x2019;ll be able to use it in other projects down the road, which should be incentive enough on its own to warrant thinking open-source. That&#x2019;s a key concept. <strong>&#x201C;Think open-source&#x201D;.</strong> Even if you don&#x2019;t actually open-source the thing, writing something <em>as-if</em> you were going to open-source it at some point, will help you with all of the above. You&#x2019;ll write code that&#x2019;s safer, better documented, and more focused.</p> <p><strong>Decouple hacks.</strong> If you&#x2019;re writing code for the browser, don&#x2019;t bake hacks that make your code work in <strong>IE &lt; 10</strong> into your package. Rather, build them <a href="https://github.com/bevacqua/contra/blob/master/src/contra.shim.js" target="_blank" aria-label="contra.shim.js in bevacqua/contra on GitHub">into a companion file</a> you can add if necessary. This decoupling will do a couple <em>(touch&#xE9;)</em> things for you. It&#x2019;ll help you keep the code cleaner, as you won&#x2019;t have ugly pieces of code lying around which don&#x2019;t have so much to do with the purpose of your package, but more to do with the limitations of the platform you&#x2019;re going to run the package on. It will keep the code smaller in those cases where you don&#x2019;t need to support legacy platforms. If your hacks are independent enough, you might even be able to reuse them in other projects! <em>Yayyy, reusable hacks.</em> <code class="md-code md-code-inline">:rolleyes:</code></p> <blockquote> <p>Deal in focused components. <strong>Think open-source.</strong></p> </blockquote> <h1 id="5-write-tests">5. Write Tests</h1> <p>Write a single test. Then another. Then progressively write enough so that you <a href="https://github.com/bevacqua/contra/blob/master/test/unit.js" target="_blank" aria-label="Unit tests in Contra.js">cover all of your API</a>. Then, <a href="https://github.com/bevacqua/contra/commits/master/test/unit.js" target="_blank" aria-label="Commit History for unit tests in Contra.js">keep your tests up to date</a>. Update the suite as you add new API members, or when modifying existing ones. Then update the documentation. Only when the tests pass and the documentation is updated should you allow yourself to commit again.</p> <p><a href="https://browserling.com/" target="_blank" aria-label="Visit the browserling"><img alt="browserling.png" class="" src="https://i.imgur.com/J4WIv2x.png"></a></p> <p>Set up automated testing. This is becoming increasingly painless. Testing modules on <a href="https://travis-ci.org/" target="_blank" aria-label="Travis-CI: Continuous Integration Platform">Travis-CI</a> is a joke, it couldn&#x2019;t be any easier to set up. In a few minutes you can have your repository running tests on every push. If you&#x2019;re into running things on browsers, then <a href="http://ci.testling.com/" target="_blank" aria-label="Testling: Run your browser tests on every push">Testling</a> and <a href="https://saucelabs.com/" target="_blank" aria-label="Sauce Labs: Hassle-free Testing">Sauce Labs</a> are eager to befriend you. I&#x2019;ve been using both while working on <a href="https://github.com/bevacqua/contra" target="_blank" aria-label="bevacqua/contra on GitHub">contra</a>, and they&#x2019;re both awesome. Testling has been particularly useful, although it took me a while to figure out that tests on <strong>IE &lt; 10</strong> were blowing up solely because I was using <code class="md-code md-code-inline">should</code>, which defines a bunch of getters. After switching to <code class="md-code md-code-inline">assert</code>, though, I didn&#x2019;t have any more problems.</p> <blockquote> <p>Whenever you add or change a method, update your test suite. Update your documentation to match.</p> </blockquote> <p>That&#x2019;s all the advice I have for today!</p></div>
