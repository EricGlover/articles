<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/master/contributing.markdown"><code>contributing.markdown</code></a> for details.</sub>

<a href="https://ponyfoo.com/articles/a-browsersync-primer"><div></div></a>

<h1>A BrowserSync Primer</h1>

<p><kbd>build</kbd> <kbd>browsersync</kbd> <kbd>grunt</kbd> <kbd>gulp</kbd> <kbd>npm</kbd> <kbd>nodemon</kbd></p>

<blockquote><p><a href="http://www.browsersync.io/" target="_blank">BrowserSync</a> is a browser testing tool, similar to <a href="http://livereload.com/" target="_blank">LiveReload</a>. It also synchronizes across browsers and is going to provide <a href="https://twitter.com/BrowserSync/status/498161493418840064" target="_blank">HTML injection</a> in the very near future, &#x2026;</p></blockquote>

<div><p><a href="http://www.browsersync.io/" target="_blank">BrowserSync</a> is a browser testing tool, similar to <a href="http://livereload.com/" target="_blank">LiveReload</a>. It also synchronizes across browsers and is going to provide <a href="https://twitter.com/BrowserSync/status/498161493418840064" target="_blank">HTML injection</a> in the very near future, alongside with the CSS and JavaScript injection it already features.</p></div>

<div></div>

<div><p><a href="http://www.browsersync.io/" target="_blank"><img src="https://cloud.githubusercontent.com/assets/934293/3879487/18b2f866-2179-11e4-8098-3467f24e5061.png" alt="browsersync.png"></a></p> <p>This tool enables rapid continuous development by saving you the trouble of refreshing the view you are debugging whenever you make changes to the JavaScript or CSS code.</p> <p>You won&#x2019;t really be able to grasp how valuable this is until you give it a try for yourself. This primer aims to encourage you to do just that!</p> <p>In this article I&#x2019;ll show you how to use it with your favorite tools. Grunt, Gulp, <code class="md-code md-code-inline">npm run</code> and <code class="md-code md-code-inline">nodemon</code>.</p></div>

<div><p>Modern web development is burdened with quite a few pauses, such as saving files, running build tasks, refreshing the browser, besides the usual <strong>thinking and refactoring</strong> that you were used to. <a href="https://ponyfoo.com/2013/09/26/continuous-development-in-nodejs" aria-label="Continuous Development in Node.js">Continuous development helps you</a> bridge the gap by shortening those pauses, or at least automating them in such a way that you don&#x2019;t have to <strong>manually take action</strong> in between those pauses.</p> <p>It doesn&#x2019;t matter what tools you use, as long as those tools get you one step closer to true continuous development, eliminating the friction in between your changes and the result displayed on the browser.</p> <ul> <li>Using a reasonable text editor <em>(<a href="http://www.sublimetext.com/" target="_blank" aria-label="The text editor you&apos;ll fall in love with">Sublime</a>, <a href="https://atom.io/" target="_blank" aria-label="A hackable text editor for the 21st Century">Atom</a>, <a href="http://www.vim.org/" target="_blank" aria-label="Highly configurable text editor">vim</a>, etc)</em> you can <strong>auto-save</strong> when your tabs lose focus</li> <li>Using <a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank" aria-label="grunt-contrib-watch on GitHub">watch tasks</a> you can avoid restarting your build flow whenever <strong>source code changes</strong></li> <li>Using <a href="https://github.com/remy/nodemon" target="_blank" aria-label="Monitor for any changes in your application and automatically restart the server">Nodemon</a> you can avoid running <code class="md-code md-code-inline">node app</code> whenever <strong>server-side code changes</strong></li> <li>Using <a href="http://www.browsersync.io/" target="_blank" aria-label="Time-saving synchronised browser testing.">BrowserSync</a> you can avoid hitting <kbd>F5</kbd> on the browser whenever <strong>client-side code changes</strong></li> </ul> <p>The one <em>unfortunate drawback</em> to <a href="http://www.browsersync.io/" target="_blank" aria-label="Time-saving synchronised browser testing.">BrowserSync</a> is that currently its documentation is quite lacking. Rather than explain and document what the API does and what properties, options and methods there are, you just get <a href="http://www.browsersync.io/docs/grunt/" target="_blank" aria-label="BrowserSync + Grunt.js">a few use cases</a> and the example code that goes with them.</p> <p>Hopefully, their documentation will improve in the future. For now, you can rely on the guides in this article.</p> <h2 id="using-grunt">Using Grunt</h2> <p>If you&#x2019;re using Grunt in your builds, you can use the <a href="https://github.com/shakyshane/grunt-browser-sync" target="_blank" aria-label="shakyshane/grunt-browser-sync on GitHub"><code class="md-code md-code-inline">grunt-browser-sync</code></a> package. I&#x2019;ll go ahead and assume you&#x2019;re <a href="https://ponyfoo.com/2013/11/13/grunt-tips-and-tricks" aria-label="Grunt Tips and Tricks">using <code class="md-code md-code-inline">load-grunt-tasks</code></a> to load your tasks automatically.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">npm install grunt-browser-sync --save-dev
</code></pre> <p>Typically you&#x2019;ll want the proxy behavior. In this case you can mount BrowserSync to listen on a port, but proxying an existing app. This will use your own server to respond to requests, but it&#x2019;ll patch it with the appropriate script injection code, which is used on the client-side to reload CSS and JS through BrowserSync.</p> <p>Besides configuring the server, BrowserSync needs to understand what files changes are going to trigger updates, and you can use a globbing pattern for that. Refer to the code snippet below for an example on how to configure <code class="md-code md-code-inline">grunt-browser-sync</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">browserSync: {
  dev: {
    bsFiles: {
      src: <span class="md-code-string">&apos;public/**/*.{js,css}&apos;</span>
    },
    options: {
      proxy: <span class="md-code-string">&apos;localhost:3000&apos;</span>
    }
  }
}
</code></pre> <p>When you are <a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank" aria-label="grunt-contrib-watch on GitHub">using watch tasks</a>, you are expected to set the <code class="md-code md-code-inline">watchTask</code> option to <code class="md-code md-code-inline">true</code>.</p> <h2 id="using-gulp">Using Gulp</h2> <p>When using Gulp, the folks at BrowserSync recommend <a href="http://www.browsersync.io/docs/gulp/" target="_blank" aria-label="BrowserSync + Gulp.js">using the <code class="md-code md-code-inline">browser-sync</code> API directly</a>, rather than a plugin, and for good reason. The code is pretty self-explanatory, simplicity beats over-engineering.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> gulp = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;gulp&apos;</span>);
<span class="md-code-keyword">var</span> browserSync = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;browser-sync&apos;</span>);

gulp.task(<span class="md-code-string">&apos;browser-sync&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  browserSync({
    proxy: <span class="md-code-string">&apos;localhost:3000&apos;</span>,
    files: [<span class="md-code-string">&apos;public/**/*.{js,css}&apos;</span>]
  });
});
</code></pre> <p>Doing the same with <code class="md-code md-code-inline">npm run</code> is even easier.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">browser-sync start --proxy localhost:<span class="md-code-number">3000</span> --files <span class="md-code-string">&quot;public/*&quot;</span>
</code></pre> <p>In my experience, though, at this point you are better off using the API within your Node application.</p> <h2 id="inside-a-node-application">Inside a Node application</h2> <p>The upside in running <a href="http://www.browsersync.io/" target="_blank" aria-label="Time-saving synchronised browser testing.">BrowserSync</a> directly in your app is that you won&#x2019;t bash your head against the wall when attempting to make it play nicely with tools such as <a href="https://github.com/remy/nodemon" target="_blank" aria-label="Monitor for any changes in your application and automatically restart the server"><code class="md-code md-code-inline">nodemon</code></a>, which constantly restart the server that BrowserSync is proxying.</p> <p>To ensure that the server is always up when BrowserSync attempts to uplink, I find that the best approach is to configure it as follows.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> express = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;express&apos;</span>);
<span class="md-code-keyword">var</span> browserSync = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;browser-sync&apos;</span>);
<span class="md-code-keyword">var</span> app = express();
<span class="md-code-keyword">var</span> port = process.env.PORT || <span class="md-code-number">3000</span>;

app.listen(port, listening);

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">listening</span> <span class="md-code-params">()</span> </span>{
  browserSync({
    proxy: <span class="md-code-string">&apos;localhost:&apos;</span> + port,
    files: [<span class="md-code-string">&apos;public/**/*.{js,css}&apos;</span>]
  });
}
</code></pre> <p>Now you can run <code class="md-code md-code-inline">nodemon</code> and BrowserSync will work even <em>across restarts</em>. Yay!</p> <pre class="md-code-block"><code class="md-code md-lang-bash">nodemon app.js
</code></pre> <p><em>It&#x2019;s time to focus on what really matters.</em></p></div>
