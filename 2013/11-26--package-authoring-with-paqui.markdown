<h1>Package Authoring with Paqui</h1>

<blockquote><p>Creating client-side JavaScript packages is increasingly becoming a painful endeavor. We need to publish our package to different repositories such as <a href="http://bower.io/" target="_blank">bower</a>, <a href="http://component.io/" target="_blank">component</a>, &#x2026;</p></blockquote>

<div><kbd>paqui</kbd> <kbd>js</kbd> <kbd>front-end</kbd> <kbd>npm</kbd> <kbd>bower</kbd></div>

<div><p>Creating client-side JavaScript packages is increasingly becoming a painful endeavor. We need to publish our package to different repositories such as <a href="http://bower.io/" target="_blank">bower</a>, <a href="http://component.io/" target="_blank">component</a>, and <a href="https://npmjs.org/" target="_blank">npm</a>, and there are others! Crazy. People might be using <a href="http://volojs.org/" target="_blank">volo</a>, <a href="http://jamjs.org/" target="_blank">jam</a>, or <a href="http://ender.jit.su/" target="_blank">Ender</a>&#x2026; <em>Have I named enough yet?</em></p></div>

<div></div>

<div><p>Then there&#x2019;s building the package for human consumption. That&#x2019;s where things get really cute. You have <a href="http://wiki.commonjs.org/wiki/Modules" target="_blank">CommonJS modules</a> and <a href="http://browserify.org/" target="_blank">browserify</a>, AMD modules with <a href="http://requirejs.org/" target="_blank">Require.js</a>, plain-old raw JavaScript, and a bunch of other &#x201C;input&#x201D; formats. There is plenty that can be done in that field, and plenty is done indeed. The output isn&#x2019;t that complicated, but everyone expects you to provide at least the minified (and unminified) code for your module tighly packaged in a single <code class="md-code md-code-inline">.js</code> file.</p> <p>Solutions such as <a href="http://gruntjs.com/" target="_blank">Grunt</a> or <a href="http://yeoman.io/" target="_blank">yeoman</a> kind-of solve these problems, but leave you but a bunch of code that you might have no idea how it works.</p> <p><a href="https://github.com/bevacqua/paqui" target="_blank"><img src="https://i.imgur.com/AksDJZW.png" alt="paqui.png"></a></p> <p><a href="https://github.com/bevacqua/paqui" target="_blank">Paqui</a> solves these issues for us, without leaving undesired artifacts behind. That&#x2019;s the nice thing of being <strong>tailored for open-source front-end package development</strong>! In this article we&#x2019;ll examine how to make use of Paqui in our package development workflow, and learn how we can extend its behavior, <em>if we need to</em>.</p></div>

<div><p>In essence, Paqui takes care of three things:</p> <ul> <li>Scaffolding</li> <li>Building</li> <li>Distributing</li> </ul> <p>Let&#x2019;s go through them in turn.</p> <h1 id="paqui-flow">Paqui Flow</h1> <p>The first step is actually <a href="https://github.com/new" target="_blank" aria-label="Create a New Repository on GitHub">creating a repository</a> on GitHub. Paqui will take care of everything else, so you should leave <strong>Initialize</strong> <em>unchecked</em>.</p> <p><img alt="github.png" title="Creating the repository on GitHub" class="" src="https://i.imgur.com/XAlzQ8V.png"></p> <p>Paqui requires a one-time only installation step, let&#x2019;s go ahead and type that into our terminal now.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">npm install -g paqui
</code></pre> <p>Ready! Okay, let&#x2019;s see how this works. The first command we&#x2019;ll look at is <code class="md-code md-code-inline">paqui init</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">paqui init paqui-dummy --remote bevacqua/paqui-dummy
</code></pre> <p>I use the <code class="md-code md-code-inline">--remote</code> option to have Paqui <em>add the remote and push to it</em> for me, otherwise I&#x2019;d need to do that by hand. Note that you can use both the full url or the shorthand <code class="md-code md-code-inline">{user}/{repo}</code> syntax.</p> <p>This command will create a <code class="md-code md-code-inline">paqui-dummy</code> directory and set up our component there. If we create the directory ourselves, and <code class="md-code md-code-inline">cd</code> into it, we could just <code class="md-code md-code-inline">paqui init .</code>. Before doing anything, Paqui will ask us a few questions, but it&#x2019;ll provide default answers to the best of its knowledge.</p> <p><img alt="init.png" title="Initializing a component with Paqui" class="" src="https://i.imgur.com/i0grZjO.png"></p> <blockquote> <p><em>I used the <code class="md-code md-code-inline">--lean</code> option to avoid verbose <code class="md-code md-code-inline">git</code> command output</em></p> </blockquote> <p>The configuration provided to Paqui when we initialize our component can be modified at any time in <code class="md-code md-code-inline">.paquirc</code>, which is the only file Paqui will burden us with.</p> <p><img alt="rc.png" title="The .paquirc configuration file" class="" src="https://i.imgur.com/Tx6ehpE.png"></p> <p>At this point we can start hacking away at our package. If we didn&#x2019;t change any of the defaults, the entry point will be <code class="md-code md-code-inline">src/main.js</code>.</p> <h2 id="building">Building</h2> <p>By default, we are going to write our code under Common.JS (using <code class="md-code md-code-inline">module.exports</code> and <code class="md-code md-code-inline">require</code>). If you scroll up a bit you&#x2019;ll see one of the questions Paqui asked was <code class="md-code md-code-inline">transform</code>, where I answered with the default: <code class="md-code md-code-inline">universal,banner</code>. This is where the extensible nature of Paqui becomes apparent.</p> <blockquote> <p>The only thing that&#x2019;s governing the way we write our module is the <strong>transformation extensions we apply to our sources</strong> during our builds.</p> </blockquote> <p>As you can imagine, <code class="md-code md-code-inline">universal</code> means that we are able to write Common.JS modules in our source code, and the <code class="md-code md-code-inline">universal</code> transform will take that code, put it through <code class="md-code md-code-inline">browserify</code>, and turn it into a client-side package that supports <a href="https://github.com/umdjs/umd" target="_blank" aria-label="Universal Module Definition">the UMD definition</a>.</p> <p>Paqui is going to generate a couple of files during builds, in this case they&#x2019;ll be called <code class="md-code md-code-inline">paqui-dummy.js</code> and <code class="md-code md-code-inline">paqui-dummy.min.js</code>. These will be the files that package consumers will pay attention to.</p> <p><img alt="build.png" title="Building a component with Paqui" class="" src="https://i.imgur.com/4dx3YHd.png"></p> <h2 id="versioning">Versioning</h2> <p>Now we&#x2019;ll want to publish our package to package management systems. First, we have to deal with versioning, an important part of package management. With Paqui, the <strong>only</strong> <em>version number that matters</em> is the one in <code class="md-code md-code-inline">.paquirc</code>. That version number will be bumped with <code class="md-code md-code-inline">paqui bump</code>.</p> <p>Paqui also <em>does a little more</em> when we call bump the first time around. It will generate files (such as <code class="md-code md-code-inline">package.json</code>, and <code class="md-code md-code-inline">bower.json</code>) filled with information about the component.</p> <p><img alt="bump.png" title="Version bumping!" class="" src="https://i.imgur.com/onnWEaI.png"></p> <p>Missing information, such as the <code class="md-code md-code-inline">main</code> script reference some package managers require, is added during the <em>build</em> step. However, you don&#x2019;t need to worry about that, since <code class="md-code md-code-inline">paqui deploy</code> will always run <code class="md-code md-code-inline">bump</code> <em>before</em> it builds. It is always worth checking out what Paqui has generated, though. At least until you get the gist of how it works.</p> <h2 id="publishing">Publishing</h2> <p>The last step Paqui takes care of is publishing to the various package managers we opt to use. With Paqui, this can be done simply executing <code class="md-code md-code-inline">paqui publish</code> in our command line.</p> <p>Paqui conveniently packages <code class="md-code md-code-inline">bump</code>, <code class="md-code md-code-inline">build</code>, and <code class="md-code md-code-inline">publish</code> in another command: <code class="md-code md-code-inline">paqui deploy</code>. The flow I suggest would be:</p> <ul> <li>Create a repo on GitHub</li> <li><code class="md-code md-code-inline">paqui init -r username/project</code></li> <li><code class="md-code md-code-inline">paqui bump</code>, then verify generated files such as <code class="md-code md-code-inline">package.json</code>, or <code class="md-code md-code-inline">bower.json</code> <em>*</em></li> <li>Work on your client-side package</li> <li><code class="md-code md-code-inline">paqui build</code>, validate build results, located in the <code class="md-code md-code-inline">bin</code> directory <em>*</em></li> <li><code class="md-code md-code-inline">paqui deploy</code></li> </ul> <p><em>* (optional steps)</em></p> <p>So we have scaffolding, version bumping, a build step, and publishing. How can we configure these things?</p> <h2 id="configuring-paqui-init">Configuring <code class="md-code md-code-inline">paqui init</code></h2> <p>The following table shows data requested by <code class="md-code md-code-inline">init</code>, as well as its defaults.</p> <table> <thead> <tr> <th>Property</th> <th>Description</th> <th>Defaults</th> </tr> </thead> <tbody> <tr> <td><em>name</em></td> <td>Package name</td> <td>Project directory name</td> </tr> <tr> <td><em>description</em></td> <td>Pretty self explanatory</td> <td>Awesome package</td> </tr> <tr> <td><em>author</em></td> <td>Package author</td> <td>Info from <code class="md-code md-code-inline">git config --global --get</code></td> </tr> <tr> <td><em>version</em></td> <td>Package version</td> <td><code class="md-code md-code-inline">0.0.1</code></td> </tr> <tr> <td><em>transform</em></td> <td>Build steps</td> <td><code class="md-code md-code-inline">[&apos;universal&apos;, &apos;banner&apos;]</code></td> </tr> <tr> <td><em>transport</em></td> <td>Build results</td> <td><code class="md-code md-code-inline">[&apos;file&apos;]</code></td> </tr> <tr> <td><em>pm</em></td> <td>Package Managers</td> <td><code class="md-code md-code-inline">[&apos;npm&apos;, &apos;bower&apos;]</code></td> </tr> <tr> <td><em>license</em></td> <td>License under which we release the package</td> <td><strong>MIT</strong></td> </tr> <tr> <td><em>remote</em></td> <td>The git remote we will be pushing to</td> <td><code class="md-code md-code-inline">origin</code></td> </tr> <tr> <td><em>main</em></td> <td>The path to the entry point for our source code</td> <td><code class="md-code md-code-inline">&apos;src/main.js&apos;</code></td> </tr> </tbody> </table> <p>The results from these questions asked by Paqui, will be dumped into a JSON file called <code class="md-code md-code-inline">.paquirc</code>, where Paqui keeps everything needed to help you build and release your project.</p> <p>The relevant command-line options are:</p> <table> <thead> <tr> <th>Option</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="md-code md-code-inline">--remote &lt;url&gt;</code></td> <td>Provide a link to the remote, then init will automatically push to it after creating the local repository</td> </tr> <tr> <td><code class="md-code md-code-inline">--no-git</code></td> <td>Paqui won&#x2019;t create a git repository using <code class="md-code md-code-inline">git init</code>, nor attempt to push anything</td> </tr> <tr> <td><code class="md-code md-code-inline">--existing</code></td> <td>Creates a <code class="md-code md-code-inline">.paquirc</code> for an existing project</td> </tr> </tbody> </table> <blockquote> <p>Using <code class="md-code md-code-inline">paqui init --existing</code> is useful to integrate existing projects into Paqui.</p> </blockquote> <p>The four options which might be unclear at this point are: <code class="md-code md-code-inline">transform</code>, <code class="md-code md-code-inline">transport</code>, <code class="md-code md-code-inline">pm</code>, and <code class="md-code md-code-inline">license</code>. In the case of the last one, I decided not to make licesing extendable. At this point you can pick one of: <a href="http://choosealicense.com/licenses/apache/" target="_blank" aria-label="Apache v2 License on ChooseALicense.com">Apache</a>, <a href="http://choosealicense.com/licenses/gpl-v3/" target="_blank" aria-label="GPL v3 License on ChooseALicense.com">GPL</a>, or <a href="http://choosealicense.com/licenses/mit/" target="_blank" aria-label="MIT License on ChooseALicense.com">MIT</a>. If you&#x2019;d like to pick another license from Paqui, you&#x2019;re welcome to <a href="https://github.com/bevacqua/paqui/pulls/" target="_blank" aria-label="Pull Requests on Paqui">open a pull request</a> with more templates.</p> <h2 id="extending-paqui">Extending Paqui</h2> <p>The three remaning options are <em>extendable</em>. The <code class="md-code md-code-inline">transform</code> extensions govern <em>how your project is compiled</em>. These can be chained, and each transformer&#x2019;s output is piped onto the next one. By default, Paqui projects are compiled using the <code class="md-code md-code-inline">universal</code> and <code class="md-code md-code-inline">banner</code> extensions. The former wraps our code in a UMD definition, using Browserify. Then, <code class="md-code md-code-inline">banner</code> prepends a comment with author information, such as the version number, license type, or package name.</p> <p>To illustrate, let&#x2019;s examine the function exported by <code class="md-code md-code-inline">banner.js</code>, the file which defines its namesake extension. This function takes a <code class="md-code md-code-inline">paqui</code> argument, which is a succint API helper provided by Paqui. The function should return an object, and in this case, that object should have a <code class="md-code md-code-inline">transform</code> property, as <em>a function with three arguments</em>:</p> <ul> <li><code class="md-code md-code-inline">pkg</code>: a read-only copy of the contents of <code class="md-code md-code-inline">.paquirc</code></li> <li><code class="md-code md-code-inline">model</code>: an empty object which can be useful to communicate among different extensions</li> <li><code class="md-code md-code-inline">done</code>: callback to be executed when the extension&#x2019;s work is over, passing an optional error and the resulting code</li> </ul> <p>The current implementation is below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(paqui)</span> </span>{
    <span class="md-code-keyword">return</span> {
        transform: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(pkg, model, done)</span> </span>{
            <span class="md-code-keyword">var</span> main = path.join(paqui.wd, pkg.main);
            <span class="md-code-keyword">var</span> raw = <span class="md-code-string">&apos;&apos;</span>;
            <span class="md-code-keyword">var</span> b = browserify(main);
            <span class="md-code-keyword">var</span> stream = b.bundle({
                standalone: pkg.name
            });

            stream.on(<span class="md-code-string">&apos;data&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(data)</span> </span>{
                raw += data;
            });

            stream.on(<span class="md-code-string">&apos;end&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
                done(<span class="md-code-literal">null</span>, raw);
            });
        }
    };
};
</code></pre> <p>As you can see, all this does is take the <code class="md-code md-code-inline">main</code> path specified in <code class="md-code md-code-inline">.paquirc</code>, join it with the working directory provided by the Paqui API, and turn it into an UMD module, before passing it to <code class="md-code md-code-inline">done(null, raw)</code>. Using this micro-framework we&#x2019;ll be able to put together any kind of build step we want in just a few lines of code. The difference is that there&#x2019;s almost no configuration after that: we just provide the names to the plugins we want to use.</p> <p>These plugins are also available to extend what&#x2019;s done after builds, enabling us to do simple things such as writing to a file, or maybe we want to get creative and send an email, or print a report to the standard output. Similarly, we&#x2019;re able to add more package management systems on top of the ones provided by default, which are <code class="md-code md-code-inline">npm</code>, <code class="md-code md-code-inline">bower</code>, and <code class="md-code md-code-inline">component</code>.</p> <p>For more information on the <strong>Paqui API</strong> and to learn how to <em>extend its functionality</em>, <a href="https://github.com/bevacqua/paqui" target="_blank">visit its GitHub repository</a>.</p></div>
