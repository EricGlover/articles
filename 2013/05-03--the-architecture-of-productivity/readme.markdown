<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/the-architecture-of-productivity">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/the-architecture-of-productivity"><div></div></a>

<h1>The Architecture of Productivity</h1>

<p><kbd>software-development</kbd> <kbd>productivity</kbd> <kbd>architecture</kbd> <kbd>quotes</kbd></p>

<blockquote><p>It&#x2019;s been a while since I last blogged. I went on vacation, switched jobs, and have been generally busy. I&#x2019;m now working <em>full-time remote</em>, which will <em>&#x2026;</em></p></blockquote>

<div><p>It&#x2019;s been a while since I last blogged. I went on vacation, switched jobs, and have been generally busy. I&#x2019;m now working <em>full-time remote</em>, which will <em>hopefully</em> give me some more time to dedicate to this blog.</p></div>

<blockquote></blockquote>

<div><p>A few days ago, I read an <a href="https://plus.google.com/116904230181415286707/posts/DnAMAN5sUR8" target="_blank">interesting rant</a>, written by <a href="https://github.com/ry" target="_blank">Ryan Dahl</a>, about software development. It prompted me to write this blog post about it, and share my thoughts on the matter. You can find his post at the end of this entry.</p> <p><a href="https://github.com/ry" target="_blank">Ryan</a> <strong>boldly</strong> indicates that <em>all that matters in software development is user experience</em>. I disagree with this. And here&#x2019;s <em>why</em>.</p></div>

<div><p>While it&#x2019;s true that end user experience is the <em>single most important aspect</em> in software, it&#x2019;s undeniable that there are other aspects of software that should be treated carefully as well. I don&#x2019;t subscribe to the theory that &#x201C;anything you do beyond doing the bare minimum in order to solve the problem is utterly worthless&#x201D;, which Ryan hints at.</p> <p>When developing an application, you could always <a href="http://en.wikipedia.org/wiki/Overengineering" target="_blank" aria-label="Over-engineering definition">over-engineer</a>, which is bad, and where I&#x2019;d agree with Ryan. There are lots of principles you should try and follow here. <a href="http://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" target="_blank" aria-label="You ain&apos;t gonna need it">YAGNI</a> and <a href="http://en.wikipedia.org/wiki/KISS_principle" target="_blank" aria-label="Keep it simple, stupid">KISS</a> are important ones in regards to over-engineering.</p> <figure><img alt="over-engineering-meme.jpg" title="Over-engineering is bad" class="" src="https://i.imgur.com/JPsizDt.jpg"><figcaption>over-engineering-meme.jpg</figcaption></figure> <p>But <em>not everything is over-engineering</em>. Picking and tuning a text editor (in fact, my next blog topic), configuring a more seamless <a href="https://ponyfoo.com/search/tagged/build" aria-label="search posts tagged build">build</a> process, and learning the ins and outs of your everyday toolset, or more generally things that not <em>likely</em> to change, are all very effective ways to boost your development productivity. And, to me, it doesn&#x2019;t <em>just end</em> with configuring your environment, although it&#x2019;s perhaps the most significant productivity boost you could earn.</p> <p>Writing clean, <em>though concise</em>, application architectures can help to achieve the simplicity demanded by large software projects, while not being strictly directed towards solving the problem at hand. Clean architectures go a tremendous way towards the goal of positive user experiences, speed up development cycles by removing redundancy (<a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" aria-label="Don&apos;t repeat yourself">DRY</a>), and ensuring that no unexpected bugs are introduced, by making the application more easily testable.</p> <p>On the subject of not adding to the problem, I couldn&#x2019;t agree more. but that&#x2019;s something that&#x2019;s easily avoidable for the <em>vast majority</em> of software developers out there, who aren&#x2019;t working on languages, compilers, operating systems, or in a sufficiently large company that warrants creating a widely used DSL (such as <a href="https://developers.facebook.com/docs/reference/fql/" target="_blank" aria-label="Facebook Query Language">FQL</a>).</p> <p>I would reword his conclusion as:</p> <blockquote> <p>The single most important aspect in software development is end-user experience, but productivity in day-to-day software development is also <strong>crucial</strong> if you are expected to meet deadlines <em>today and in the future</em>. The software development experience might be just as important.</p> </blockquote> <p>Below is the post <a href="https://github.com/ry" target="_blank" aria-label="Ryan Dahl">Ryan</a> originally wrote.</p> <blockquote> <p>I hate almost all software. It&#x2019;s unnecessary and complicated at almost every layer. At best I can congratulate someone for quickly and simply solving a problem on top of the shit that they are given. The only software that I like is one that I can easily understand and solves my problems. The amount of complexity I&#x2019;m willing to tolerate is proportional to the size of the problem being solved.</p> <p>In the past year I think I have finally come to understand the ideals of Unix: file descriptors and processes orchestrated with C. It&#x2019;s a beautiful idea. This is not however what we interact with. The complexity was not contained. Instead I deal with DBus and /usr/lib and Boost and ioctls and SMF and signals and volatile variables and prototypal inheritance and <em>C99_FEATURES</em> and dpkg and autoconf.</p> <p>Those of us who build on top of these systems are adding to the complexity. Not only do you have to understand $LD_LIBRARY_PATH to make your system work but now you have to understand $NODE_PATH too - there&#x2019;s my little addition to the complexity you must now know! The users - the one who just want to see a webpage - don&#x2019;t care. They don&#x2019;t care how we organize /usr, they don&#x2019;t care about zombie processes, they don&#x2019;t care about bash tab completion, they don&#x2019;t care if zlib is dynamically linked or statically linked to Node. There will come a point where the accumulated complexity of our existing systems is greater than the complexity of creating a new one. When that happens all of this shit will be trashed. We can flush boost and glib and autoconf down the toilet and never think of them again.</p> <p>Those of you who still find it enjoyable to learn the details of, say, a programming language - being able to happily recite off if NaN equals or does not equal null - you just don&#x2019;t yet understand how utterly fucked the whole thing is. If you think it would be cute to align all of the equals signs in your code, if you spend time configuring your window manager or editor, if put unicode check marks in your test runner, if you add unnecessary hierarchies in your code directories, if you are doing anything beyond just solving the problem</p> <ul> <li>you don&#x2019;t understand how fucked the whole thing is. No one gives a fuck about the glib object model.</li> </ul> <p>The only thing that matters in software is the experience of the user.</p> </blockquote> <p>I recommend reading <a href="http://www.amazon.com/dp/020161622X" target="_blank" aria-label="The Pragmatic Programmer on Amazon">The Pragmatic Programmer</a>, if you are interested in learning more on how to be productive while staying on target and be a solid software thinker in general.</p> <figure><a href="http://www.amazon.com/dp/020161622X" target="_blank" aria-label="The Pragmatic Programmer on Amazon"><img alt="pragmatic-programmer.jpg" class="" src="https://i.imgur.com/3W9BJTe.jpg"></a><figcaption>pragmatic-programmer.jpg</figcaption></figure> <p>Until the next time!</p></div>
