<h1>Monitoring Production Grade Node Applications</h1>

<div><kbd>nodejs</kbd> <kbd>monitor</kbd> <kbd>performance</kbd></div>

<blockquote><p>Catching, or even <em>tracing</em> errors in Node applications can be <em>tricky sometimes</em>. I wanted to share a few practices that can help you <strong>keep your application up in most &#x2026;</strong></p></blockquote>

<div><p>Catching, or even <em>tracing</em> errors in Node applications can be <em>tricky sometimes</em>. I wanted to share a few practices that can help you <strong>keep your application up in most scenarios</strong>.</p></div>

<div></div>

<div><p>We shouldn&#x2019;t ever rely on the luxury of <em>hoping for the best</em> when it comes to <em>production application uptime</em>. There are a series of steps we can take to <em>prevent and minimize fatal exceptions</em>, while <strong>maximizing uptime and improving monitoring</strong>.</p></div>

<div><h3 id="log-exceptions-with-their-full-stack-traces">Log <strong>exceptions</strong> with their <em>full stack traces</em></h3> <p>This one is <em>obvious enough</em>. You have to watch out for exceptions getting lost in the sea of asynchronous code. This basically means figuring out whether a piece of code <em><code class="md-code md-code-inline">throw</code>s exceptions or uses the callback convention</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// the usual, sync way</span>
<span class="md-code-keyword">try</span>{
   syncOperation(); 
}<span class="md-code-keyword">catch</span>(e){
    <span class="md-code-comment">// rethrow, or handle it</span>
}

<span class="md-code-comment">// the async way</span>
asyncOperation(<span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(err, data)</span></span>{
    <span class="md-code-keyword">if</span>(err){
        <span class="md-code-comment">// bubble the exception up, or handle it</span>
        <span class="md-code-keyword">return</span>;
    }
});
</code></pre> <p>Keep in mind another important aspect of exception logging, is doing so in a persistant way. That is, <em>use a database storage</em> for your logging purposes. The <code class="md-code md-code-inline">console</code> is <em>just fine</em> for development environments, but you probably want something <em>more robust</em> in production.</p> <p><img alt="logging.jpg" title="Not the most useful kind of logging" class="" src="https://i.imgur.com/gBJfpgY.jpg"></p> <p>If you are, however, hosting on a platform such as <a href="https://www.heroku.com/" target="_blank" aria-label="Heroku Cloud Hosting">heroku</a>, where <code class="md-code md-code-inline">console</code> output is persisted, then you can opt not to log to a database yourself.</p> <p>Popular logging options for Node include <a href="https://github.com/flatiron/winston" target="_blank" aria-label="flatiron/winston on GitHub">winston</a> and <a href="https://github.com/trentm/node-bunyan" target="_blank" aria-label="trentm/node-bunyan on GitHub">bunyan</a>. Both support various logging adapters.</p> <h3 id="log-uncaughtexception-but-then-exit">Log <code class="md-code md-code-inline">uncaughtException</code>, but <em>then exit</em></h3> <p>When an exception is not handled anywhere else, it will be emitted on the <code class="md-code md-code-inline">process</code>&apos;s <code class="md-code md-code-inline">&apos;uncaughtException&apos;</code> event. We can listen for this event to do some logging, but we should allow the process to <em>shut down gracefully</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">process.on(<span class="md-code-string">&apos;uncaughtException&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(err)</span></span>{
    <span class="md-code-comment">// log the error</span>
    process.exit(<span class="md-code-number">1</span>);    
});
</code></pre> <h2 id="using-domains">Using Domains</h2> <p>Node has recently released the <a href="http://nodejs.org/api/domain.html" target="_blank" aria-label="Domain - Node Docs">Domain API</a>, which provides <em>a context</em> in which we can deal with uncaught exceptions.</p> <p>It&#x2019;s hard to put it any better than what the <em>Node Docs</em> have to offer:</p> <blockquote> <p>Domains provide a way to handle multiple different IO operations as a single group. If any of the event emitters or callbacks registered to a domain emit an <code class="md-code md-code-inline">error</code> event, or throw an error, then the domain object will be notified, rather than losing the context of the error in the <code class="md-code md-code-inline">process.on(&apos;uncaughtException&apos;)</code> handler, or causing the program to exit immediately with an error code.</p> </blockquote> <h2 id="failover-clusters">Failover Clusters</h2> <p><img alt="cluster.jpg" title="Not quite, but better than nothing!" class="" src="https://i.imgur.com/qpxYf8O.jpg"></p> <p>The <a href="http://nodejs.org/api/cluster.html" target="_blank" aria-label="Cluster - Node Docs">Cluster API</a> was published alongside <code class="md-code md-code-inline">domain</code>. Clusters allow us to use several processes, taking advantage of <em>multi-core systems</em>. The usefulness of clusters lies in the <em>ability to listen to the same port using several processes</em>. This is provided by the API itself.</p> <p>Here is a very unpolished example HTTP server, using clusters.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> cluster = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;cluster&apos;</span>);
<span class="md-code-keyword">var</span> http = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;http&apos;</span>);
<span class="md-code-keyword">var</span> numCPUs = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;os&apos;</span>).cpus().length;

<span class="md-code-keyword">if</span> (cluster.isMaster) {
  <span class="md-code-comment">// Fork workers.</span>
  <span class="md-code-keyword">for</span> (<span class="md-code-keyword">var</span> i = <span class="md-code-number">0</span>; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  cluster.on(<span class="md-code-string">&apos;exit&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(worker, code, signal)</span> </span>{
    <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;worker &apos;</span> + worker.process.pid + <span class="md-code-string">&apos; died&apos;</span>);
  });
} <span class="md-code-keyword">else</span> {
  <span class="md-code-comment">// Workers can share any TCP connection</span>
  <span class="md-code-comment">// In this case its a HTTP server</span>
  http.createServer(<span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(req, res)</span> </span>{
    res.writeHead(<span class="md-code-number">200</span>);
    res.end(<span class="md-code-string">&quot;hello world\n&quot;</span>);
  }).listen(<span class="md-code-number">8000</span>);
}
</code></pre> <p>Obviously we&#x2019;d like to <em>separate this</em> into two files, the master cluster and the forks. A nice improvement over this design might be <em>forking the cluster whenever a worker crashes</em>. We would simply need to add <code class="md-code md-code-inline">cluster.fork()</code> to the <code class="md-code md-code-inline">exit</code> listener.</p> <p>Node Docs explain:</p> <blockquote> <p>Because workers are all separate processes, they can be killed or re-spawned depending on your program&#x2019;s needs, without affecting other workers. As long as there are some workers still alive, the server will continue to accept connections. Node does not automatically manage the number of workers for you, however. It is your responsibility to manage the worker pool for your application&#x2019;s needs.</p> </blockquote> <p>I <strong>highly recommend</strong> skimming <em>(at the very least)</em> through both <a href="http://nodejs.org/api/domain.html" target="_blank" aria-label="Domain - Node Docs">domain</a> and <a href="http://nodejs.org/api/cluster.html" target="_blank" aria-label="Cluster - Node Docs">cluster</a> documentation pages, as they are really short and extremely valuable for whoever&#x2019;s interested in keeping their servers uptime at a respectable level.</p> <h2 id="the-last-stand-uptime-monitoring">The Last Stand, Uptime Monitoring</h2> <p>Ultimately, even the master cluster <em>can</em> fail. As a last resort, we might set up a process that monitors our application&#x2019;s port. We can determine a <em>finite number of states</em> our application and port might be in.</p> <ul> <li>Server completely shut down. No port listener</li> <li>Server preparing to listen. No port listener</li> <li>Server listening</li> </ul> <p>Armed with this knowledge, we could assert whether our application is down, starting, or up. We might set up a <em>monitoring process</em>, which would run <em>in parallel</em> with our server process(es).</p> <p>I created an <code class="md-code md-code-inline">npm</code> package explicitly to deal with this kind of scenario. The <a href="https://github.com/bevacqua/process-finder" target="_blank" aria-label="bevacqua/process-finder on GitHub">process-finder</a> package helps us find processes listening on a port, and even more handily, it lets us watch the port for changes!</p> <p>Here&#x2019;s a tentative <code class="md-code md-code-inline">monitor.js</code> application.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> finder = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;process-finder&apos;</span>);
<span class="md-code-keyword">var</span> port = <span class="md-code-number">3000</span>; <span class="md-code-comment">// port to watch</span>
<span class="md-code-keyword">var</span> watcher = finder.watch(port);
<span class="md-code-keyword">var</span> runner = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;./runner.js&apos;</span>);

watcher.on(<span class="md-code-string">&apos;error&apos;</span>, <span class="md-code-built_in">console</span>.error);
watcher.on(<span class="md-code-string">&apos;listen&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(pid)</span></span>{
    <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;Cluster Up!&apos;</span>, pid);
});
watcher.on(<span class="md-code-string">&apos;unlisten&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(pid)</span></span>{
    <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;Cluster Down!&apos;</span>, pid);
    runner.start();
});

runner.start();
</code></pre> <p>Where <code class="md-code md-code-inline">runner.js</code> would simply <a href="http://nodejs.org/api/child_process.html" target="_blank" aria-label="Child Process - Node Docs">spawn</a> a new server. The spawned process would eventually listen in the application&#x2019;s port, and it might even use a <strong>cluster</strong>, as we previously discussed, to improve its resilience.</p> <p>We got this far in <em>our efforts to reduce server downtime</em>, we should go the extra mile here. Most definitely, we would benefit from having our logger <em>send us an email</em> whenever a worker dies, or at the very least, whenever the <code class="md-code md-code-inline">monitor</code> has to restart our <code class="md-code md-code-inline">cluster</code> because a previous cluster <em>went deaf</em>.</p> <h2 id="performance-analytics">Performance Analytics</h2> <p>Monitoring your application is great, but you&#x2019;d probably like charts with that, too. You can use a tool such as <a href="http://nodefly.com/" target="_blank" aria-label="NodeFly Monitoring Solution">NodeFly</a>, or <a href="http://nodetime.com/" target="_blank" aria-label="Nodetime Performance Analytics">Nodetime</a> for this purpose.</p> <p>These solutions allow you to track CPU usage, server load, database load, perform memory profiling, and <em>more</em>. Make sure to check them out. They also allow you to set up alerts when certain thresholds are surpassed.</p> <h4 id="nodetime">Nodetime</h4> <p>Nodetime&#x2019;s <a href="http://docs.nodetime.com/#alerts" target="_blank" aria-label="Alerts - Nodetime Documentation">documentation</a> explains:</p> <blockquote> <p>It is important to be notified when an application is experiencing performance problems in order to prevent downtime and be able to quickly locate the problem&#x2019;s root cause, while profiling exact problem symptoms, which might disappear later. Nodetime allows users to create threshold and anomaly alerts for many internal metrics of the application - for example, if HTTP response time is continuously high or there are too few requests. It is also possible to set alerts on API call metrics of different supported libraries, such as MongoDB, Redis, and MySQL.</p> </blockquote> <p>Both solutions are trivially easy to set up.</p> <p>For <a href="http://nodetime.com/" target="_blank" aria-label="Nodetime Performance Analytics">Nodetime</a>, all you need to do is the following:</p> <h4 id="sign-up-http-nodetimecom-signup-sign-up-nodetime"><a href="http://nodetime.com/signup" target="_blank" aria-label="Sign up - Nodetime">Sign Up</a></h4> <p>Sign up with them to get an API key.</p> <h4 id="install">Install</h4> <p>Install their <code class="md-code md-code-inline">npm</code> module.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">$ npm install nodetime --save
</code></pre> <h4 id="setup">Setup</h4> <p>Load and configure the module using the API key linked to your account.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;nodetime&apos;</span>).profile({
    accountKey: <span class="md-code-string">&apos;your_account_key&apos;</span>, 
    appName: <span class="md-code-string">&apos;your_application_name&apos;</span>
});
</code></pre> <p>And, <em>that&#x2019;s it!</em></p></div>
