<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/taming-asynchronous-javascript">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/taming-asynchronous-javascript"><div><img src="https://i.imgur.com/QiE11db.jpg" alt="Taming Asynchronous JavaScript"></div></a>

<h1>Taming Asynchronous JavaScript</h1>

<p><kbd>async</kbd> <kbd>callback-hell</kbd> <kbd>js</kbd> <kbd>best-practices</kbd> <kbd>quotes</kbd></p>

<blockquote><p>Last month, a series of <em>very</em> interesting articles regarding <strong>async coding style</strong>, in Node, popped up. The discussion spanned a few more subjects than <em>just coding style</em>, it &#x2026;</p></blockquote>

<div><p>Last month, a series of <em>very</em> interesting articles regarding <strong>async coding style</strong>, in Node, popped up. The discussion spanned a few more subjects than <em>just coding style</em>, it was analyzed in a more <em>theoretical level</em>, as well as a <em>deep technical level</em>, obviously on the <em>practical level</em>, and <em>even politics</em> saw the limelight in this <em>fascinating</em> argument.</p></div>

<blockquote></blockquote>

<div><p>I&#x2019;ll try my best to put together a coherent article on the subject that doesn&#x2019;t put you to sleep. But I wouldn&#x2019;t bet my horse on that.</p> <p>I&#x2019;d bet <em>yours</em>, though.</p></div>

<div><p>I do realize I got <em>one month too late</em> to the party, but <a href="https://ponyfoo.com/the-architecture-of-productivity" aria-label="The Architecture of Productivity">like I mentioned</a>, I was too busy visiting coffee shops in Amsterdam. Without further ado&#x2026;</p> <h3 id="case-study-callbacks-https-githubcom-caolan-async-async-callback-library-vs-promises-https-githubcom-kriskowal-q-q-promise-library">Case Study: <a href="https://github.com/caolan/async" target="_blank" rel="noopener noreferrer" aria-label="&apos;async&apos; callback library">Callbacks</a> vs. <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener noreferrer" aria-label="&apos;q&apos; promise library">Promises</a></h3> <p>Firstly, I would like to cite the series of resources that prompted this blog post.</p> <ul> <li><a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises" target="_blank" rel="noopener noreferrer" aria-label="An introduction to promises">You&#x2019;re Missing the Point of Promises</a>, an introduction to promises</li> <li><a href="http://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity" target="_blank" rel="noopener noreferrer" aria-label="James&apos; post in favor of promises in Node">Node&#x2019;s biggest missed opportunity</a>, the article that triggered the <em>blog-post hell</em>, by <a href="https://github.com/jcoglan" target="_blank" rel="noopener noreferrer" aria-label="James Coglan on GitHub">James Coglan</a></li> <li><a href="http://www.futurealoof.com/posts/broken-promises.html" target="_blank" rel="noopener noreferrer" aria-label="Broken Promises, written by Mikeal Rogers">Broken Promises</a>, narrating why promises were <code class="md-code md-code-inline">.reject()</code>&apos;d in Node, by <a href="https://github.com/mikeal" target="_blank" rel="noopener noreferrer" aria-label="Mikeal Rogers on GitHub">Mikeal Rogers</a></li> <li><a href="http://sealedabstract.com/code/broken-promises" target="_blank" rel="noopener noreferrer" aria-label="Broken Promises, written by Drew Crawford, an iOS developer">Broken Promises</a>, another reply, depicting the pitfalls of promises and evangelizing patterns</li> <li><a href="http://blog.jcoglan.com/2013/04/01/callbacks-promises-and-simplicity" target="_blank" rel="noopener noreferrer" aria-label="James&apos; conclusions on the matter">Callbacks, promises, and simplicity</a>, where James makes some concessions and concludes his point</li> </ul> <p>These are possibly the lengthiest articles written on the subject, but they definitely are the most interesting ones. I recommend to take your time and read through all of them, you won&#x2019;t regret it.</p> <p>[&#x2026;]</p> <p>So, you&#x2019;ve read them all? <strong>Great!</strong></p> <p>Lets back up a little bit, now, and point out the source of the conflict. Node <em>supported promises</em> early on, but they decided to <a href="https://groups.google.com/forum/?fromgroups=#!msg/nodejs/sWE0Oa80iNg/-n7xPyOdGd8J" target="_blank" rel="noopener noreferrer" aria-label="Ryan explains why promises aren&apos;t such a good fit for Node">drop support</a> for them shortly afterwards, partially because of the volume of disagreement they generated. Thus, they <em>sticked with callbacks</em>.</p> <figure><img alt="call-me.jpg" title="Overly attached callbacks" class="" src="https://i.imgur.com/1B12xqM.jpg"></figure> <p>The different modules packaged through <kbd>npm</kbd>, swiftly followed the convention of passing <code class="md-code md-code-inline">function(err, results){}</code> as the last parameter, a convention was silently born.</p> <h1 id="my-point-of-view">My Point of View</h1> <p>While developing <a href="https://github.com/bevacqua/ponyfoo" target="_blank" rel="noopener noreferrer" aria-label="ponyfoo on GitHub">this blogging engine</a>, and <em>particularly</em> the <a href="https://github.com/bevacqua/node-assetify" target="_blank" rel="noopener noreferrer" aria-label="assetify on GitHub">asset manager</a> behind it, I made extensive use of <a href="https://github.com/caolan/async" target="_blank" rel="noopener noreferrer" aria-label="async on GitHub">async</a>, which vastly improves upon the <em>raw power</em> of manually chaining callbacks.</p> <p>I felt comfortable dealing with callbacks, but some more <em>complex scenarios demanded a more robust solution</em>, such as the ones <strong>async</strong> provides.</p> <p>As far as promises go, I&#x2019;ve been working with <a href="http://api.jquery.com/category/deferred-object/" target="_blank" rel="noopener noreferrer" aria-label="Deferred Object - jQuery API docs">jQuery.Deferred</a> for a while now, mostly in AJAX scenarios, though.</p> <p>Recently, I started working on an application that makes more extensive use of promises, both through <a href="http://angularjs.org/" target="_blank" rel="noopener noreferrer" aria-label="AngularJS MVW Framework">AngularJS</a> on the client-side, and using <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener noreferrer" aria-label="&apos;q&apos; promise library">Q</a> on the server-side.</p> <p>On the client-side, this makes perfect sense. We have <strong>jQuery</strong> performing similar operations, and the complexity requirements for asynchronous code aren&#x2019;t as steep as they are in the back-end.</p> <p>Front-end async operations <em>tend to be way simpler</em> than those performed on the server-side. There <em>rarely</em> is the need to create a deeply nested hierarchy of callbacks: an event handler making an AJAX request and maybe even doing something else with the response. You might even have a thin layer that creates a cache of the responses, but that&#x2019;s about it. From this standpoint, it makes sense using promises.</p> <p>On the other side, promises tend to result in more convoluted, complex code in Node.</p> <figure><img alt="broken-promises.jpg" title="Broken Promises" class="" src="https://i.imgur.com/qPrHNz6.jpg"></figure> <blockquote> <p>To me, it&#x2019;s not a matter of simplicity, <a href="http://blog.jcoglan.com/2013/04/01/callbacks-promises-and-simplicity" target="_blank" rel="noopener noreferrer" aria-label="Callbacks, promises, and simplicity">as James puts it</a>, but rather, a matter of <strong>both practicality and productivity</strong>.</p> </blockquote> <blockquote> <p>Practicality, because it&#x2019;s just <em>more straightforward</em> to use callbacks in an environment where <strong>it&#x2019;s the standard to do so</strong>. <em>Productivity</em> is a side-effect bonus here, bending the application to use promises in a portion of the code would be an unwarranted waste of time.</p> </blockquote> <p>And <em>think of the drawbacks</em>. It would also be unnatural and lead to a chaotic codebase where everyone has an opinion on how code should look like. It&#x2019;s not even that promises are <em>wrong</em>, it&#x2019;s just that, <em>at this point in time</em>, they <strong>don&#x2019;t belong</strong> in Node.</p> <p>Again, not because promises are <em>wrong</em>, or <em>&#x201C;broken&#x201D;</em>, but they don&#x2019;t fit in, they don&#x2019;t accomplish anything that can&#x2019;t be done using callbacks. Besides, mixing both styles might even <em>complicate</em> matters, making it particularly confusing to handle errors, for example.</p> <h2 id="error-handling-conventions-in-javascript">Error Handling Conventions in JavaScript</h2> <p>There is a very simple convention in JavaScript you should abide by, if you want to build <em>successful and clean</em> applications. And that is, how to write properly error-handling functions.</p> <blockquote> <p>Synchronous code should <code class="md-code md-code-inline">throw</code>, Asynchronous code shouldn&#x2019;t. Ever.</p> </blockquote> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sync</span><span class="md-code-params">()</span></span>{
    <span class="md-code-keyword">try</span>{
        <span class="md-code-keyword">return</span> taskThatMayThrow();
    }<span class="md-code-keyword">catch</span>(e){
        <span class="md-code-built_in">console</span>.log(e); <span class="md-code-comment">// handle</span>
    }
}

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">async</span><span class="md-code-params">(done)</span></span>{
    operation(<span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(err, result)</span></span>{
        <span class="md-code-keyword">if</span>(err){
            <span class="md-code-keyword">return</span> done(err); <span class="md-code-comment">// bubble up</span>
        }
        result += <span class="md-code-number">1</span>; <span class="md-code-comment">// [...] further processing</span>
        done(<span class="md-code-literal">null</span>, result);
    });
}
</code></pre> <p>Simple enough, when dealing with asynchronous code, you should always <em>bubble exceptions</em> up, so that <em>the caller can choose</em> to either handle them, or bubble them further up the callback chain. This way, your application can handle errors gracefully, rather than quit unexpectedly (or require <code class="md-code md-code-inline">process.on(&apos;uncaughtException&apos;)</code> in order to survive).</p> <h3 id="conclusion">Conclusion</h3> <p>I definitely think Node is better off without promises, broken or otherwise. The client-side ecosystem is a little less well-defined, and as such, a more suitable home for promises, but even then, it&#x2019;s just a matter of preference to use one or the other.</p></div>
