<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/angular-wysiwyg">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/angular-wysiwyg"><div></div></a>

<h1>Angular WYSIWYG</h1>

<p><kbd>angularjs</kbd> <kbd>wysiwyg</kbd> <kbd>ponyedit</kbd></p>

<blockquote><p>Building on the blocks laid out <a href="https://ponyfoo.com/2013/10/25/event-emitter-obey-and-report">in my previous article</a>, I open-sourced a <a href="http://en.wikipedia.org/wiki/WYSIWYG" target="_blank">WYSIWYG</a> editing library <em>which doesn&#x2019;t provide an UI</em>. You can <a href="https://github.com/bevacqua/ponyedit" target="_blank">find the source code here</a>.</p><p><code>&#x2026;</code></p></blockquote>

<div><p>Building on the blocks laid out <a href="https://ponyfoo.com/2013/10/25/event-emitter-obey-and-report">in my previous article</a>, I open-sourced a <a href="http://en.wikipedia.org/wiki/WYSIWYG" target="_blank">WYSIWYG</a> editing library <em>which doesn&#x2019;t provide an UI</em>. You can <a href="https://github.com/bevacqua/ponyedit" target="_blank">find the source code here</a>.</p></div>

<blockquote></blockquote>

<div><p><code class="md-code md-code-inline">ponyedit</code> allows us to interact with a <code class="md-code md-code-inline">contentEditable</code> element by following the <strong>Obey and Report</strong> pattern. It emits events whenever its state changes, and it takes commands that alter this state. This enables us to completely decouple the user interface from the component&#x2019;s functionality. In this article, we&#x2019;ll dig a little deeper into the pattern, analyzing the decisions made in ponyedit, how it came together, its resulting API, and the <a href="https://github.com/bevacqua/ponyedit/blob/master/web/assets/js/example.js" target="_blank">sample <em>bare bones</em> UI implementation</a>.</p></div>

<div><p>The sample UI, bundled in the module&#x2019;s repository, looks like this:</p> <p><img alt="ui.png" title="A sample UI implementation for ponyedit" class="" src="https://i.imgur.com/NYNlIWg.png"></p> <h3 id="implemented-in-angular">Implemented in Angular</h3> <p>The <a href="http://ponyedit.herokuapp.com/angular" target="_blank" aria-label="Ponyedit using Angular">Angular implementation example</a> for <code class="md-code md-code-inline">ponyedit</code> uses a directive and a controller. However we could organize the application however we want it, as the library doesn&#x2019;t set forth any constraints. The directive will simply instance the object on a DOM element. The controller will display the object state, and allow us to send commands back to the object. Please note this is just the way I hacked it together in under 5 minutes, definitely not the best way to go about it. You might want everything in a single directive. In the particular use case we had, we needed to display state and commands in a panel that was controlled by a directive, while the editor was within another directive, so <code class="md-code md-code-inline">ponyedit</code> was born.</p> <p>Here&#x2019;s the sample directive.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">app.directive(<span class="md-code-string">&apos;ponyeditable&apos;</span>, [
    <span class="md-code-string">&apos;$rootScope&apos;</span>,
    <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">($rootScope)</span> </span>{
        <span class="md-code-keyword">return</span> {
            restrict: <span class="md-code-string">&apos;A&apos;</span>,
            link: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(scope, element, attrs)</span> </span>{
                <span class="md-code-keyword">var</span> dom = element[<span class="md-code-number">0</span>];
                ponyedit.init(dom);
                $rootScope.$broadcast(<span class="md-code-string">&apos;pony&apos;</span>, dom);
            }
        };
    }
]);
</code></pre> <p>This directive is loaded with <code class="md-code md-code-inline">article.editable(ponyeditable)</code> in the <a href="https://github.com/bevacqua/ponyedit/blob/master/web/views/angular.jade" target="_blank" aria-label="Sample Jade file">example Jade file</a>.</p> <blockquote> <p>As you can see, that just initializes the editor, and then broadcasts so our controller can do its thing. Clearly this doesn&#x2019;t scale up very well at all (if you have multiple instances of this directive), but I wanted to keep things simple for the demo.</p> </blockquote> <p>The controller could definitely be simpler, but I didn&#x2019;t want to include the entire ponyeditor in the scope, to get a more decoupled result. Its code is below:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">app.controller(<span class="md-code-string">&apos;exampleCtrl&apos;</span>, [
    <span class="md-code-string">&apos;$scope&apos;</span>,
    <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">($scope)</span> </span>{
        $scope.$on(<span class="md-code-string">&apos;pony&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(e, element)</span> </span>{
            <span class="md-code-keyword">var</span> pony = ponyedit(element);

            $scope.state = {};
            $scope.setBold = pony.setBold.bind(pony);
            $scope.setItalic = pony.setItalic.bind(pony);
            $scope.decreaseSize = pony.decreaseSize.bind(pony);
            $scope.increaseSize = pony.increaseSize.bind(pony);

            pony.on(<span class="md-code-string">&apos;report.*&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(value, property)</span> </span>{
                $scope.state[property] = value;

                <span class="md-code-keyword">if</span> (!$scope.$$phase) {
                    $scope.$apply();
                }
            });
        });
    }
]);
</code></pre> <p>The controller acts as a proxy, just passing commands through to the ponyeditor, and passing state reports through to the <code class="md-code md-code-inline">$scope</code>. This keeps the controller thin. The view has some bindings to display the state, and wire up the commands.</p> <pre class="md-code-block"><code class="md-code md-lang-css">div.ui(ng-controller=&apos;exampleCtrl&apos;, ng-disabled=&apos;!state.active&apos;)
    span.ui-state.ui-bold(ng-click=&apos;setBold()&apos;, ng-class=&apos;{true:&quot;ui-enabled&quot;}[state.bold]&apos;) Bold
    span.ui-state.ui-italic(ng-click=&apos;setItalic()&apos;, ng-class=&apos;{true:&quot;ui-enabled&quot;}[state.italic]&apos;) Italic
    span.ui-state.ui-size-up(ng-click=&apos;increaseSize()&apos;) +
    span.ui-state.ui-size-down(ng-click=&apos;decreaseSize()&apos;) -
</code></pre> <p>That&#x2019;s all I had to do in order to use <code class="md-code md-code-inline">ponyedit</code> with Angular from the ground up, giving it a UI that <em>just works</em>.</p> <h3 id="get-the-source">Get the Source!</h3> <p>All the library really does is sort out a few inconsistencies in <code class="md-code md-code-inline">contentEditable</code> elements, and provide a nice API around it, making it almost feel easy to deal with it. The code is <a href="https://github.com/bevacqua/ponyedit/blob/master/src/ponyedit.js" target="_blank" aria-label="ponyedit.js on GitHub">fairly easy to follow</a>, and I <a href="https://github.com/bevacqua/ponyedit#api" target="_blank" aria-label="Ponyedit API documentation on GitHub">thoroughly documented its public API</a>, so that&#x2019;s definitely worth a look if you&#x2019;re interested.</p></div>
