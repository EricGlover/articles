<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/the-web-wars">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/the-web-wars"><div></div></a>

<h1>The Web Wars</h1>

<p><kbd>js</kbd> <kbd>async</kbd> <kbd>architecture</kbd> <kbd>lazyjs</kbd> <kbd>politics</kbd></p>

<blockquote><p>There have always been wars in browser-land. Browsers, specs, politics, <em>lots</em> of politics. Even <em>libraries</em> had theirs.</p><p>What once was the browser <em>utility library</em> war, has &#x2026;</p></blockquote>

<div><p>There have always been wars in browser-land. Browsers, specs, politics, <em>lots</em> of politics. Even <em>libraries</em> had theirs.</p></div>

<blockquote></blockquote>

<div><p>What once was the browser <em>utility library</em> war, has now been settled, <a href="http://jquery.com/" target="_blank">jQuery</a> won that. We are now in the midst of another one, the <em>framework</em> war, with <a href="http://angularjs.org/" target="_blank">AngularJS</a> leading the competition. There are lots to pick from though, and it isn&#x2019;t anywhere near settled. Popular frameworks include <a href="http://backbonejs.org/" target="_blank">BackboneJS</a>, <a href="http://emberjs.com/" target="_blank">EmberJS</a>, <a href="http://sproutcore.com/" target="_blank">SproutCore</a>, <a href="http://knockoutjs.com/" target="_blank">KnockoutJS</a>, just to name a few.</p> <p>Before <strong>Node</strong>, and frameworks like <strong>Angular</strong>, it wasn&#x2019;t all that common opening a web project and finding front-end code <em>organized in a way that scaled</em>. This war will probably drag on for at least a couple more years. Maybe even <em>indefinitely</em>.</p> <p>As we can see on <a href="http://todomvc.com/" target="_blank">TodoMVC</a>, there are <em>a boatload</em> of different <strong>MV</strong>* frameworks out there. I expect that many of those won&#x2019;t make it very far, while a few will gain more traction.</p> <p>I&#x2019;ll also be covering <a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank">CommonJS</a> vs <a href="http://requirejs.org/" target="_blank">RequireJS</a> vs <a href="http://bevacqua.github.io/lazyjs/" target="_blank">LazyJS</a>, an alternative I developed.</p></div>

<div><p><img alt="angularjs.png" title="AngularJS application framework" class="" src="https://i.imgur.com/hYmljo5.png"></p> <p>I believe <a href="http://angularjs.org/" target="_blank" aria-label="Angular Model-View-Whatever Framework">AngularJS</a> has a <em>good chance</em> of winning. It&#x2019;s a great combination of <strong>MV</strong>* patterns, great modularization. It&#x2019;s <em>debatable</em> whether IoC will captivate developers at large, but they certainly implemented it in a <em>clean and coherent</em> way. Their solution is highly <em>extensible</em>, higly <em>comprehensive</em>, and, <em>considering its extensive feature-set</em>, extremely <em>intuitive and easy to use</em>. So, kudos <strong>Google</strong>!</p> <p>However, it won&#x2019;t enjoy the <em>widespread adoption</em> that <strong>jQuery</strong> has. <strong>jQuery</strong> is, ultimately, a utility library that&#x2019;s meant to be <em>auxiliary</em> to your application, <strong>AngularJS</strong> is an integral solution, and it restricts how you can organize your front end architecture.</p> <p>Lets get into <a href="http://requirejs.org/" target="_blank" aria-label="RequireJS script loader">RequireJS</a>, a script loader that resembles the <strong>AngularJS</strong> <a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank" aria-label="Dependency Injection">dependency injection</a> mechanism.</p> <h2 id="a-little-background-history">A little background history</h2> <p>There was a time when Node was coming up, when they had to decide on a spec to organize the complex code architecture that comes with a web application&#x2019;s back end. The <a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" aria-label="CommonJS Modules Spec">CommonJS Modules/1.1</a> spec was conceived. But it didn&#x2019;t <em>quite work</em> in browser-land.</p> <p>It wasn&#x2019;t that long ago <a href="http://blog.millermedeiros.com/amd-is-better-for-the-web-than-commonjs-modules/" target="_blank" aria-label="AMD is better for the web than CommonJS modules, by Miller Medeiros">CommonJS and RequireJS</a> took sides in a little skirmish. Fortunately, that&#x2019;s <a href="http://tomdale.net/2012/01/amd-is-not-the-answer/" target="_blank" aria-label="AMD is Not the Answer, by Tom Dale">more or less</a> settled. To be fair, I created <a href="http://bevacqua.github.io/lazyjs/" target="_blank" aria-label="LazyJS: The minimalist JS loader">LazyJS</a> in hopes to <em>reignite</em> that argument. I&#x2019;ll expand on that later.</p> <h2 id="commonjs-modules-11-http-wikicommonjsorg-wiki-modules-11-commonjs-modules-spec"><a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" aria-label="CommonJS Modules Spec">CommonJS Modules/1.1</a></h2> <p>Modules, as defined by the CommonJS spec, the so-called <em>Node way</em>, are directly related to the files that contain them, and can be included using <code class="md-code md-code-inline">require</code>. A module will contain all properties published in the public interface defined in <code class="md-code md-code-inline">module.exports</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// util.js</span>

<span class="md-code-built_in">module</span>.exports = {
	public_api: <span class="md-code-literal">true</span>,
	log_message: <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(message)</span></span>{
		<span class="md-code-built_in">console</span>.log(message);
	}
};

<span class="md-code-comment">// main.js</span>

<span class="md-code-keyword">var</span> util = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;./util.js&apos;</span>);
expect(util.public_api).toBeTruthy();
util.log_message(<span class="md-code-string">&apos;foo&apos;</span>);

<span class="md-code-comment">// &gt; foo</span>
</code></pre> <p>This pattern is <em>very good for Node</em>.</p> <ul> <li>Everything that&#x2019;s not exposed with <code class="md-code md-code-inline">module.exports</code> is considered private to the module</li> <li>Modules are interpreted once, and their results are stored for subsequent calls to <code class="md-code md-code-inline">require</code></li> <li>It&#x2019;s similar to what we see in other, <em>non-prototypal</em>, server side languages</li> <li>Modules just execute and return a value. You are not tied to a particular pattern</li> </ul> <h2 id="requirejs-http-requirejsorg-requirejs-script-loader"><a href="http://requirejs.org/" target="_blank" aria-label="RequireJS script loader">RequireJS</a></h2> <p><img alt="requirejs.jpg" title="RequireJS script loader" class="" src="https://i.imgur.com/tkY5UGR.jpg"></p> <p><a href="http://requirejs.org/docs/whyamd.html" target="_blank" aria-label="Why AMD? - RequireJS">AMD</a> is a <em>concession</em> to the fact that browsers are just terminals and, unlike Node, assets are fetched <strong>over the network</strong>. This introduces a host of problems, such as latency, uncertainty (that the file will <em>ever</em> load), asynchronicity, and such.</p> <p><strong>AMD</strong> attempts to correct these issues by providing an <em>asynchronous module loading pattern</em>.</p> <pre class="md-code-block"><code class="md-code">define(&apos;module&apos;, function(dep1, dep2){
	return function(){};
});
</code></pre> <p>Benefits of using <strong>RequireJS</strong> include the following.</p> <ul> <li>Modular code that isn&#x2019;t limited to one module per file, like CommonJS modules are</li> <li><strong>AMD</strong> modules work even if they aren&#x2019;t resolved immediatly, due to dependencies such a script in an external <a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" aria-label="Content Delivery Network">CDN</a></li> <li><a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank" aria-label="Dependency Injection">DI</a> pattern. Dependencies are <em>inferred from the arguments</em>, resolved, and injected to the module function, all of which is done by <strong>RequireJS</strong></li> </ul> <h2 id="behind-enemy-lines">Behind enemy lines</h2> <p>If you are like me, you don&#x2019;t care about the <em>politics</em> behind different specs and solutions. All that matters is getting a clean solution that <em>just works</em>.</p> <blockquote> <p>It&#x2019;s a fact that <strong>CommonJS</strong> was not aimed at the browser, and although I prefer it for Node, I wouldn&#x2019;t try and force it into browser-land. However, <strong>RequireJS</strong> attempts to do too much when it comes to the browser, and <em>kind of fails at it</em>.</p> </blockquote> <p>You need a lot of boilerplate code in order to get <strong>AMD</strong> working, and <em>it shouldn&#x2019;t have to be that way</em>.</p> <p><strong>RequireJS</strong> set out to be a <em>simple and easy to use</em> script loading solution, but that&#x2019;s not quite what you find here.</p> <blockquote> <p><strong>RequireJS</strong> allows modules on the <code class="md-code md-code-inline">Object</code> level, but I&#x2019;m <em>not so hot</em> on the idea that my script loader should <em>also</em> take on the task of providing <a href="http://en.wikipedia.org/wiki/Inversion_of_control" target="_blank" aria-label="Inversion of Control technique">inversion of control</a> and dependency injection mechanisms</p> </blockquote> <p>Besides that, there are some <em>unwanted complications</em>. The example above won&#x2019;t work when the JS is <em>minified</em>, because the arguments on the anonymous function will get renamed to something like <code class="md-code md-code-inline">a, b</code>, meaning they won&#x2019;t be able to infer the names of the modules anymore. The solution, is <strong>even more verbose</strong>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">define(<span class="md-code-string">&apos;module&apos;</span>, [<span class="md-code-string">&apos;dep1&apos;</span>, <span class="md-code-string">&apos;dep2&apos;</span>], <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(dep1, dep2)</span></span>{
	<span class="md-code-keyword">return</span> <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">()</span></span>{};
});
</code></pre> <p>This leaves you wondering why they try so hard to provide <strong>something that just won&#x2019;t work in production environments</strong>. And why does everyone have to modify their code to comply with yours? That&#x2019;s <em>just not right</em>.</p> <h1 id="how-is-lazyjs-any-different">How is <strong>LazyJS</strong> any different?</h1> <ul> <li>Modules don&#x2019;t need to adhere to silly conventions, you can you require them providing the <code class="md-code md-code-inline">/path/to/the/source.js</code></li> <li><em>Faster</em>, very little JS is parsed on page load, after that, necessary JS is parsed on demand</li> <li><em>Less tightly coupled</em>. Directives are comments that don&#x2019;t define the way you should style your code</li> <li><em>Less ceremony</em>. Use the same tools and concepts in development and production</li> <li><em>Succint</em>. Give it a hint of which modules you depend on, <em>that&#x2019;s it</em></li> <li><a href="http://en.wikipedia.org/wiki/KISS_principle" target="_blank" aria-label="Keep it simple stupid">KISS</a></li> </ul> <p><a href="http://bevacqua.github.io/lazyjs/" target="_blank" aria-label="LazyJS: The minimalist JS loader">LazyJS</a> is different in that <strong>it can become whatever you want it to be</strong>. It&#x2019;s different in that it lets you organize blocks of code (entire files or chunks), and specify their dependencies.</p> <p>For now it doesn&#x2019;t even have an API, it&#x2019;s just <em>an idea</em>. And I want to spend some time figuring out the best &#x201C;out of the box&#x201D; feature-set, without staining everyone&#x2019;s code with extra code.</p> <p>Suppose you want it to &#x201C;become&#x201D; <strong>CJS</strong>, then you should reference a bundle, disable AJAX calls, and let it resolve everything on its own before, synchronously, giving you a result back.</p> <p>Similarly, you can leave it pretty much on its <a href="https://github.com/bevacqua/lazyjs/tree/9d3c3173ec067a83f5e4afafc29b9e195ef05798" target="_blank" aria-label="LazyJS on GitHub">current state</a>, expose the <code class="md-code md-code-inline">.lookup(url, done)</code> <a href="https://github.com/bevacqua/lazyjs/blob/9d3c3173ec067a83f5e4afafc29b9e195ef05798/src/lazy-loader.js#L112" target="_blank" aria-label="LazyJS on GitHub">function</a>, and voil&#xE1;, you&#x2019;ve got RequireJS. Sort of.</p> <p>Feedback regarding <a href="http://bevacqua.github.io/lazyjs/" target="_blank" aria-label="LazyJS: The minimalist JS loader">LazyJS</a> is welcome, and I promise to try my best to leave it <em>as agnostic and unopinionated as possible</em>.</p></div>
