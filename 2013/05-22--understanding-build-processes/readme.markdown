<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/understanding-build-processes">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/understanding-build-processes"><div></div></a>

<h1>Understanding Build Processes</h1>

<p><kbd>build</kbd> <kbd>productivity</kbd> <kbd>best-practices</kbd></p>

<blockquote><p>A <em>task runner</em> helps you automate everything you need to get an environment functional. Configure, build, run tests, and execute your web server. But there&#x2019;s more &#x2026;</p></blockquote>

<div><p>A <em>task runner</em> helps you automate everything you need to get an environment functional. Configure, build, run tests, and execute your web server. But there&#x2019;s more than that to a build system. Particularly, in the <em>local environment</em>, there&#x2019;s a lot you could do to improve <em>development productivity</em>.</p></div>

<blockquote></blockquote>

<div><p>The single most important aspect of even resorting to a build system is producing a <strong>one-step build process</strong>. This means doing everything with a simple command, such as <code class="md-code md-code-inline">grunt dev</code>. We&#x2019;ll look at ways to make that happen, and how to improve it as your applications grow. I&#x2019;ll also mention some of the most common tasks in the process, as well as some that aren&#x2019;t <em>as widely adopted</em>.</p> <p>Even though I&#x2019;ll be talking about <a href="http://gruntjs.com/" target="_blank">Grunt</a>, I won&#x2019;t get <em>intimate</em> with the tool itself. The concepts I&#x2019;ll describe should apply to any decent build tool you might pick for the job.</p></div>

<div><h1 id="why-a-build-process">Why a build process?</h1> <p>I figure a good idea, assuming you&#x2019;ve never done this before, is start by laying out the benefits of using a well-defined build process.</p> <p>Chances are, you&#x2019;ve worked in a project where you had to take several steps before you could get your local environment to work. Such a setup process might look similar to this:</p> <ul> <li>Create the database by hand. Lucky you, it&#x2019;s just <a href="http://www.linux.org/article/view/create-mysql-database-via-command-line" target="_blank" aria-label="Create MySQL database via command line">three easy steps</a>!</li> <li>Restore a data dump into the database. <code class="md-code md-code-inline">mysql -u root -p suicide_db &lt; ./dump.sql</code></li> <li>Maybe edit the <a href="https://en.wikipedia.org/wiki/Hosts_(file)" target="_blank" aria-label="hosts file explained">hosts</a> file <em>by hand</em></li> <li>Configure local variables such as database authentication, listener port, etc. Usually done <em>by hand</em></li> <li>Download the latest version of the code. <code class="md-code md-code-inline">git pull</code></li> <li>Download external libraries from a repository such as <a href="https://npmjs.org/" target="_blank" aria-label="npm packages">npm</a>, <a href="http://nuget.org/" target="_blank" aria-label="NuGet repository">NuGet</a>, <a href="http://rubygems.org/" target="_blank" aria-label="Ruby gems">gem</a>, <a href="https://pypi.python.org/pypi/pip" target="_blank" aria-label="Python package index">pip</a>. <code class="md-code md-code-inline">npm install</code></li> <li>Compile your code (in non-interpreted, compiled languages). <code class="md-code md-code-inline">msbuild</code></li> <li>Upgrade the database to the latest version. Generally done by a <em>post-build event</em></li> <li>Run every unit test. <code class="md-code md-code-inline">java junit.swingui.TestRunner test.Run</code></li> <li>Compile assets such as <a href="http://coffeescript.org/" target="_blank" aria-label="CoffeeScript Language">CoffeeScript</a> and <a href="http://sass-lang.com/" target="_blank" aria-label="SASS Language">SASS</a>. <code class="md-code md-code-inline">coffee --compile --output ./js ./bin</code></li> <li>Start the web server. <code class="md-code md-code-inline">node ./server.js</code></li> </ul> <p>Granted, this is <em>just for the first time</em>, or so you tell yourself. But the truth is, except for a few steps such as restoring the database, you are going to <em>run every single of these steps in <strong>production</strong></em>. Well, actually, you are going to want to add a few more steps for a production build. Lets see:</p> <ul> <li>Start fresh, <strong>don&#x2019;t leave anything behind</strong>, except the <em>data</em></li> <li>Compile your code in <em>release</em> mode, removing debugging symbols</li> <li>Bundle and minify assets. <code class="md-code md-code-inline">uglifyjs ./foo/main.js -o ./bin/foo.min.js</code></li> <li>Finally, point the web server to the new version</li> </ul> <p>Sure, frosting on our cake. But you can&#x2019;t deny <strong>it adds up</strong>. Lets see, <strong>oh!</strong> We might also want to do crafty things in our local environment.</p> <ul> <li>Display <a href="https://ponyfoo.com/2013/03/06/defensive-design" aria-label="Defensive Design">full stack traces</a> when things blow up</li> <li>Use the <em>unminified</em> versions of vendor libraries such as <a href="http://jquery.com/" target="_blank" aria-label="jQuery library">jQuery</a></li> <li>Execute all the build steps again after making any changes</li> </ul> <p>And think of the benefits of a one step build process!</p> <p>You could now hook your repository with continuous integration platforms that <strong>alert you</strong> in case your tests are <em>acting up</em>, and from there, think just how easy it becomes to <code class="md-code md-code-inline">push</code> changes to different environments.</p> <blockquote> <p>The question should then be: <strong>why <em>not</em> use a build process?</strong></p> </blockquote> <h1 id="where-to-start">Where to start?</h1> <p>The very first thing you need to do, is <strong>investigate</strong>. Learn about the <em>different build tools</em> out there and find one that fits your project. It&#x2019;s usually a safe bet to pick the most popular build tool around your language. Once you&#x2019;ve picked a tool, you&#x2019;ll need to <strong>identify the core steps</strong> it takes to build and run the application, and how those steps <em>mutate for each environment</em>. Find <em>commonalities</em>.</p> <p>After you&#x2019;ve identified these steps, you will have to decide which of those steps will pertain to the <em>build process</em>. You might entertain the idea of doing <strong>absolutely everything</strong> in that one step, and it might be the right thing to do. But maybe you can leave aside the database creation, while keeping the upgrades, for example. At this point you&#x2019;ll have to decide whether you want the build step to also function as a <strong>&#x201C;first-time setup&#x201D;</strong>, or not.</p> <h1 id="build-step-by-step-in-depth">Build step by step, in depth</h1> <p>Lets go back to the <em>setup process</em> I outlined earlier, and examine those steps.</p> <blockquote> <ul> <li>Create the database by hand. Lucky you, it&#x2019;s just <a href="http://www.linux.org/article/view/create-mysql-database-via-command-line" target="_blank" aria-label="Create MySQL database via command line">three easy steps</a>!</li> <li>Restore a data dump into the database. <code class="md-code md-code-inline">mysql -u root -p suicide_db &lt; ./dump.sql</code></li> </ul> </blockquote> <p>I&#x2019;d leave steps like these to <strong>a separate flow</strong>, designed to set up the local development environment. The reason is <em>obvious enough</em>. We don&#x2019;t want to be <em>dropping the database</em> and filling it with fake data at any point other than when we set up our local environment. These are probably the only couple of steps I&#x2019;d be comfortable doing manually, and by that I mean: not in a single command execution.</p> <blockquote> <ul> <li>Maybe edit the <a href="https://en.wikipedia.org/wiki/Hosts_(file)" target="_blank" aria-label="hosts file explained">hosts</a> file <em>by hand</em></li> <li>Configure local variables such as database authentication, listener port, etc. Usually done <em>by hand</em></li> </ul> </blockquote> <p>This kind of configuration usually changes over time, so you must have good, <strong>up-to-date</strong> documentation on how to set up these things. The best thing you can do about this is either add part of this to the <em>setup flow</em> we discussed earlier, or alternatively, add default configuration files that are <em>obvious enough</em> to let developers get set up on their own.</p> <blockquote> <ul> <li>Download the latest version of the code. <code class="md-code md-code-inline">git pull</code></li> <li>Download external libraries from a repository such as <a href="https://npmjs.org/" target="_blank" aria-label="npm packages">npm</a>, <a href="http://nuget.org/" target="_blank" aria-label="NuGet repository">NuGet</a>, <a href="http://rubygems.org/" target="_blank" aria-label="Ruby gems">gem</a>, <a href="https://pypi.python.org/pypi/pip" target="_blank" aria-label="Python package index">pip</a>. <code class="md-code md-code-inline">npm install</code></li> </ul> </blockquote> <p>In the local environment, it might be sensible pulling code and installing dependencies by hand, rather than in an automated way, so that you have finer control over these things. Outside the local environment, this kind of steps will depend on the platform you are using.</p> <p>In the case of this blog, for example, I am using <a href="https://www.heroku.com/" target="_blank" aria-label="Heroku Cloud Application Platform">Heroku</a>. Heroku takes care of both of these steps. Well, I <code class="md-code md-code-inline">git push heroku master</code>, and they respond by pulling that code, executing <code class="md-code md-code-inline">npm install</code>, and running the application with a command I provide. <a href="https://travis-ci.org/" target="_blank" aria-label="Travis: Free Hosted Continuous Integration">Travis</a> provides a free CI service, which also takes care of fetching my latest changes and installing dependencies. This might not always be the case, so you should learn your integration or hosting platform, maybe you <em>do have</em> to push your dependency packages as well.</p> <blockquote> <ul> <li>Compile your code (in non-interpreted, compiled languages). <code class="md-code md-code-inline">msbuild</code></li> <li>Upgrade the database to the latest version. Generally done by a <em>post-build event</em></li> </ul> </blockquote> <p>In the case of the blog, I don&#x2019;t really have to compile anything, and <a href="http://mongoosejs.com/" target="_blank" aria-label="Mongoose ODM">Mongoose</a> takes care of keeping my schemas up to date, <a href="http://www.mongodb.org/" target="_blank" aria-label="MongoDB database engine">MongoDB</a> doesn&#x2019;t really care at all. But, <em>generally speaking</em>, this step will entail compiling your code using the command-line version of your language&#x2019;s compiler, and somehow updating the database. <a href="https://code.google.com/p/dbup/" target="_blank" aria-label="Upgrading SQL server databases the right way">DbUp</a> is probably an awesome example of how this is done in <strong>.NET</strong>.</p> <blockquote> <ul> <li>Run unit tests. <code class="md-code md-code-inline">java junit.swingui.TestRunner test.Run</code></li> </ul> </blockquote> <p>Your code compiled, that&#x2019;s your first line of defense. In the case of JavaScript, that&#x2019;d be a <a href="http://www.jshint.com/" target="_blank" aria-label="JSHint Code Quality Tool">linter</a>. Now your test suite needs to give the green-light. Build tools are usually very well-suited to execute unit test runs, and output the test logs, so this one shouldn&#x2019;t be an issue once you learn the quirks of configuring the tool to run the tests.</p> <blockquote> <ul> <li>Compile assets such as <a href="http://coffeescript.org/" target="_blank" aria-label="CoffeeScript Language">CoffeeScript</a> and <a href="http://sass-lang.com/" target="_blank" aria-label="SASS Language">SASS</a>. <code class="md-code md-code-inline">coffee --compile --output ./js ./bin</code></li> <li>Bundle and minify assets. <code class="md-code md-code-inline">uglifyjs ./foo/main.js -o ./bin/foo.min.js</code></li> </ul> </blockquote> <p>Nowadays, it is very common in web applications to resort to some little <a href="http://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" aria-label="Domain Specific Language">DSL</a>, in order to avoid redundancies such as writing all the prefixes to <code class="md-code md-code-inline">border-radius</code>, a tool can help you with this. But you then need to compile it, or you need an asset manager such as <a href="https://github.com/bevacqua/node-assetify" target="_blank" aria-label="assetify: the Node asset manager">assetify</a> or <a href="https://github.com/jetheredge/SquishIt" target="_blank" aria-label="asset optimization library for .NET">SquishIt</a>, to do that for you.</p> <p>Sometimes those very libraries can handle bundling and minification as well, it&#x2019;s usually best to do it with the least amount of libraries, that translates as <em>less compatibility issues</em> and <strong>less headaches</strong>.</p> <blockquote> <ul> <li>Start the web server. <code class="md-code md-code-inline">node ./server.js</code></li> </ul> </blockquote> <p>This too is <em>platform dependent</em>. Maybe you just want to do this locally for convenience. Maybe you don&#x2019;t need to do it <em>yourself</em> in your hosting platform, but <em>someone</em> has to trigger the web server to listen for incoming requests.</p> <blockquote> <ul> <li>Execute all the build steps again after making any changes</li> </ul> </blockquote> <p>This might currently be one of the most sought after, <em>and trending</em>, build steps. But in order to have a build process that restarts itself, using something like <a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank" aria-label="grunt-contrib-watch on GitHub">grunt-watch</a>, you must first have a very solid build process that deals with virtually everything I&#x2019;ve discussed so far.</p> <p>I&#x2019;ve tried <a href="http://www.jetbrains.com/webstorm/" target="_blank" aria-label="WebStorm JavaScript IDE">WebStorm</a> but I don&#x2019;t think I&#x2019;m sold on the whole <a href="http://blog.jetbrains.com/webide/2012/08/liveedit-plugin-features-in-detail/" target="_blank" aria-label="LiveEdit plugin features in detail">live-edit</a> thing, mainly because <em>it doesn&#x2019;t play very well</em> with others. Meaning that if you have a custom build process, chances are it&#x2019;s going to <em>break down</em>.</p> <p>I&#x2019;m fine with <em>tabbing away</em> from <a href="http://www.sublimetext.com/" target="_blank" aria-label="Sublime Text Editor">my editor</a>, and just <em>refreshing</em> my browser. The trick is to enable auto-save. <code class="md-code md-code-inline">&quot;save_on_focus_lost&quot;: true</code></p> <p>You can check out the <a href="https://github.com/bevacqua/ponyfoo" target="_blank" aria-label="ponyfoo platform repository">ponyfoo</a> repo if you want to figure out how I&#x2019;ve configured the build process for this site.</p> <h1 id="a-book">A Book?</h1> <p>I&#x2019;m currently engaged in talks regarding <strong>writing a book</strong> on the subject of <em>build processes</em>, maintainable software <em>architecture</em>, and in particular, how these concepts are <em>applied in JavaScript</em>, a language where these things used to be <strong>utterly disregarded</strong>, and are now beginning to get some affection.</p> <blockquote> <p>Your feedback and suggestions are more than welcome!</p> </blockquote></div>
