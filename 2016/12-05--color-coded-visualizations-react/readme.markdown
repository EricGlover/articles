<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/color-coded-visualizations-react">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/color-coded-visualizations-react"><div><img src="https://i.imgur.com/cw8wWN2.jpg" alt="Thousands of Color-coded Visualizations in React"></div></a>

<h1>Thousands of Color-coded Visualizations in React</h1>

<p><kbd>react</kbd> <kbd>react-fiber</kbd> <kbd>visualizations</kbd></p>

<blockquote><p>For the past few days I&#x2019;ve been working on a data visualization that displays Elasticsearch node distribution across different cloud instances and zones.</p>
</blockquote>

<div><p>For the past few days I&#x2019;ve been working on a data visualization that displays Elasticsearch node distribution across different cloud instances and zones. This article shows off the visualization, the color generation script, an interesting performance issue, and the solution I arrived at.</p></div>

<blockquote></blockquote>

<div><blockquote> <p>This article was originally posted on the <a href="https://www.elastic.co/blog/color-coded-visualizations-react" target="_blank" rel="noopener noreferrer">Elastic company blog</a>.</p> </blockquote> <p>User interfaces for cloud services are typically boring, long lists of nodes, clusters, regions, proxies, users, snapshots, logs, and lists. Identifying patterns in the data is mostly a responsibility of the UI implementor, and not so much the consumer. When such an identifiable pattern emerges, implementors should come up with ways to break away from these long tabular data lists and display data in more valuable ways.</p> <p>Tabular data is by its very nature repetitive and boring. There is nothing wrong with displaying boring data, but visualizations can certainly help identify outliers when we have long data lists.</p> <p>The following screenshot shows a small fraction of a list of allocators, along with their health and available capacity. An allocator is a container that may host several Elasticsearch or Kibana Docker instances, and perhaps some available capacity. These allocators are sorted by available capacity, which becomes immediately obvious when we use a visualization to display how capacity is distributed in each allocator. The visualizations are relative to each other in width, so it&#x2019;s easier to understand the relationship between different allocators in terms of total capacity.</p> <figure class="figure-has-loaded"><img src="https://i.imgur.com/ZpyYMV1.png" alt="A list of allocators and their respective node distributions."></figure> <p>Note that this is just the end-result of what we arrived at after around two weeks of on-and-off iteration on the design and UX of the visualization. Let&#x2019;s go over that iteration process.</p></div>

<div><h1 id="design-iteration">Design Iteration</h1> <p>As usual, the design process started with a simple PR <a href="https://github.com/kimjoar" target="_blank" rel="noopener noreferrer" aria-label="@kimjoar on Twitter">Kim</a> made that displayed bars which depicted how full an allocator was relative to its total capacity.</p> <figure><img alt="Initial implementation." class="" src="https://i.imgur.com/ADGi8Jf.png"></figure> <p>Then <a href="https://github.com/pmoust" target="_blank" rel="noopener noreferrer" aria-label="@pmoust on GitHub">Panos</a> proposed using a color palette to illustrate breaks between different nodes.</p> <blockquote> <p>Nice! Is it possible to get like a <code class="md-code md-code-inline">1px</code> divider per occupied capacity segment? Or an alternating color palette indicating different nodes and their size? i.e:</p> <pre class="md-code-block"><code class="md-code">10.10.10.10   -  (y)  -  6  - 0  -   4 GB   -  [###|###|######|#########|####|####|    ]
10.10.10.11   -  (y)  -  4  - 0  -  10 GB   -  [###|###|######|#####|                  ]
</code></pre> </blockquote> <p>That ended up in a redesign <a href="https://github.com/kimjoar" target="_blank" rel="noopener noreferrer" aria-label="@kimjoar on Twitter">Kim</a> implemented, where he also made the full visualization width relative to the largest allocator&#x2019;s total capacity. This redesign also <a href="https://i.imgur.com/LLG5gaC.png" target="_blank" rel="noopener noreferrer" aria-label="After implementing Panos&apos; idea of color-coding each different node">helped</a> get a notion of how many nodes an allocator has, and roughly how big they are. <a href="https://github.com/kimjoar" target="_blank" rel="noopener noreferrer" aria-label="@kimjoar on Twitter">Kim</a>&#x2019;s PR got merged shortly after that, but <a href="https://twitter.com/nzgb" target="_blank" rel="noopener noreferrer" aria-label="@nzgb on Twitter">I had</a> my own ideas as well.</p> <p>I removed the border used to display how much total capacity an allocator had, instead choosing to rely on a striped repeating linear gradient to represent available capacity. I also added tooltips that mentioned how large the nodes were, and made each slice in the visualization a link to that node&#x2019;s view. The links turned out to be pretty useful, as they avoid going through an allocator&#x2019;s page when we want to visit a particular node &#x2013; especially when they&#x2019;re large and thus easy to identify.</p> <figure><img alt="First draft of my changes." class="" src="https://i.imgur.com/2tya0uL.png"></figure> <p>Then <a href="https://github.com/alexbrasetvik" target="_blank" rel="noopener noreferrer" aria-label="@alexbrasetvik on GitHub">Alex</a> came in with one of my favorite suggestions: using color shades per node size variation.</p> <blockquote> <p>Could it make sense to have different shades of the same color per size? Instead of explaning, threw together this ugly example:</p> <img alt="" class="" src="https://i.imgur.com/DnMhWAR.png"> </blockquote> <p>This change made colors more meaningful communicators of how the data is shaped. Before, each node took a color from a repeating list with a few colors. After, as seen below, each node with same capacity is colored in different shades of one color, making colors more meaningful.</p> <figure><a href="https://i.imgur.com/uKX3bug.png" target="_blank" rel="noopener noreferrer" aria-label="Expand image to full size"><img alt="Color coding helps distinguish different capacity tiers by looking at the color of each slice." title="Expand image to full size" class="" src="https://i.imgur.com/uKX3bug.png"></a></figure> <p>We experimented with color shading. <strong>A lot.</strong> At first we used the original colors Kim had used. Then I came up with a brighter color scheme, but that was too bright. Then we used some of the brand&#x2019;s colors, and lastly I improved the shade <a href="https://ponyfoo.com/articles/es6-generators-in-depth" aria-label="ES6 Generators in Depth">generator</a> algorithm quite a bit.</p> <div class="mde-inline mde-33"><p><a href="https://i.imgur.com/4HVYWRr.png" target="_blank" rel="noopener noreferrer" aria-label="Expand image to full size"><img alt="" class="" src="https://i.imgur.com/4HVYWRr.png"></a></p> </div><div class="mde-inline mde-33"><p><a href="https://i.imgur.com/35EjlGL.png" target="_blank" rel="noopener noreferrer" aria-label="Expand image to full size"><img alt="" class="" src="https://i.imgur.com/35EjlGL.png"></a></p> </div><div class="mde-inline mde-33"><p><a href="https://i.imgur.com/gi50jBw.png" target="_blank" rel="noopener noreferrer" aria-label="Expand image to full size"><img alt="" class="" src="https://i.imgur.com/gi50jBw.png"></a></p> </div><p>The design process is still ongoing &#x2013; as you know, web applications are never really &#x201C;done&#x201D;!</p> <p>We&#x2019;re experimenting with a small line at the bottom that describes whether the node we&#x2019;re illustrating is a Kibana instance or an Elasticsearch instance. This piece of work also normalizes colors so that all nodes of the same capacity use the same color &#x2013; across all visualizations. Colors changed a bit, <em>again</em>, because bright contiguous shades of red, yellow, and green could be mistaken for cluster state. We&#x2019;ve also added a legend so that humans know at a glance what each color means.</p> <figure><img alt="The next version, that&apos;s being currently worked on!" class="" src="https://i.imgur.com/ZpyYMV1.png"></figure> <p>Let&#x2019;s look at some code.</p> <h1 id="color-shade-generation-in-javascript">Color Shade Generation in JavaScript</h1> <p>All of the colors and shades are produced by an <a href="https://ponyfoo.com/articles/es6-generators-in-depth" aria-label="ES6 Generators in Depth">infinite generator sequence</a>. You can see <a href="https://codepen.io/bevacqua/pen/YpabJB" target="_blank" rel="noopener noreferrer">a demo in action on CodePen</a>. I&#x2019;ll explain the code below.</p> <p>First off, we import the <a href="https://github.com/tmcw/color-ops" target="_blank" rel="noopener noreferrer" aria-label="tmcw/color-ops on GitHub"><code class="md-code md-code-inline">color-ops</code></a> package. This nice little utility let&#x2019;s us perform basic color operations like spin, darken, or desaturate.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import ops from <span class="md-code-string">&apos;color-ops&apos;</span>
</code></pre> <p>Next up we have a tiny utility that can be paired with <code class="md-code md-code-inline">Array#reduce</code> to apply several functions in an array to transform a value. An usage example for <code class="md-code md-code-inline">waterfall</code> could look like <code class="md-code md-code-inline">[v =&gt; v * 2, v =&gt; v + 3].reduce(waterfall, 5)</code>, which would result in <code class="md-code md-code-inline">5 * 2</code>, and then <code class="md-code md-code-inline">10 + 3</code>, returning <code class="md-code md-code-inline">13</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> waterfall = (currentColor, nextCommand) =&gt; nextCommand(currentColor)
</code></pre> <p>Next up we have a couple of utility functions to transform <code class="md-code md-code-inline">rgb</code> components into an <code class="md-code md-code-inline">[r, g, b, a]</code> array, which is the data structure <code class="md-code md-code-inline">color-ops</code> relies on. The <code class="md-code md-code-inline">rgbString</code> function takes the output from <code class="md-code md-code-inline">color-ops</code> and turns it into a solid CSS color.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> rgb = (r, g, b, a = <span class="md-code-number">1</span>) =&gt; [r, g, b, a]
<span class="md-code-keyword">const</span> rgbString = ([r, g, b]) =&gt; `rgb(${r}, ${g}, ${b})`

<span class="md-code-keyword">const</span> unknownColor = rgb(<span class="md-code-number">123</span>, <span class="md-code-number">123</span>, <span class="md-code-number">123</span>)

<span class="md-code-keyword">const</span> baseColors = <span class="md-code-keyword">new</span> Map([
  [<span class="md-code-number">1024</span> * <span class="md-code-number">64</span>, rgb(<span class="md-code-number">40</span>, <span class="md-code-number">114</span>, <span class="md-code-number">150</span>)], <span class="md-code-comment">// turquoise</span>
  [<span class="md-code-number">1024</span> * <span class="md-code-number">32</span>, rgb(<span class="md-code-number">213</span>, <span class="md-code-number">189</span>, <span class="md-code-number">62</span>)], <span class="md-code-comment">// yellow</span>
  [<span class="md-code-number">1024</span> * <span class="md-code-number">16</span>, rgb(<span class="md-code-number">50</span>, <span class="md-code-number">167</span>, <span class="md-code-number">194</span>)], <span class="md-code-comment">// cyan</span>
  [<span class="md-code-number">1024</span> * <span class="md-code-number">8</span>, rgb(<span class="md-code-number">37</span>, <span class="md-code-number">146</span>, <span class="md-code-number">98</span>)], <span class="md-code-comment">// green</span>
  [<span class="md-code-number">1024</span> * <span class="md-code-number">4</span>, rgb(<span class="md-code-number">61</span>, <span class="md-code-number">64</span>, <span class="md-code-number">120</span>)], <span class="md-code-comment">// blue</span>
  [<span class="md-code-number">1024</span> * <span class="md-code-number">2</span>, rgb(<span class="md-code-number">121</span>, <span class="md-code-number">88</span>, <span class="md-code-number">67</span>)], <span class="md-code-comment">// brown</span>
  [<span class="md-code-number">1024</span>, rgb(<span class="md-code-number">138</span>, <span class="md-code-number">66</span>, <span class="md-code-number">138</span>)], <span class="md-code-comment">// purple</span>
])
</code></pre> <p>We&#x2019;re finally getting to the generator code! Our generator is called <code class="md-code md-code-inline">capacityShader</code> and it produces an infinite sequence, so we need to be careful about how we read values off of it, so that we&#x2019;re not stuck in an infinite loop. The <code class="md-code md-code-inline">shadeIndex</code> tracks what shade of the base color we should <code class="md-code md-code-inline">yield</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">capacityShader</span><span class="md-code-params">(baseColor)</span> </span>{
  <span class="md-code-keyword">let</span> shadeIndex = <span class="md-code-number">0</span>

  <span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
    <span class="md-code-comment">// the infinite sequence</span>
  }
}
</code></pre> <p>As you probably know, the <code class="md-code md-code-inline">%</code> remainder operator returns the remainder of the division. We use this to cycle in the <code class="md-code md-code-inline">0..baseColors.length</code> range regardless of how large the <code class="md-code md-code-inline">currentColorIndex</code> becomes, without having to worry about doing the cycling math by hand.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> baseColorIndex = currentColorIndex % baseColors.length
<span class="md-code-keyword">const</span> baseColor = baseColors[baseColorIndex]
</code></pre> <p>In the loop, we calculate a <code class="md-code md-code-inline">light</code> index and an <code class="md-code md-code-inline">offset</code>, which are used to generate slightly different variations of each color. The <code class="md-code md-code-inline">light</code> variable sits in the <code class="md-code md-code-inline">0..16</code> range, <em>in <code class="md-code md-code-inline">4</code> unit steps:</em> <code class="md-code md-code-inline">0</code>, <code class="md-code md-code-inline">4</code>, &#x2026;, <code class="md-code md-code-inline">16</code>. The <code class="md-code md-code-inline">offset</code> value sits in the <code class="md-code md-code-inline">0..2</code> range. Note how for indices of <code class="md-code md-code-inline">0</code>, our modifiers are also <code class="md-code md-code-inline">0</code>. This means any sequence begins using the base color itself. The combination of both offsets means there&#x2019;s 15 possible shades of each color: <code class="md-code md-code-inline">light</code> as <code class="md-code md-code-inline">0..4 * 4</code> and <code class="md-code md-code-inline">offset</code> as <code class="md-code md-code-inline">0..2</code>, so <code class="md-code md-code-inline">5 * 3</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> light = currentCapacityIndex * <span class="md-code-number">4</span> % <span class="md-code-number">20</span>
<span class="md-code-keyword">const</span> offset = currentCapacityIndex % <span class="md-code-number">3</span>
</code></pre> <p>The <code class="md-code md-code-inline">light</code> value will be used to determine what shade of the color we want, while the <code class="md-code md-code-inline">offset</code> is also used to toggle saturation so that shades of the same color are less uniformly distributed, and thus easier to tell apart from each other. We use the <code class="md-code md-code-inline">Array#reduce</code> waterfall to apply the color operations on the base color, and then round each component of the <code class="md-code md-code-inline">[r, g, b, a]</code> result.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> tasks = [
  currentColor =&gt; ops.lighten(currentColor, light + offset * <span class="md-code-number">4</span>),
  currentColor =&gt; ops.saturate(currentColor, offset * <span class="md-code-number">8</span>),
  currentColor =&gt; currentColor.map(<span class="md-code-built_in">Math</span>.round)
]

<span class="md-code-keyword">const</span> shade = tasks.reduce(waterfall, baseColor)
</code></pre> <p>At long last, we <code class="md-code md-code-inline">yield</code> the CSS RGB string version of the resulting color shade, suspending execution in the generator.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">yield</span> rgbString(shade)
</code></pre> <p>Then we just add one to the counter, and return to the top of the <code class="md-code md-code-inline">while (true)</code> loop.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">shadeIndex++
</code></pre> <p>In order to consume the generator, we instantiate it and read the sequence by hand.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> shader = createCapacityShader(baseColor)
<span class="md-code-keyword">const</span> color = shader.next().value
</code></pre> <p>While we want a new shade of the same color, we keep calling <code class="md-code md-code-inline">g.next()</code>. When we want to switch to a different color, we&#x2019;ll need to create a new shader object. The screenshot below shows the generator in action, rendering each shade 15 times before moving on to a new generator. As you can see, the generators are deterministic in that the same shades are generated every 15 steps. Saturation offsets make it easy to notice the difference between consecutive shades of the same color. Compare the screenshot below to <a href="https://i.imgur.com/35EjlGL.png" target="_blank" rel="noopener noreferrer" aria-label="Expand image to full size">the previous screenshot</a>, where saturation offsets hadn&#x2019;t been introduced yet.</p> <figure><a href="https://codepen.io/bevacqua/pen/YpabJB" target="_blank" rel="noopener noreferrer"><img alt="A CodePen demo with all the colors produced by the generator code." class="" src="https://i.imgur.com/Bryi7ZG.png"></a></figure> <p>The other cool piece of code was something I dubbed the <code class="md-code md-code-inline">&lt;NonBlockingRenderLoop&gt;</code> component.</p> <h1 id="rendering-non-critical-ui-components-last">Rendering Non-Critical UI Components Last</h1> <p>There&#x2019;s thousands of nodes in this page, which translates into thousands of DOM elements for the visualizations. As we were iterating on this page, we noticed a <em>significantly noticeable</em> performance drop that resulted in the entire page being frozen for several seconds at a time, as shown in the following performance profile taken during page load, as DOM nodes were being mounted.</p> <figure><img alt="All work happens upfront, and every DOM node is mounted at the same time." class="" src="https://i.imgur.com/NvFEsAm.png"></figure> <p>My solution was to defer all visualizations by wrapping them in a magical <code class="md-code md-code-inline">NonBlockingRenderLoop</code> component:</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">NonBlockingRenderLoop</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">InstanceCapacitiesViz</span> { <span class="md-code-attribute">...props</span> } /&gt;</span>
<span class="md-code-tag">&lt;/<span class="md-code-title">NonBlockingRenderLoop</span>&gt;</span>
</code></pre> <p>Afterwards, the UI stopped freezing for seconds at a time. Instead, non-critical work was deferred until after the rest of the UI loaded, and then it was only done progressively, not constantly. At the same time, the visualizations load fast enough that waiting for them to load doesn&#x2019;t become an issue.</p> <figure><img alt="After deferring non-critical UI components to an asynchronous yet sequential rendering loop." class="" src="https://i.imgur.com/NqJeetF.png"></figure> <p>So how does the <code class="md-code md-code-inline">&lt;NonBlockingRenderLoop&gt;</code> component work? The idea is fairly simple: any component controls when and how its children are rendered. If our <code class="md-code md-code-inline">render</code> method returns <code class="md-code md-code-inline">null</code>, then nothing would be rendered, but if we returned <code class="md-code md-code-inline">this.props.children</code> then we&#x2019;d render our child components. We could <em>&#x2013; for example &#x2013;</em> implement an element like the following, which would block rendering of any children for one second.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> NonBlockingRenderLoop extends Component {
  state = {
    wait: <span class="md-code-literal">true</span>
  }
  componentDidMount() {
    setTimeout(() =&gt; <span class="md-code-keyword">this</span>.setState({ wait: <span class="md-code-literal">false</span> }), <span class="md-code-number">1000</span>)
  }
  render() {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">this</span>.state.wait ? <span class="md-code-literal">null</span> : <span class="md-code-keyword">this</span>.props.children
  }
}
</code></pre> <p>While this would be good enough to load non-critical components after critical ones, they&#x2019;d still load all at the same time, which wouldn&#x2019;t be very much of an improvement. Instead, I came to a solution that&#x2019;s a bit similar, except that it relies on <code class="md-code md-code-inline">requestAnimationFrame</code> and a lock. The way it works is:</p> <ol> <li>All components start off blocking their children</li> <li>All components loop through <code class="md-code md-code-inline">requestAnimationFrame</code>, checking on a lock</li> <li>One component obtains the lock</li> <li>Inside the <code class="md-code md-code-inline">requestAnimationFrame</code> callback, the component updates its <code class="md-code md-code-inline">state</code> turning off the <code class="md-code md-code-inline">wait</code> flag</li> <li>That component releases the lock</li> <li>Back to step 3</li> <li>Repeat until all components were rendered</li> </ol> <p>In order for the lock to work across different component instances, it needs to be shared somehow. We could just add the locking functionality to our module&#x2019;s top level, and then export the <code class="md-code md-code-inline">NonBlockingRenderLoop</code> class, but that would mean there could only ever be a single category of non-critical components. Instead, what we could do is export a factory function that returns different component classes. This way, when we need different groups of components to load in separate asynchronous sequences rather than being blocked on each other, we could just wrap each component in a <code class="md-code md-code-inline">NonBlockingRenderLoop</code>.</p> <p>Consider the following pure component, where we render an item list wrapped in a <code class="md-code md-code-inline">&lt;NonBlockingRenderLoop&gt;</code> component. We&#x2019;re creating a <code class="md-code md-code-inline">NonBlockingRenderLoop</code> class just for the list being rendered at <code class="md-code md-code-inline">renderItemList</code>. If the list is re-rendered, <code class="md-code md-code-inline">createNonBlockingRenderLoop</code> will hit the cache and avoid creating a different component class, which would&#x2019;ve resulted in remounting the entire tree, something we definitely want to avoid. A different portion of the application could just create a different NBRL, making any elements under that other component also load in an asynchronous sequence, but it&#x2019;d be a different asynchronous sequence.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> renderItemList = ({ id, items }) =&gt; {
  <span class="md-code-keyword">const</span> NonBlockingRenderLoop = createNonBlockingRenderLoop({
    key: `list-items-<span class="md-code-keyword">for</span>-${ id }`
  })
  <span class="md-code-keyword">return</span> items.map(item =&gt;
    <span><span class="md-code-tag">&lt;<span class="md-code-title">NonBlockingRenderLoop</span> <span class="md-code-attribute">key</span>=<span class="md-code-value">{</span> <span class="md-code-attribute">item.id</span> }&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">ListItem</span> <span class="md-code-attribute">item</span>=<span class="md-code-value">{</span> <span class="md-code-attribute">item</span> } /&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">NonBlockingRenderLoop</span>&gt;</span>
  )
}
</span></code></pre> <p>Going then to the implementation, let&#x2019;s start with the skeleton. Here we&#x2019;re just exporting the factory function, and returning a <code class="md-code md-code-inline">NonBlockingRenderLoop</code> that may or may not exist in the cache. We&#x2019;ll use a <code class="md-code md-code-inline">concurrencyLevel</code> instead of a boolean lock, so that the component could be used to create asynchronous render loops that are able to render more than a single elements at a time.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import Component from <span class="md-code-string">&apos;react&apos;</span>

<span class="md-code-keyword">const</span> cache = <span class="md-code-keyword">new</span> Map()

export <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createNonBlockingRenderLoop</span><span class="md-code-params">({ key, concurrencyLevel = 1 })</span> </span>{
  <span class="md-code-keyword">if</span> (cache.has(key)) {
    <span class="md-code-keyword">return</span> cache.get(key)
  }
  <span class="md-code-comment">// ...</span>
  cache.set(key, NonBlockingRenderLoop)
  <span class="md-code-keyword">return</span> NonBlockingRenderLoop
}
</code></pre> <p>Next up, we&#x2019;ll define a few functions that manage the lock slots. We start at <code class="md-code md-code-inline">concurrencyLevel</code> slots, which are taken by each component being rendered, and then released. We will consider the lock to be busy if there are no slots left.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">let</span> slots = concurrencyLevel
<span class="md-code-keyword">const</span> isBusy = () =&gt; slots &lt; <span class="md-code-number">1</span>
<span class="md-code-keyword">const</span> takeSlot = () =&gt; slots--
<span class="md-code-keyword">const</span> releaseSlot = () =&gt; slots++
</code></pre> <p>Next up is the <code class="md-code md-code-inline">NonBlockingRenderLoop</code> component. As we&#x2019;ve done earlier, it starts on a <code class="md-code md-code-inline">wait</code> state of <code class="md-code md-code-inline">true</code> and only renders its children when <code class="md-code md-code-inline">wait</code> is <code class="md-code md-code-inline">false</code>. Instead of using a timeout, though, it calls a method named <code class="md-code md-code-inline">enqueue</code> when it&#x2019;s mounted. The <code class="md-code md-code-inline">enqueue</code> method checks whether the lock is busy, in which case it uses <code class="md-code md-code-inline">requestAnimationFrame</code> to trigger another call to <code class="md-code md-code-inline">enqueue</code>. This loop goes on until a slot is released. When the lock is not busy, which is the starting state, we&#x2019;ll take a slot from the lock and defer with <code class="md-code md-code-inline">requestAnimationFrame</code>. Once the callback is executed we call <code class="md-code md-code-inline">setState</code> to turn <code class="md-code md-code-inline">wait</code> off, after which we release our lock on one of the slots. This process repeats itself until there&#x2019;s no more work left.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> NonBlockingRenderLoop extends Component {
  state = {
    wait: <span class="md-code-literal">true</span>
  }

  componentDidMount() {
    <span class="md-code-keyword">this</span>.enqueue()
  }

  componentWillUnmount() {
    <span class="md-code-keyword">this</span>.stop()
  }

  render() {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">this</span>.state.wait ? <span class="md-code-literal">null</span> : <span class="md-code-keyword">this</span>.props.children
  }

  enqueue() {
    <span class="md-code-keyword">if</span> (isBusy()) {
      <span class="md-code-keyword">this</span>.defer(() =&gt; <span class="md-code-keyword">this</span>.enqueue())
    } <span class="md-code-keyword">else</span> {
      takeSlot()
      <span class="md-code-keyword">this</span>.defer(() =&gt; <span class="md-code-keyword">this</span>.dequeue())
    }
  }

  dequeue() {
    <span class="md-code-keyword">this</span>.setState({ wait: <span class="md-code-literal">false</span> })
    releaseSlot()
  }

  defer(fn) {
    requestAnimationFrame(() =&gt; {
      <span class="md-code-keyword">if</span> (<span class="md-code-keyword">this</span>.defer !== noop) {
        fn()
      }
    })
  }

  stop() {
    <span class="md-code-keyword">this</span>.defer = noop
    <span class="md-code-keyword">if</span> (<span class="md-code-keyword">this</span>.state.wait) {
      releaseSlot()
    }
  }
}

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">noop</span> <span class="md-code-params">()</span> </span>{}
</code></pre> <p>Lastly, we have a sanity check at <code class="md-code md-code-inline">componentWillUnmount</code>, where we call the <code class="md-code md-code-inline">stop</code> method. This sets <code class="md-code md-code-inline">defer</code> to <code class="md-code md-code-inline">noop</code> and releases our lock on a slot if the component is still waiting to render. As an additional sanity check, we avoid executing the callback in the <code class="md-code md-code-inline">defer</code> method if the component has been unmounted since <code class="md-code md-code-inline">requestAnimationFrame</code> was called.</p> <p><em>You can find the <a href="https://gist.github.com/bevacqua/b7c481cc0bfb56320ac96c7f8c7cb0b6" target="_blank" rel="noopener noreferrer" aria-label="Full code for NonBlockingRenderLoop.js on gist.github.com">full source code on gist.github.com</a>.</em></p> <p>In the not-so-distant-future React&#x2019;s next-generation renderer &#x2013; Fiber &#x2013; will help with these kinds of scenarios by allowing us to determine the rendering priority of different portions of our applications. Improving performance in these kinds of React development scenarios is about to become way easier!</p> <p>Did React Fiber pique your interest? Here you go. Some of these are long reads <em>&#x2014; or presentations &#x2014;</em>, but they&#x2019;re well worth it. Take your time to dig through these links.</p> <ul> <li><a href="https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener noreferrer">React Components, Elements, and Instances</a></li> <li><a href="https://facebook.github.io/react/docs/reconciliation.html" target="_blank" rel="noopener noreferrer">Reconciliation in React</a></li> <li><a href="https://github.com/reactjs/react-basic" target="_blank" rel="noopener noreferrer">Basic React Theoretical Concepts</a></li> <li><a href="https://facebook.github.io/react/contributing/design-principles.html" target="_blank" rel="noopener noreferrer">React Design Principles</a></li> <li><a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener noreferrer">Fiber Principles</a></li> <li><a href="https://github.com/reactjs/react-future" target="_blank" rel="noopener noreferrer">Future and experimental React APIs</a></li> <li><a href="https://www.youtube.com/watch?v=d0pOgY8__JM" target="_blank" rel="noopener noreferrer">Evolving Complex Systems Incrementally</a> <strong><mark class="md-mark">Talk</mark></strong></li> <li><a href="https://www.youtube.com/watch?v=BF58ZJ1ZQxY" target="_blank" rel="noopener noreferrer">Don&#x2019;t Rewrite, React!</a> <strong><mark class="md-mark">Talk</mark></strong></li> <li><a href="http://isfiberreadyyet.com/" target="_blank" rel="noopener noreferrer">&#x201C;Is Fiber Ready Yet?&#x201D;</a></li> <li><a href="https://github.com/facebook/react/tree/master/src/renderers/shared/fiber" target="_blank" rel="noopener noreferrer">React Fiber Renderer Code</a></li> </ul> <p>By the way, if you got this far, you may be interested in the <a href="https://www.jsco.re/kcih" target="_blank" rel="noopener noreferrer" aria-label="Senior JavaScript Engineer, Cloud">remote senior JavaScript engineer position</a> at Elastic! We&#x2019;re always looking for smart and talented individuals like yourself.</p> <p>Ta! &#x1F389;</p></div>
