<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/binding-methods-to-class-instance-objects">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/binding-methods-to-class-instance-objects"><div><img src="https://i.imgur.com/mc5wsXD.jpg" alt="Binding Methods to Class Instance Objects"></div></a>

<h1>Binding Methods to Class Instance Objects</h1>

<p><kbd>javascript</kbd> <kbd>this</kbd> <kbd>semantics</kbd></p>

<blockquote><p>There&#x2019;s a number of different ways we can ensure class methods have access to <code>this</code>. After some controversy on Twitter last week, we quickly go over the most &#x2026;</p></blockquote>

<div><p>There&#x2019;s a number of different ways we can ensure class methods have access to <code class="md-code md-code-inline">this</code>. After some controversy on Twitter last week, we quickly go over the most common approaches, discussing their advantages and drawbacks.</p></div>

<blockquote></blockquote>

<div><p>The problem is when we have a class method such as the following.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Logger {
  printName (name = <span class="md-code-string">&apos;there&apos;</span>) {
    <span class="md-code-keyword">this</span>.print(`Hello ${name}`);
  }

  print (text) {
    <span class="md-code-built_in">console</span>.log(text); 
  }
}
</code></pre> <p>Then &#x2013; for whatever reason &#x2013; the <code class="md-code md-code-inline">printName</code> method&#x2019;s context changes, expectations aren&#x2019;t met, exceptions are thrown, and kittens die.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> logger = <span class="md-code-keyword">new</span> Logger();
<span class="md-code-keyword">const</span> { printName } = logger;
printName();
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">Uncaught TypeError: Cannot read property &apos;print&apos; of undefined</mark></span>
</code></pre> <p>Twitter drama began with Andr&#xE9;&#x2019;s salty remarks about a competing front-end framework.</p> <figure class="twitter-tweet-figure"><blockquote class="twitter-tweet"><p>constructor() {<br> this.onClick = this.onClick.bind(this);<br>}<br><br>Congrats, 3 this in 1 LOC, and it&apos;s not even app logic. Oh, it&apos;s official docs.</p>&#x2014; Andr&#xE9; Staltz (@andrestaltz) <a href="https://twitter.com/andrestaltz/status/768087662557274112">August 23, 2016</a></blockquote> </figure><p>The problem lies, of course, with the fact that JavaScript doesn&#x2019;t yet have semantics where we can easily mark every class method as bound to that class, which is how they probably should work.</p> <figure class="twitter-tweet-figure"><blockquote class="twitter-tweet"><p>&#x1F3C1; The reality is classes are in dire need for improvement<br>2&#xFE0F;&#x20E3; Usability via sensible defaults &#x2935;&#xFE0F;<br>&#x2611;&#xFE0F; Own scope<br>&#x2611;&#xFE0F; Methods bound to instance</p>&#x2014; Nicol&#xE1;s Bevacqua (@nzgb) <a href="https://twitter.com/nzgb/status/768152975676174336">August 23, 2016</a></blockquote> </figure><p>Let&#x2019;s look at our options.</p></div>

<div><h1 id="caveman-mode">Caveman Mode</h1> <p>In this scenario, we just bind methods by hand on the constructor.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Logger {
  constructor () {
    <span class="md-code-keyword">this</span>.printName = <span class="md-code-keyword">this</span>.printName.bind(<span class="md-code-keyword">this</span>);
  }

  printName (name = <span class="md-code-string">&apos;there&apos;</span>) {
    <span class="md-code-keyword">this</span>.print(`Hello ${name}`);
  }

  print (text) {
    <span class="md-code-built_in">console</span>.log(text); 
  }
}
</code></pre> <p>This is the least elegant solution, but it works. Drawbacks include having to keep track of which methods use <code class="md-code md-code-inline">this</code> and need to be bound, or ensuring every method is bound, remembering to <code class="md-code md-code-inline">.bind</code> new methods as they are added, and removing <code class="md-code md-code-inline">.bind</code> statements for methods that are removed. Benefits include being explicit, and having no extra code involved.</p> <h1 id="auto-bind">Auto Bind</h1> <p>A similar but less painful approach is using a module that takes care of this on our behalf. Sindre&#x2019;s <a href="https://github.com/sindresorhus/auto-bind" target="_blank" aria-label="sindresorhus/auto-bind on GitHub"><code class="md-code md-code-inline">auto-bind</code></a> goes through an object&#x2019;s methods and binds them to itself.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Logger {
  constructor () {
    autoBind(<span class="md-code-keyword">this</span>);
  }

  printName (name = <span class="md-code-string">&apos;there&apos;</span>) {
    <span class="md-code-keyword">this</span>.print(`Hello ${name}`);
  }

  print (text) {
    <span class="md-code-built_in">console</span>.log(text); 
  }
}
</code></pre> <p>This approach works well for classes, although we can&#x2019;t escape the need for a <code class="md-code md-code-inline">constructor</code>. The advantage is that we don&#x2019;t have to keep track of every single method by name when binding them. At the same time, if we&#x2019;re dealing with objects rather than classes, we need to ensure that <code class="md-code md-code-inline">autoBind</code> gets called on the object after every method has been assigned to the object, or else some methods will be left unbound. Any methods added after <code class="md-code md-code-inline">autoBind</code> gets called are unbound, and this means that in some situations <code class="md-code md-code-inline">autoBind</code> is an even worse option than manually calling <code class="md-code md-code-inline">.bind</code> on every method.</p> <h1 id="proxies">Proxies</h1> <p>A <a href="https://ponyfoo.com/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo"><code class="md-code md-code-inline">Proxy</code> object</a> could be used to intercept <code class="md-code md-code-inline">get</code> operations, returning methods bound to the <code class="md-code md-code-inline">logger</code>. Below we have a <code class="md-code md-code-inline">selfish</code> function which takes an object and returns a proxy for that object. Any methods accessed through the proxy will be automatically bound to the object. A <code class="md-code md-code-inline">WeakMap</code> is used to ensure we only bind the methods once, so that equality in <code class="md-code md-code-inline">proxy.fn === proxy.fn</code> is preserved.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">selfish</span> <span class="md-code-params">(target)</span> </span>{
  <span class="md-code-keyword">const</span> cache = <span class="md-code-keyword">new</span> WeakMap();
  <span class="md-code-keyword">const</span> handler = {
    get (target, key) {
      <span class="md-code-keyword">const</span> value = Reflect.get(target, key);
      <span class="md-code-keyword">if</span> (<span class="md-code-keyword">typeof</span> value !== <span class="md-code-string">&apos;function&apos;</span>) {
        <span class="md-code-keyword">return</span> value;
      }
      <span class="md-code-keyword">if</span> (!cache.has(value)) {
        cache.set(value, value.bind(target));
      }
      <span class="md-code-keyword">return</span> cache.get(value);
    }
  };
  <span class="md-code-keyword">const</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler);
  <span class="md-code-keyword">return</span> proxy;
}
<span class="md-code-keyword">const</span> logger = selfish(<span class="md-code-keyword">new</span> Logger());
</code></pre> <p>The benefit of taking this approach is that methods on the <code class="md-code md-code-inline">target</code> object will be bound regardless of whether they were added before or after the proxy object was created. The obvious drawback is that <code class="md-code md-code-inline">Proxy</code> support is meager even when transpilers are taken into account.</p> <p>Even if proxies were generally available, this solution would also be far from ideal. The difference lies in that libraries could potentially implement something like <code class="md-code md-code-inline">selfish</code> so that components you hand over to the library would follow these semantics without you having to do anything. That said, the only real solution lies in the language moving forward, adding semantics for classes that have every method bound to itself by default.</p> <p>We&#x2019;re definitely better off than back when we had to write <code class="md-code md-code-inline">Logger.prototype.print</code> <em>&#x2013; an implementation detail artifact that never made a lot of sense &#x2013;</em> and classes are a result of observing a pattern that was being repeated consistently, over time, and developing a solution. A private scope for classes where you can declare functions scoped to that class that aren&#x2019;t class methods <em>(but are available to every method)</em> and other variables scoped to the class would be a huge step forward for classes.</p> <p>Having bind semantics that are a bit less verbose, tedious, error-prone, or complicated, is mostly a matter of time. And when it comes to JavaScript, we all know that time flows faster. &#x23F3;</p> <blockquote> <p>What&#x2019;s your preferred way of ensuring methods are bound to their host object? What native JavaScript semantics would you propose for objects where every method is bound to their host?</p> </blockquote></div>
