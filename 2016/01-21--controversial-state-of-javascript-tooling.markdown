<h1>The Controversial State of JavaScript Tooling</h1>

<div><kbd>state-of-the-web</kbd> <kbd>hypermodularity</kbd></div>

<blockquote><p>There have been many different blog posts on the <em>&#x201C;State of the Web&#x201D;</em>, problems people face around tooling, and similar-style musings of late. This article &#x2026;</p></blockquote>

<div><p>There have been many different blog posts on the <em>&#x201C;State of the Web&#x201D;</em>, problems people face around tooling, and similar-style musings of late. This article is about summarizing my thoughts on recent events. Rather than yet another rant about the state of web development, this piece aims to pour some thought into what we can do to fix the situation we find ourselves in.</p></div>

<div></div>

<div><p>Remy Sharp wrote <a href="https://remysharp.com/2016/01/20/why-i-love-working-with-the-web" target="_blank" aria-label="Why I love working with the web">an excellent piece</a> recently about his love for the web. It immediately stuck with me &#x2013; and many others, I imagine &#x2013; because of how close to home it hit. He wasn&#x2019;t the only one to publish his thoughts recently, though.</p> <p>Unfortunately, the spirit and praise of the web in Remy&#x2019;s post isn&#x2019;t shared by many of these articles. To the contrary, the web development community is flooding in skepticism, negativity, and pessimism.</p> <blockquote> <p><strong>The web community is as opinionated as it is large.</strong></p> </blockquote> <p>These days however we don&#x2019;t see as much constructive thinking as we see <a href="https://medium.com/@MikeRyan52/angular-2-first-app-post-mortem-b2b2b3618828" target="_blank" aria-label="Angular 2 First App Post-Mortem">articles about Angular 2 being too complex</a>, React being &#x201C;bad&#x201D;, Babel <em>(or even worse, their maintainers)</em> &#x2026; &#x2013; just about anything that&#x2019;s popular within the community is wide open for criticism. When it comes to providing constructive criticism, though, we&#x2019;re sorely lacking.</p> <p>The problems, however, are real. By the end of 2015 many &#x2013; myself included &#x2013; agreed that one of the hardest problem the front-end community faces right now is tooling consolidation. That is, arriving at easier-to-use tools <strong>without</strong> sacrificing firepower.</p> <blockquote class="twitter-tweet"><p>JavaScript community made some great improvements in 2015, but we need to consolidate tooling in 2016. <a href="https://t.co/HGrLjiSQhb">https://t.co/HGrLjiSQhb</a></p>&#x2014; Nicol&#xE1;s Bevacqua (@nzgb) <a href="https://twitter.com/nzgb/status/685475705149329408">January 8, 2016</a></blockquote> <p>Earlier this month, there was a Medium rant making the rounds about how <strong>using a sledgehammer to crack a nut</strong> has become a difficult chore, basically repeating the premise of <a href="https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4" target="_blank" aria-label="Javascript Fatigue on Medium">an older Medium article</a> but dropping the constructive bits <em>(and personally attacking Babel authors &#x2013; which is why I refuse to link to it)</em>. Around the same time, hundreds of open-source advocates signed a <a href="https://github.com/dear-github/dear-github" target="_blank" aria-label="dear-github/dear-github on GitHub">petition to GitHub</a> asking for better workflows in large open-source projects. There have also been responses to &#x201C;Dear GitHub&#x201D;, <a href="http://www.juliandunn.net/2016/01/14/dear-dear-github-from-your-local-friendly-product-person/" target="_blank" aria-label="Dear &apos;Dear GitHub&apos;">Dear &#x201C;Dear GitHub&#x201D;</a>, and so on. You get the point. <em>People like to complain about things.</em></p> <p><img src="https://i.imgur.com/jjuLwGm.jpg" alt="Cracking a nut with a sledgehammer"></p> <p>In this article I hope to look into the negativity rabbit hole, see how deep it gets, while asking ourselves how the hell we got into this mess <strong>&#x2013; and more importantly how we could fix it.</strong></p></div>

<div><h1 id="a-hard-place">A Hard Place</h1> <p>The front-end development community as a whole has put itself in a <mark class="md-mark">hard place</mark>. We&#x2019;ve collectively overlooked issues that arise from using tons of purpose-specific tools, <strong>and for good reason</strong>. Other languages and ecosystems are victims of all-encompassing standard libraries, but the web development community takes pride in <strong>not having</strong> that problem. In the past we fell prey to large utility libraries that did just about anything <em>&#x2013; your jQuery, Underscore, etc.</em></p> <p>Large libraries had their benefits &#x2013; as well as their drawbacks. It was nice being able to drop-in jQuery, do &#x201C;all the things&#x201D;, and forget about it. As applications grew in size and complexity, <em>though</em>, we couldn&#x2019;t just drop any libraries we found on the Internet in our codebases anymore. That&#x2019;d result in <strong>much-larger-than-necessary</strong> websites, something we didn&#x2019;t want. Thus, over time, the community understood how we could benefit from smaller modules, and started working on micro libraries <em>&#x2013; at a time where most &#x201C;libraries&#x201D; were developed as jQuery plugins</em>. Along came Node.js, and its small modules philosophy turned many of us into firm believers that, <strong>indeed</strong>, writing small modules is the way to go.</p> <p>Followers of the small module movement started breaking down libraries they built into components. Out came a more modular approach to popular libraries like jQuery and Lodash. True, jQuery had been &#x201C;modular&#x201D; for a long time, but the approach they took didn&#x2019;t lend itself to adoption: it relied on consumers utilizing complicated online build tooling where you had to pick what parts of jQuery your application was going to utilize <strong><em>&#x2013; in advance</em></strong>. Great in theory, and they certainly could boast about being modular, but not the most user-friendly approach.</p> <blockquote> <p>In practice, consumers either used the raw, full jQuery library, or <em>&#x2013; at best &#x2013;</em> they took out a few highly irrelevant parts and called it a day. jQuery UI was in a similar place, but had an even weaker position due to the fact that it also depended in jQuery.</p> <p>When Bower came along, <em>&#x2013; it took a while before jQuery was mirrored onto <code class="md-code md-code-inline">npm</code> as well &#x2013;</em> it became even more obvious that the <strong>custom build wasn&#x2019;t a serious option</strong>, as you&#x2019;d have to jump through a considerable number of hoops before you could even arrive at a custom bundle.</p> </blockquote> <p>Lodash took a different path, which favored adoption even though their approach was detrimental to their own build processes <em>(but not their consumers)</em>. Starting with v2, they published hundreds of modules to <code class="md-code md-code-inline">npm</code> &#x2013; <code class="md-code md-code-inline">lodash.find</code>, <code class="md-code md-code-inline">lodash.flatten</code>, etc. &#x2013; where each module represented <strong>one</strong> of the utility functions in Lodash. Later on, starting in v3, they improved upon that and allowed you to pull specific functions as CommonJS modules like <code class="md-code md-code-inline">require(&apos;lodash/function/bind&apos;)</code>. Even though there&#x2019;s a tree composed of hundreds of small modules in the Lodash codebase, they&#x2019;re still available as a single package on npm. <strong>That is a good thing.</strong></p> <h1 id="hypermodularization">Hypermodularization</h1> <p>Around the same time came <strong>hypermodularization</strong>. This is basically the same, in principle, as <code class="md-code md-code-inline">lodash</code> splitting their functionality in hundreds of small modules, bits and pieces of documentation and tests, and <code class="md-code md-code-inline">npm</code> packages. A major difference in an hypermodularized scenario is that you don&#x2019;t see comprehensive distributions anymore. One such example is the original <code class="md-code md-code-inline">lodash</code> package itself, which to this day contains the whole of their utility functions, even though they&#x2019;re now also available as individual pieces. When it comes to <code class="md-code md-code-inline">lodash</code>, you can take the whole thing or a method at a time.</p> <p>For library authors, hypermodularization makes a lot of sense, as it comes with <strong>a wealth of benefits</strong>.</p> <ul> <li>You only take what you need</li> <li>Reuse functionality across several packages</li> <li>Semantic versioning on individual modules <em>&#x2013; not just for packages as a whole</em></li> <li>Extended documentation and front-facing API surface tests</li> <li>Less friction integrating server-side modules in client-side applications</li> </ul> <p>The problem with hypermodularization, though, is that <strong>adoption becomes trickier</strong>. Undoubtedly, people will immediately point at small modules as the culprit. <em>&#x201C;Too many API touchpoints&#x201D;</em> &#x2013; some say. <em>&#x201C;Too much plumbing&#x201D;</em> &#x2013; others point out. Some might even say that larger bundles of things were better, as you didn&#x2019;t have to spend time forming an opinion as to how half a dozen modules should be plumbed together, or dealing with boilerplate generators such as <code class="md-code md-code-inline">yeoman</code> <em>(another non-solution &#x2013; <strong>code generators are hardly ever the answer</strong>)</em>.</p> <p>When I <a href="http://www.2ality.com/2015/12/webpack-tree-shaking.html" target="_blank" aria-label="Tree-shaking with webpack 2 and Babel 6 on 2ality.com">first ran into tree-shaking</a> I quickly dismissed it as <strong>a nice to have</strong> that would prove hardly more beneficial than <a href="https://github.com/substack/bundle-collapser" target="_blank" aria-label="substack/bundle-collapser on GitHub"><code class="md-code md-code-inline">bundle-collapser</code></a>, which allows you to save a few hundred bytes in bulky <code class="md-code md-code-inline">browserify</code> bundles. Nice &#x2013; sure. Necessary? <em>Hardly.</em> Or that&#x2019;s what I thought.</p> <h1 id="tree-shaking-is-a-game-breaker">Tree-shaking is a game breaker</h1> <p>At the time, I misunderstood its use cases. Tree-shaking is a feature available in modern module bundlers <em>&#x2013; <a href="https://github.com/rollup/rollup" target="_blank" aria-label="rollup/rollup on GitHub"><code class="md-code md-code-inline">rollup</code></a>, namely &#x2013;</em> where ES6 modules are statically analyzed for exports that are being used, and those that are not become left out of the resulting bundle.</p> <p>Suppose we had the following piece of code:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import _ from <span class="md-code-string">&apos;lodash&apos;</span>;
_.keys({ pony: <span class="md-code-string">&apos;foo&apos;</span> });
</code></pre> <p>How cool would it be if a compiler would turn that into something like this?</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> _ = {
  keys: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(o)</span> </span>{
    <span class="md-code-keyword">return</span> <span class="md-code-built_in">Object</span>.keys(o);
  }
};
_.keys({ pony: <span class="md-code-string">&apos;foo&apos;</span> });
</code></pre> <blockquote> <p><sub>Disclaimer: Actual <code class="md-code md-code-inline">lodash</code> code is <a href="https://github.com/lodash/lodash/blob/6889837d2d3f506ef36fd5cf7368b0ad70c7431f/lodash.js#L11122-L11140" target="_blank" aria-label="_.keys method in the lodash codebase">not as contrived</a>, this is merely an illustration.</sub></p> </blockquote> <p>I had hoped <code class="md-code md-code-inline">rollup</code> would do that, but it interprets <code class="md-code md-code-inline">lodash</code> as an external dependency, presumably because its written under ES5, or maybe just because the package is in <code class="md-code md-code-inline">node_modules</code>. Nevertheless, if we were able to take code like the previous snippet and turn it into the second &#x2013; smaller &#x2013; one, we&#x2019;d <strong>eliminate one of the biggest drawbacks of large distributions</strong> such as the <code class="md-code md-code-inline">lodash</code> package and similar utility libraries: <strong>people</strong>.</p> <p>People take libraries like <code class="md-code md-code-inline">lodash</code> <em>&#x2013; or jQuery, as we analyzed earlier &#x2013;</em> and insert the whole thing into their codebases. If a simple bundler plugin could deal with getting rid of everything in <code class="md-code md-code-inline">lodash</code> they aren&#x2019;t using, footprint is <strong>one less thing we&#x2019;d have to worry about</strong>.</p> <p>The other set of drawbacks in large distributions can&#x2019;t be solved by consumers, and should be resolved by implementers instead. Incidentally, these things are already solved by hypermodularization: <strong>maintability, documentation, ease of contribution, etc.</strong> As modules get smaller, they also become easier to maintain, document, test, and contribute to, lowering the barrier of entry. A large monolith on the other hand usually involves some sort of learning curve, makes people scared of breaking undocumented functionality, and so on.</p> <p>One drawback when it comes to code contributions and support requests <em>&#x2013; however (and amusingly) &#x2013;</em> is that maintaining an hypermodularized ecosystem is a hassle when they are highly related and kept in several different repositories. Babel has <em>an excellent document</em> that outlines <a href="https://github.com/babel/babel/blob/master/doc/design/monorepo.md" target="_blank" aria-label="Why is Babel a monorepo?">their <strong><mark class="md-mark">monorepo</mark> culture</strong></a> and how it has allowed them to contain issues arising from dealing with support requests against their many hypermodular, interconnected components.</p> <h1 id="consolidating-opinions">Consolidating Opinions</h1> <p>In a hypermodular ecosystem, it becomes increasingly hard to plumb pieces of code together. In a monolithic ecosystem, it becomes increasingly annoying to deal with large chunks of code that you don&#x2019;t need. <em>We need to consolidate the two.</em></p> <p><strong>I believe in hypermodular components</strong>. They are great at what they do, they follow the <em>&#x201C;do one specific thing very well&#x201D;</em> philosophy and are primed to thrive in an open-source community such as ours.</p> <p><strong>I never much liked</strong> comprehensive libraries like jQuery in terms of API surface, but a lot of that dislike <em>goes away</em> when a tool such as tree-shaking is effectively applied across the board.</p> <p>Moreover, when we take a look at application logic that is mostly concerned with plumbing discrete libraries in the application level, we begin to see how hypermodular components should be packaged in larger distributions. In one of the opening lines in this article I stated that <em>&#x201C;the web community is as opinionated as it is large&#x201D;</em>. I opine <strong>we need to become more opinionated</strong> as far as library authorship goes.</p> <p><a href="https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4" target="_blank" aria-label="Javascript Fatigue on Medium"><img alt="Screenshot showing code plumbing hypermodular libraries at the application level" class="" src="https://i.imgur.com/4ArrsqC.png"></a></p> <p><sub><em>One such example of plumbing at the application level, extracted from <a href="https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4" target="_blank" aria-label="Javascript Fatigue on Medium">a Medium article</a>.</em></sub></p> <p>Not only would we be getting rid of obnoxious plumbing, but we&#x2019;d also steer more users towards best practices, we&#x2019;d spend less time arguing about what approach is correct, and we&#x2019;d spend more time being productive in day-to-day development. While flexibility and hyper-modularity are great features, compromising on a set of opinions and reducing noise at the implementation level are similarly honorable objectives to arrive at.</p> <p>Nothing is to prevent us from keeping the lower-levels of our architectures hypermodularized. This is all good and well &#x2013; it is one of the fundamental pillars of modern JavaScript development. It is also true that the crux of our problems today stem not from one library or another being hypermodular, but from the ecosystem as a whole being developed this way.</p> <blockquote> <p>In that sense, <strong>we needn&#x2019;t cry</strong> about <code class="md-code md-code-inline">babel@6</code> asking us to install a couple more packages. If you dislike doing that every time, build a wrapper around it with some opinions on top. Do the same for React packages you use and are tired of plumbing over and over in all your applications. Avoid generators with a passion, but <strong>opinionate your way through the ocean of hypermodules</strong> we find ourselves swimming around in.</p> </blockquote> <p>Write wrappers and intermediate libraries that live outside of your application core while consuming hypermodules. Keep your opinions to those intermediate libraries, while keeping hypermodules discrete. In this sense, you could think of an hypermodule as <code class="md-code md-code-inline">lodash/function/bind</code> and an intermediate library as <code class="md-code md-code-inline">lodash</code>. I use <code class="md-code md-code-inline">lodash</code> as an example because it&#x2019;s one of the best representations out there today of what constitutes an hypermodular library. One that has hundreds of components, but <strong>opinions are not one of them</strong>.</p> <p>An ecosystem that&#x2019;s founded on intermediate libraries on top of hypermodules could fare much better. The bulk of implementation, testing, and documentation would fall in hypermodules, while opinions and plumbing could be kept in an intermediate layer we are only just yet starting to even consider. Presumably, code in the intermediate layer could be bulkier, but that should be something that <em>&#x2013; with proper and better tooling &#x2013;</em> a feature like tree-shaking could take care of.</p></div>
