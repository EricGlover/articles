<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/weakref">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/weakref"><div><img src="https://i.imgur.com/gaku2qj.jpg" alt="JavaScript Proposal for weak references: WeakRef"></div></a>

<h1>JavaScript Proposal for weak references: <code class="md-code md-code-inline">WeakRef</code></h1>

<p><kbd>ecmascript</kbd> <kbd>weakref</kbd> <kbd>proposal-draft</kbd></p>

<blockquote><p>A proposal to implement weak references in JavaScript <em>&#x2013; which would expose weak references made possible by <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth"><code>WeakMap</code> and <code>WeakSet</code></a> &#x2013;</em> is currently sitting at <em>stage 0</em>.</p>
</blockquote>

<div><p>A proposal to implement weak references in JavaScript <em>&#x2013; which would expose weak references made possible by <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth"><code class="md-code md-code-inline">WeakMap</code> and <code class="md-code md-code-inline">WeakSet</code></a> &#x2013;</em> is currently sitting at <em>stage 0</em>.</p></div>

<blockquote></blockquote>

<div><p>Time for another ECMAScript proposal draft. This time we&#x2019;ll discuss <code class="md-code md-code-inline">WeakRef</code>. Weak references had their first &#x2013; indirect &#x2013; appearance in ES6, with the arrival of <a href="https://github.com/tc39/proposal-weakrefs/blob/3f0eb80e9fd67ccd1f284ff467e852fb69a364a1/specs/weakrefs.md" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">WeakMap</code> and <code class="md-code md-code-inline">WeakSet</code></a>.</p></div>

<div><p>The <a href="#background">Background</a> and <a href="#intended-audience">Intended Audience</a> sections, found below, contain good indicators of why the proposal was put forward, as well as the intended audience. They were extracted from the proposal&#x2019;s repository. Afterwards we&#x2019;ll move onto use cases and its API.</p> <h1 id="background">Background</h1> <p>In a simple garbage-collected language, memory is a graph of references between objects, anchored in the roots such as global data structures and the program stack. The garbage collector may reclaim any object that is not reachable through that graph from the roots. Some patterns of computation that are important to JavaScript community are difficult to implement in this simple model because their straightforward implementation causes no-longer used objects to still be reachable. This results in storage leaks or requires difficult manual cycle breaking. Examples include:</p> <ul> <li>MVC and data binding frameworks</li> <li>Reactive-style libraries and languages that compile to JS</li> <li>Caches that require cleanup after keys are no longer referenced</li> <li>Proxies/stubs for comm or object persistence frameworks</li> <li>Objects implemented using external or manually-managed resources</li> </ul> <p>Two related enhancements to the language runtime will enable programmers to implement these patterns of computation: weak references and finalization.</p> <blockquote> <p>A <em>strong reference</em> is a reference that causes an object to be retained; in the simple model all references are strong. A <em>weak reference</em> is a reference that allows access to an object that has not yet been garbage collected, but does not prevent that object from being garbage collected. <em>Finalization</em> is the execution of code to clean up after an object that has become unreachable to program execution.</p> </blockquote> <p>For example, MVC frameworks often use an observer pattern: the view points at the model, and also registers as an observer of the model. If the view is no longer referenced from the view hierarchy, it should be reclaimable. However in the observer pattern, the model points at its observers, so the model retains the view (even though the view is no longer displayed). By having the model point at its observers using a weak reference, the view can just be garbage collected normally with no complicated reference management code.</p> <p>Similarly, a graphics widget might have a reference to a primitive external bitmap resource that requires manual cleanup (e.g., it must be returned to a buffer pool when done). With finalization, code can cleanup the bitmap resource when the graphics widget is reclaimed, avoiding the need for pervasive manual disposal discipline across the widget library.</p> <h1 id="intended-audience">Intended Audience</h1> <p>The garbage collection challenges addressed here largely arise in the implementation of libraries and frameworks. The features proposed here are advanced features (e.g., like proxies) that are <strong>primarily intended for use by library and framework creators</strong>, not their clients.</p> <blockquote> <p>Thus, the priority is enabling library implementors to correctly, efficiently, and securely manage object lifetimes and finalization.</p> </blockquote> <h1 id="the-api-for-weak-references">The API for weak references</h1> <p>When using strongly-held references, cutting off one of them doesn&#x2019;t affect other references.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> a, b;
a = b = <span class="md-code-built_in">document</span>.querySelector(<span class="md-code-string">&apos;.ponyfoo&apos;</span>)
a = <span class="md-code-literal">undefined</span>
<span class="md-code-comment">// ... a GC pause later ...</span>
<span class="md-code-comment">// b still references the DOM element</span>
</code></pre> <p>In the diagram below <em>&#x2013; also retrieved from the proposal&#x2019;s repository &#x2013;</em> the target object is the DOM element itself, while the <em>Client</em> and <em>Service Object</em> are references to it. Here, the case is being made for the use case where we have a core &#x201C;Client&#x201D; component <em>(such as the DOM element)</em> and one or many &#x201C;Service Object&#x201D; components that are only necessary as long as the DOM element is being referenced.</p> <figure><img alt="Diagram without using WeakRef" class="" src="https://i.imgur.com/ly0xhbt.png"></figure> <p>In the situation we&#x2019;ve just described, we&#x2019;d have to dereference <code class="md-code md-code-inline">b</code> whenever we dereference <code class="md-code md-code-inline">a</code>. In particular, we&#x2019;d have to keep track of reference counting ourselves, so that we know when the DOM element is no longer being referenced by a relevant party, and then we can dereference the element in _&#x201C;secondary&#x201D; <em>&#x2013; that is, &#x201C;Service&#x201D; &#x2013;</em> references to it.</p> <p>Under this proposal, there&#x2019;s a <code class="md-code md-code-inline">makeWeakRef</code> global function and a <code class="md-code md-code-inline">WeakRef</code> built-in class. Using <code class="md-code md-code-inline">makeWeakRef</code> returns a <code class="md-code md-code-inline">WeakRef</code> object that&#x2019;s pointed at <code class="md-code md-code-inline">target</code>. If <code class="md-code md-code-inline">target</code> is no longer referenced, then the <code class="md-code md-code-inline">WeakRef</code> object will stop pointing at it after a full garbage collector sweep.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">makeWeakRef(target, executor?, holdings?)
</code></pre> <p>The parameters to <code class="md-code md-code-inline">makeWeakRef</code> are as follows:</p> <ul> <li><code class="md-code md-code-inline">target</code> is the object we wish to create a weak reference to</li> <li><code class="md-code md-code-inline">executor</code> is an optional argument that can be used as a <em>finalization callback</em></li> <li><code class="md-code md-code-inline">holdings</code> is an optional argument provided to <code class="md-code md-code-inline">executor</code> when it&#x2019;s invoked for <code class="md-code md-code-inline">target</code></li> </ul> <p>We could create a new <code class="md-code md-code-inline">WeakRef</code> using <code class="md-code md-code-inline">makeWeakRef</code>, as shown below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = <span class="md-code-built_in">document</span>.querySelector(<span class="md-code-string">&apos;.ponyfoo&apos;</span>)
<span class="md-code-keyword">var</span> weakRef = makeWeakRef(target)
</code></pre> <p>The <code class="md-code md-code-inline">WeakRef</code> object has two methods. There&#x2019;s <code class="md-code md-code-inline">get()</code>, which retrieves the weakly held <code class="md-code md-code-inline">target</code> object reference or <code class="md-code md-code-inline">null</code> if the object has been garbage collected away. Then there&#x2019;s <code class="md-code md-code-inline">.clear()</code> which nulls out the underlying weak reference <em>while preventing the <code class="md-code md-code-inline">executor</code> from being invoked</em>, without the need for a full GC sweep.</p> <p>The following diagram shows how <code class="md-code md-code-inline">WeakRef</code> can act as an intermediary that deals with reference counting of strongly held references and retrieval of a weakly held reference on our behalf.</p> <figure><img alt="Diagram when using WeakRef" class="" src="https://i.imgur.com/PUv49zn.png"></figure> <p>While there&#x2019;s at least one non-weak reference to the DOM element matching <code class="md-code md-code-inline">.ponyfoo</code>, <code class="md-code md-code-inline">weakRef.get()</code> target will return the element. In our case, this means we&#x2019;ll be able to retrieve the weakly held reference to the DOM element for as long as the <code class="md-code md-code-inline">target</code> variable is pointing at it.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">weakRef.get() === <mark class="md-mark md-code-mark">target</mark>
</code></pre> <p>If we de-referenced <code class="md-code md-code-inline">target</code>, the <code class="md-code md-code-inline">WeakRef</code> interface can no longer guarantee that it&#x2019;ll return the DOM element. After a full GC sweep and finalization, <code class="md-code md-code-inline">weakRef.get</code> will start to return <code class="md-code md-code-inline">null</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">target = <span class="md-code-literal">undefined</span> <span class="md-code-comment">// de-reference <mark class="md-mark md-code-mark">target</mark></span>
<span class="md-code-comment">// after a full GC, weakRef no longer points at <mark class="md-mark md-code-mark">target</mark></span>
weakRef.get() === <mark class="md-mark md-code-mark">null</mark>
</code></pre> <p>Instead of waiting for a GC sweep you could alternatively call <code class="md-code md-code-inline">weakRef.clear</code> to break the weakly held reference. In that case, <code class="md-code md-code-inline">weakRef.get</code> would immediately begin to return <code class="md-code md-code-inline">null</code>.</p> <h1 id="use-cases">Use Cases</h1> <p>Whenever you previously wanted to use a <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth"><code class="md-code md-code-inline">WeakMap</code></a> just so you could map a DOM element to an object that provided extra features related to it, you could now use <code class="md-code md-code-inline">WeakRef</code>. Similarly, in every case where you want to provide extra features around an object you don&#x2019;t have control over, a <code class="md-code md-code-inline">WeakRef</code> is a great way to do so without holding onto it with a strongly-held reference that prevents it from being garbage collected. Something that, under certain circumstances, could end up in a <strong>hard-to-detect memory leak</strong> situation.</p></div>
