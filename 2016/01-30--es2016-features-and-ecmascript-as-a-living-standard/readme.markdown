<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/es2016-features-and-ecmascript-as-a-living-standard">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/es2016-features-and-ecmascript-as-a-living-standard"><div><img src="https://i.imgur.com/o8Iibqx.jpg" alt="ES2016 Features &amp; ECMAScript as a Living Standard"></div></a>

<h1>ES2016 Features &amp; ECMAScript as a Living Standard</h1>

<p><kbd>es2016</kbd> <kbd>standards</kbd> <kbd>ecmascript</kbd></p>

<blockquote><p>As it turns out, ES2016 <em>&#x2013; also known colloquially as ES7 &#x2013;</em> will be comprised of a very small feature set. This article explains the new features in ES2016.</p><p>&#x2026;</p></blockquote>

<div><p>As it turns out, ES2016 <em>&#x2013; also known colloquially as ES7 &#x2013;</em> will be comprised of a very small feature set. This article explains the new features in ES2016.</p></div>

<blockquote></blockquote>

<div><p>ECMAScript editor <a href="https://twitter.com/bterlson" target="_blank" rel="noopener noreferrer" aria-label="@bterlson on Twitter">@bterlson</a> reported last week that features in stage 4 were going to make it into ES2016, and there were just two features in that state. You can check out the <a href="https://github.com/tc39/ecma262/blob/master/README.md" target="_blank" rel="noopener noreferrer" aria-label="tc39/ecma262 on GitHub">current state of all ECMAScript proposals</a> on GitHub.</p> <figure class="twitter-tweet-figure"><blockquote class="twitter-tweet"><p><a href="https://twitter.com/rauschma">@rauschma</a> Any that are stage 4 by Thursday will make it in, yes.</p>&#x2014; Brian Terlson (@bterlson) <a href="https://twitter.com/bterlson/status/692427832555892736">January 27, 2016</a></blockquote> </figure><p>The features in question are <code class="md-code md-code-inline">Array.prototype.includes</code> and the exponentiation operator. We&#x2019;ll go over both of them explaining what they do and looking at a couple of examples &#x2013; note that these are very simple features, so we&#x2019;ll keep it short!</p> <p>Lastly, we&#x2019;ll talk a little bit about where ES6 is going in the future. Shall we?</p></div>

<div><h1 id="arrayprototypeincludes"><code class="md-code md-code-inline">Array.prototype.includes</code></h1> <p>Originally, this method was going to be named <code class="md-code md-code-inline">Array.prototype.contains</code>, but that <a href="https://github.com/tc39/Array.prototype.includes/tree/b6671aec098db241ab2d27d7bc182cc8a074edef" target="_blank" rel="noopener noreferrer" aria-label="tc39/Array.prototype.includes on GitHub">would&#x2019;ve proven problematic</a> as it would&#x2019;ve clashed with popular library <code class="md-code md-code-inline">MooTools</code> &#x2013; whose implementation was incompatible with ECMA&#x2019;s, potentially resulting in many broken websites once the feature was implemented according to the standard.</p> <blockquote> <p>This proposal was formerly for <code class="md-code md-code-inline">Array.prototype.contains</code>, but that name <a href="http://esdiscuss.org/topic/having-a-non-enumerable-array-prototype-contains-may-not-be-web-compatible" target="_blank" rel="noopener noreferrer" aria-label="Having a non-enumerable Array.prototype.contains may not be web-compatible">is not web-compatible</a>. Per the November 2014 TC39 meeting, the name of both <code class="md-code md-code-inline">String.prototype.contains</code> and <code class="md-code md-code-inline">Array.prototype.contains</code> was changed to <code class="md-code md-code-inline">includes</code> to dodge that bullet.</p> </blockquote> <p>The <code class="md-code md-code-inline">.includes</code> method returns whether the provided reference value is included in the array or not.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-string">&apos;a&apos;</span>, <span class="md-code-string">&apos;b&apos;</span>, <span class="md-code-string">&apos;c&apos;</span>].includes(<span class="md-code-string">&apos;c&apos;</span>);
<span class="md-code-comment">// &lt;- true</span>
[{}, {}].includes({}); <span class="md-code-comment">// strictly a reference comparison</span>
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-keyword">var</span> a = {};
[{}, a].includes(a);
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>You can also specify a <code class="md-code md-code-inline">fromIndex</code> as the second parameter, and the search will start at that position in the array. When this value isn&#x2019;t provided, <code class="md-code md-code-inline">0</code> is assumed and the whole array is searched.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-string">&apos;a&apos;</span>, <span class="md-code-string">&apos;b&apos;</span>, <span class="md-code-string">&apos;c&apos;</span>, <span class="md-code-string">&apos;d&apos;</span>].includes(<span class="md-code-string">&apos;b&apos;</span><mark class="md-mark md-code-mark">, <span class="md-code-number">2</span></mark>);
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>Even though <code class="md-code md-code-inline">NaN !== NaN</code>, <code class="md-code md-code-inline">.includes</code> uses the <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero" target="_blank" rel="noopener noreferrer" aria-label="SameValueZero algorithm in ECMAScript specification"><code class="md-code md-code-inline">SameValueZero</code> comparison algorithm</a> where <code class="md-code md-code-inline">NaN</code> is equivalent to itself.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-literal">NaN</span>].includes(<span class="md-code-literal">NaN</span>);
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>There isn&#x2019;t much else to say about this method.</p> <h1 id="exponentiation-operator">Exponentiation operator &#x2013; <code class="md-code md-code-inline">**</code></h1> <p>The exponentiation operator &#x2013; or <code class="md-code md-code-inline">a ** b</code> &#x2013; is the syntactic equivalent to doing <code class="md-code md-code-inline">Math.pow(a, b)</code>. It&#x2019;ll work similarly to the <a href="http://www.pythonforbeginners.com/basics/python-operators" target="_blank" rel="noopener noreferrer" aria-label="Python Operators &#x2013; Python for Beginners">exponentiation operator in Python</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-number">1</span> ** <span class="md-code-number">2</span> === <span class="md-code-built_in">Math</span>.pow(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Just like with any other operators, it&#x2019;s possible to mix exponentiation with assignment, as show below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> a = <span class="md-code-number">2</span>;
a **= <span class="md-code-number">3</span>; <span class="md-code-comment">// equivalent to <mark class="md-mark md-code-mark">a = Math.pow(a, 3)</mark></span>
<span class="md-code-built_in">console</span>.log(a);
<span class="md-code-comment">// &lt;- 8</span>
</code></pre> <h1 id="ecmascript-as-a-living-standard">ECMAScript as a Living Standard</h1> <p>In an article shared this weekend, Axel Rauschmayer has detailed <a href="http://www.2ality.com/2016/01/ecmascript-2016.html" target="_blank" rel="noopener noreferrer" aria-label="The final feature set of ECMAScript 2016 (ES7) on 2ality.com">how the ECMAScript release process will work</a> from now on. In this sense, the ECMAScript standarization process will behave more like HTML and CSS ones, where new features are standarized as consensus is reached, rather than clean-cut <em>&#x2013; or &#x201C;limited by&#x201D; &#x2013;</em> by version numbers.</p> <figure class="twitter-tweet-figure"><blockquote class="twitter-tweet"><p><a href="https://twitter.com/nzgb">@nzgb</a> <a href="https://twitter.com/rauschma">@rauschma</a> Apparently. The Epoch of Unversioned Web.</p>&#x2014; Ingvar Stepanyan (@RReverser) <a href="https://twitter.com/RReverser/status/693544959618760704">January 30, 2016</a></blockquote> </figure><p>This standarization style is what we&#x2019;ve come to know as a living standard. It&#x2019;s something that I think was long overdue when it comes to JavaScript, even though <strong>in practice, implementation was already behaving this way</strong>: browsers already implement much of ES6 and there never was a waiting period until 100% of ES6 is implemented.</p> <p>Firefox, Chrome, and Edge all offer <strong>over 90% compliancy of the ES6 specification</strong>, and we&#x2019;ve been able to use the features they implemented as they came out rather than having to wait until the flip of a switch when their implementation of ES6 was 100% finalized. This can also be connected with what Chris Heilmann frequently brings up when he mentions browser vendors need developers to try out features in order to improve them, but developers need to be able to play with those features in order to try them out.</p> <p>Personally, I&#x2019;m pretty excited about JavaScript becoming a living standard, and so should you! We&#x2019;ve seen how much CSS improved as a result, so this is another step in the right direction by the ECMAScript council. Yay, JavaScript!</p></div>
