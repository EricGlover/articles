<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/web-audio-art">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/web-audio-art"><div><img src="https://i.imgur.com/mOWCPDZ.jpg" alt="What Does a Sound Look Like? Web Audio Art!"></div></a>

<h1>What Does a Sound Look Like? Web Audio Art!</h1>

<p><kbd>art</kbd> <kbd>web-audio</kbd> <kbd>hacks</kbd></p>

<blockquote><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank">Web Audio API</a> is a very powerful feature available in modern browsers today, boasting a rich set of functionality. In this exploration, we&#x2019;ll be looking at &#x2026;</p></blockquote>

<div><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank" rel="noopener noreferrer">Web Audio API</a> is a very powerful feature available in modern browsers today, boasting a rich set of functionality. In this exploration, we&#x2019;ll be looking at ways to analyse audio data and produce some visual output, ranging from the rudimentary to the ridiculous. Let&#x2019;s get started!</p></div>

<blockquote><p>Suz is always showing off cool hacks at conferences. I asked her to write about one of her most recent talks <em>&#x2013; The Formulartic Spectrum &#x2013;</em> which really inspired me. You can <a href="https://www.youtube.com/watch?v=P8Cy2_ZHWI8" target="_blank" rel="noopener noreferrer">watch her presentation at JSConf Budapest</a> to catch a glimpse. Otherwise, save it for later and read on!</p><p align="right"><sub><em>&#x2014; Editor&#x2019;s note.</em></sub></p></blockquote>

<div><p>When you think of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank" rel="noopener noreferrer">Web Audio API</a>, you probably immediately think of music creation in the browser. However, there are other things that can be created with the help of this amazing API. The audio analysis tools and methods available open up new opportunities and uses. For example, painting visual art with sounds is one fun way to think out of the box! How can stimuli meant for hearing become something you can see instead?</p> <p>What if I told you that harvesting a humble WAVE file for its audio data is possible using the Web Audio API? That data is just waiting to be messed around with.</p> <p>Let&#x2019;s dive in, explore what this data looks like, and make some art! &#x1F3A8;</p></div>

<div><h2 id="a-little-theory">A little theory</h2> <p>First, let&#x2019;s look at one of the many audio formats out there: PCM. PCM is an acronym for &#x2018;Pulse Code Modulation&#x2019;. The PCM file format allows uncompressed audio data storage. You&#x2019;ve probably played PCM files before - common file extensions that are in PCM are .WAV, .PCM, .AIFF, and more.</p> <p>So what does a PCM file look like? Let&#x2019;s examine a WAVE file to see. A WAVE file has three distinct sections to it - the RIFF chunk, format chunk, and data chunk.</p> <figure><img alt="diagram of file icon with RFF, FMT and DATA labeled thirds" class="" src="https://i.imgur.com/8snMhDu.png"></figure> <p>The RIFF chunk briefly describes details such as what type of file it is. The FMT or format chunk contains important information including the type of compression, how many channels of audio are present, the sample rate, average bytes per second, etc etc.</p> <p>We are most concerned with the last one - the data chunk. This contains the PCM data itself. Each data point is an individual sample of the audio content. The value of each sample ranges from -1 to +1. This is what we&#x2019;ll be working with when analysing audio sources. The diagram below shows how the audio is recorded digitally by sampling the sound waves at tiny intervals:</p> <figure><img alt="diagram of pcm samples" class="" src="https://i.imgur.com/Bn1dKfl.png"></figure> <p>Note: each audio channel in the WAVE file (eg. &#x2018;left&#x2019; and &#x2018;right&#x2019; channels) are interleaved within the data. This means, that if our audio file has 2 channels, each sample will output both channels&#x2019; values next to each other in the PCM data chunk. This is easy to deal with, as our format chunk tells us how many channels are in the WAVE file.</p> <h2 id="extracting-pcm-data-in-the-browser">Extracting PCM data in the browser</h2> <p>The Web Audio API offers a method we can use to extract the PCM data from any PCM file. The method is <code class="md-code md-code-inline">decodeAudioData</code>. It takes an array buffer of the PCM file contents, and a callback function for when the data has been successfully decoded.</p> <p>In this example, a WAVE file will be used from <a href="https://soundcloud.com/nasa/sets/golden-record-greetings-to-the" target="_blank" rel="noopener noreferrer">NASA&#x2019;s Golden Record: Greetings to the Universe (listen)</a>. Let&#x2019;s choose the <a href="https://soundcloud.com/nasa/golden-record-english-greeting?in=nasa/sets/golden-record-greetings-to-the" target="_blank" rel="noopener noreferrer">English greeting (listen)</a>.</p> <p>The first step is to get the contents of the WAVE file in array buffer format. The <a href="https://jakearchibald.com/2015/thats-so-fetch/" target="_blank" rel="noopener noreferrer">Fetch API</a> will do the job well for this. If Fetch is not available in your browser of choice, the <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener noreferrer">XMLHttpRequest API</a> will also work. We return the WAVE file in an <code class="md-code md-code-inline">arrayBuffer</code>, and create a new <code class="md-code md-code-inline">Int8Array</code> &#x2018;view&#x2019; so that we can read the individual elements in a console log to ensure everything worked as expected.</p> <p>Putting it all together, we get the code below:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">
fetch(<span class="md-code-string">&apos;English.wav&apos;</span>)
  .then((response) =&gt; response.arrayBuffer())
  .then((fileBuffer) =&gt; {
    <span class="md-code-built_in">console</span>.log(<span class="md-code-keyword">new</span> <span class="md-code-built_in">Int8Array</span>(fileBuffer)); <span class="md-code-comment">// [82, 73, 70, 70, 104, 16, 1, 0, 87, ...]</span>
  });
</code></pre> <p>Once we have the file contents in the correct form, let&#x2019;s create a new <code class="md-code md-code-inline">AudioContext</code> and decode the audio data. The method to call from the AudioContext is <code class="md-code md-code-inline">decodeAudioData</code>. For arguments, it takes our <code class="md-code md-code-inline">arrayBuffer</code> returned after the fetch from before, and a callback with the decoded data passed in. From there, the decoded data is wrapped in some convenience methods, including getting channel data. For simplicity, we&#x2019;ll grab just one channel of audio data (the first one).</p> <p>Let&#x2019;s look at what the code looks like now:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">
fetch(<span class="md-code-string">&apos;English.wav&apos;</span>)
  .then((response) =&gt; response.arrayBuffer())
  .then((fileBuffer) =&gt; {
    <span class="md-code-comment">// create new Web Audio API context</span>
    <span class="md-code-keyword">let</span> audioCtx = <span class="md-code-keyword">new</span> AudioContext();
    
    audioCtx.decodeAudioData(fileBuffer, (audioData) =&gt; {
      <span class="md-code-comment">// get the first set of channel data only</span>
      <span class="md-code-keyword">let</span> channelData = audioData.getChannelData(<span class="md-code-number">0</span>);
      <span class="md-code-built_in">console</span>.log(channelData); <span class="md-code-comment">// [0.02567136287689209, 0.026834938675165176, ...]</span>
    });
  });
</code></pre> <p>That console log of <code class="md-code md-code-inline">channelData</code> will show the PCM values we&#x2019;re looking for. Now let&#x2019;s do something cool with this data!</p> <h2 id="transforming-pcm-data">Transforming PCM data</h2> <p>At this point, the PCM data is just a set of raw numbers. Numbers are really versatile to work with, and can be mapped to other contexts.</p> <p>Keeping to our art in the browser theme, what if we transformed the audio data into something visual. What does sound &#x201C;look&#x201D; like? This can be approached in a myriad of ways, but let&#x2019;s keep this simple. What if each PCM sample was mapped to a color? And that color was applied to a pixel? By using a canvas element, we can explore this. First step - create a canvas element and grab its 2D context:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// within decodeAudioData callback</span>
<span class="md-code-keyword">let</span> c = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">&apos;canvas&apos;</span>);
<span class="md-code-keyword">let</span> ctx = c.getContext(<span class="md-code-string">&apos;2d&apos;</span>);
</code></pre> <p>What has this given us? With a canvas element, we essentially have a blank playground to start &#x2018;painting&#x2019; with the PCM audio data. One literal way of representing the PCM values is to paint one pixel on the canvas for each value. If they&#x2019;re all lined up, some patterns might even emerge!</p> <p>Intuitively, we can size the canvas based on how many pixels it&#x2019;s going to have. The amount of pixels is equal to the length of the PCM data (the single channel we extracted). Based on this, we can also calculate how wide and tall the final canvas element should be.</p> <p>Squares are a great shape to work with, as they&#x2019;re pleasing to look at, and the math to produce them is relatively minimal. Let&#x2019;s go with drawing a square shape out of the PCM data pixels.</p> <p>The next step is to use some math to figure out the height and width of the square &#x1F4D0;&#x1F4CF;. Using the length of the <code class="md-code md-code-inline">channelData</code> array, calculating the square root will give us how long each side of the square should be.</p> <p>After creating the canvas element, setting the width and height property looks like the code example below:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// within decodeAudioData callback</span>
<span class="md-code-keyword">let</span> c = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">&apos;canvas&apos;</span>);
<span class="md-code-keyword">let</span> ctx = c.getContext(<span class="md-code-string">&apos;2d&apos;</span>);

<span class="md-code-comment">// math!</span>
<span class="md-code-keyword">let</span> size = <span class="md-code-built_in">Math</span>.sqrt(channelData.length);
c.height = size;
c.width = size;
</code></pre> <p>Once the canvas element is the right physical size, we need an image data object to manipulate before &#x2018;painting&#x2019; it onto the square canvas. Canvas elements have a method called <code class="md-code md-code-inline">createImageData</code> which returns an RGBA (red/green/blue/alpha) image data array. Because each pixel has four values (three colors and alpha), the image data array is four times as long as the <code class="md-code md-code-inline">channelData</code> array. We just need to keep this in mind when setting each pixel up. Each pixel will require four adjacent values to be changed.</p> <p>The last line in the code below sets up an image data array and assigns it to the variable <code class="md-code md-code-inline">imgData</code>:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// within decodeAudioData callback</span>
<span class="md-code-keyword">let</span> c = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">&apos;canvas&apos;</span>);
<span class="md-code-keyword">let</span> ctx = c.getContext(<span class="md-code-string">&apos;2d&apos;</span>);

<span class="md-code-comment">// math!</span>
<span class="md-code-keyword">let</span> size = <span class="md-code-built_in">Math</span>.sqrt(channelData.length);
c.height = size;
c.width = size;

<span class="md-code-comment">// canvas data</span>
<span class="md-code-keyword">let</span> imgData = ctx.createImageData(size, size);
</code></pre> <p>Ok! Now for the fun part. Each PCM sample value is mapped to one pixel, as mentioned earlier. Using HSL, or Hue / Saturation / Luminosity in this kind of example is much more straightforward to get visually pleasing results for coloring the pixel. &#x201C;But canvas image data arrays use RGBA,&#x201D; I hear you protest. That&#x2019;s ok! These values will need to be converted to RGBA later on to resolve this nit, but coding the loop over the PCM samples can happen first.</p> <p>The loop examines every PCM data value in <code class="md-code md-code-inline">channelData</code>, and uses the value to influence its associated pixel&#x2019;s hue. The first PCM data value produces the first pixel in the canvas image data array, and so on until all PCM data values have produced a pixel. Therefore the canvas image data array is filled out from left to right, row by row until the entire loop is done.</p> <p>The final loop is below:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">channelData.forEach((v, i) =&gt; {
  <span class="md-code-comment">// clamp the data value to a scale of 0-255</span>
  <span class="md-code-keyword">let</span> val = <span class="md-code-built_in">Math</span>.ceil((v + <span class="md-code-number">1</span>) * <span class="md-code-number">255</span> / <span class="md-code-number">2</span>);
  
  <span class="md-code-comment">// get color of pixel in RGBA (we&apos;ll write the function hslToRgba next)</span>
  <span class="md-code-comment">// play with the 0.74 value to tweak what kind of colors are returned -  fun!</span>
  <span class="md-code-keyword">let</span> rgba = hslToRgba(val / <span class="md-code-number">0.74</span>, <span class="md-code-number">255</span>, <span class="md-code-number">150</span>, <span class="md-code-number">255</span>);
  
  <span class="md-code-comment">// starting point in the canvas image data</span>
  <span class="md-code-comment">// there are four elements per pixel in canvas data arrays (R, G, B, and A)</span>
  <span class="md-code-keyword">let</span> start = i * <span class="md-code-number">4</span>;
  
  <span class="md-code-comment">// set one canvas pixel to RGBA values</span>
  <span class="md-code-comment">// loop over the 4 adjacent values the pixel has in the canvas image data</span>
  rgba.forEach((v, i) =&gt; {
    imgData.data[start + i] = v;
  });
});
</code></pre> <p>Now for the <code class="md-code md-code-inline">hslToRgba</code> function. A very common implementation is below. Complicated math ahead &#x1F4D0;&#x1F4CF; ! We don&#x2019;t need to worry too much about what all of this means. Color theory is a fascinating topic, but not one we have time for today.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">hslToRgba</span><span class="md-code-params">(h, s, l, a)</span> </span>{
  <span class="md-code-keyword">let</span> r, g, b; 

  h = h / <span class="md-code-number">255</span>;
  s = s / <span class="md-code-number">255</span>;
  l = l / <span class="md-code-number">255</span>;
	
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">convert</span><span class="md-code-params">(p, q, t)</span> </span>{
    <span class="md-code-keyword">if</span> (t &lt; <span class="md-code-number">0</span>) t += <span class="md-code-number">1</span>;
    <span class="md-code-keyword">if</span> (t &gt; <span class="md-code-number">1</span>) t -= <span class="md-code-number">1</span>;
    <span class="md-code-keyword">if</span> (t &lt; <span class="md-code-number">1</span> / <span class="md-code-number">6</span>) <span class="md-code-keyword">return</span> p + (q - p) * <span class="md-code-number">6</span> * t;
    <span class="md-code-keyword">if</span> (t &lt; <span class="md-code-number">1</span> / <span class="md-code-number">2</span>) <span class="md-code-keyword">return</span> q;
    <span class="md-code-keyword">if</span> (t &lt; <span class="md-code-number">2</span> / <span class="md-code-number">3</span>) <span class="md-code-keyword">return</span> p + (q - p) * (<span class="md-code-number">2</span> / <span class="md-code-number">3</span> - t) * <span class="md-code-number">6</span>;
    <span class="md-code-keyword">return</span> p;
  }
	   
  <span class="md-code-keyword">let</span> q = l &lt; <span class="md-code-number">0.5</span> ? l * (<span class="md-code-number">1</span> + s) : l + s - l * s;
  <span class="md-code-keyword">let</span> p = <span class="md-code-number">2</span> * l - q;
  r = convert(p, q, h + <span class="md-code-number">1</span> / <span class="md-code-number">3</span>);
  g = convert(p, q, h);
  b = convert(p, q, h - <span class="md-code-number">1</span> / <span class="md-code-number">3</span>);
	
  <span class="md-code-keyword">return</span> [r * <span class="md-code-number">255</span>, g * <span class="md-code-number">255</span>, b * <span class="md-code-number">255</span>, a];
}
</code></pre> <p>The most difficult parts are done. Finally, let&#x2019;s populate the canvas element&#x2019;s pixels, and place the final result on the page! We can take the finished <code class="md-code md-code-inline">imgData</code> array, and pass it into the canvas element&#x2019;s <code class="md-code md-code-inline">putImageData</code> method. The last two arguments specify the x and y coordinates of where to start placing the image data. Our canvas element is exactly the right size, so 0 and 0 make sense.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// put the pixels on the canvas</span>
ctx.putImageData(imgData, <span class="md-code-number">0</span>, <span class="md-code-number">0</span>);

<span class="md-code-comment">// place the canvas into the HTML document</span>
<span class="md-code-built_in">document</span>.body.appendChild(c);
</code></pre> <h2 id="results">Results</h2> <p>When NASA&#x2019;s Golden Record: English Greeting is run through the code we wrote, we get the following:</p> <figure><img alt="NASA&apos;s Golden Record English Greeting displayed in pixels" class="" src="https://i.imgur.com/OWIf9QZ.png"></figure> <p>Pretty cool, huh! If you study the visual closely, you might be able to make out each individual word, and the slight artifact at the end of the sound file producing the soft pink banding on the bottom. Neato.</p> <p>Tweaking the first argument in the <code class="md-code md-code-inline">hslToRgba</code> method call will change up which colors will output onto the canvas. I encourage you to play with it and have some fun!</p> <p>&#x1F30A; Here&#x2019;s what the sound of a single crashing ocean wave looks like:</p> <figure><img alt="a crashing ocean sound displayed in pixels" class="" src="https://i.imgur.com/3m29l7y.png"></figure> <p>&#x1F413; A rooster crowing looks like this:</p> <figure><img alt="rooster crowing displayed in pixels" class="" src="https://i.imgur.com/EIrOMvj.png"></figure> <h2 id="taking-it-further">Taking it further</h2> <p>What if we fed the pixel data back into the Web Audio API, to test if it sounds the same as the original? Let&#x2019;s try it! The following code will turn pixels back into sound data again. We have to create a new audio buffer to put the sound data into, in a similar way to the canvas image data array.</p> <p>Calling <code class="md-code md-code-inline">createBuffer</code> on the audio context is the way to do this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// create a new single channel audio buffer to put sound into</span>
<span class="md-code-keyword">let</span> soundBuffer = audioCtx.createBuffer(<span class="md-code-number">1</span>, channelData.length, audioCtx.sampleRate);
<span class="md-code-comment">// get channel data for mutating</span>
<span class="md-code-keyword">let</span> channelBuffer = soundBuffer.getChannelData(<span class="md-code-number">0</span>);
</code></pre> <p>Taking the new <code class="md-code md-code-inline">soundBuffer</code>, we can loop through and transform the red value of each pixel back into a value between -1 and +1. Each data or sample value within the <code class="md-code md-code-inline">soundBuffer</code> object will be assigned in this way, until it&#x2019;s full of PCM values.</p> <p>Take a look below to see how the loop works:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>, l = channelData.length; i &lt; l; i++) {
  <span class="md-code-comment">// take the red value of each pixel only for simplicity</span>
  <span class="md-code-comment">// audio needs to be in -1.0 - 1.0</span>
  <span class="md-code-comment">// 0 = -1, 255 = 1</span>
  channelBuffer[i] = ((imgData.data[i*<span class="md-code-number">4</span>] / <span class="md-code-number">255</span>)  * <span class="md-code-number">2</span> - <span class="md-code-number">1</span>);
}
</code></pre> <p>Then, it&#x2019;s a matter of connecting this new sound data to a new audio context source, and then start playing it &#x1F4E2; !</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">let</span> source = audioCtx.createBufferSource();

<span class="md-code-comment">// set the source to be the buffer we created earlier</span>
source.buffer = soundBuffer;

<span class="md-code-comment">// connect the source to the destination so we can hear the sound</span>
source.connect(audioCtx.destination);

<span class="md-code-comment">// start the source playing!</span>
source.start();
</code></pre> <p>You should hear the WAVE file playing back to you. What happens if those HSL values are tweaked in the pixel loop we wrote earlier? Give that a try yourself. Notice how the sound distorts in different ways? Cool!</p> <p>You can view this entire example (and fork it) at my <a href="http://codepen.io/noopkat/pen/QKLbxL?editors=0010#0" target="_blank" rel="noopener noreferrer">codepen</a> - I can&#x2019;t wait to see what you make! &#x1F389;</p> <p>This is one simple example of the ways you can manipulate something from one format into another in order to create browser art. There are ways to really go to town on this, generating complex visual rules for each PCM data sample. Consider using extra tools, such as <a href="http://threejs.org/" target="_blank" rel="noopener noreferrer">three.js</a> and <a href="https://d3js.org/" target="_blank" rel="noopener noreferrer">D3.js</a>. The sky is the limit! For a more abstract application of audio art, check out my <a href="http://noopkat.github.io/iltsw/index5.html" target="_blank" rel="noopener noreferrer" aria-label="I love the subway by Suz Hinton">&#x201C;I love the subway&#x201D;</a> piece, which attempts to create a song, complete with cats playing guitars! &#x1F638;&#x1F3B8;</p> <figure><a href="http://noopkat.github.io/iltsw/index5.html" target="_blank" rel="noopener noreferrer" aria-label="I love the subway by Suz Hinton"><img alt="cats on the subway" class="" src="https://i.imgur.com/zQqZBkc.png"></a></figure> <blockquote> <p>What are some cool hacks you&#x2019;ve made using the Web Audio API?</p> </blockquote></div>
