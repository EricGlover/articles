<div><blockquote>
  <h1>The <code class="md-code md-code-inline">npm</code> Meltdown Uncovers Serious Security Risks</h1>
  <div><p>Earlier this week, as almost everyone reading this article knows, <code>npm</code> experienced a brief service interruption where <code>npm install</code> would fail for heaps of popular packages &#x2026;</p></div>
</blockquote></div>

<div><p>Earlier this week, as almost everyone reading this article knows, <code class="md-code md-code-inline">npm</code> experienced a brief service interruption where <code class="md-code md-code-inline">npm install</code> would fail for heaps of popular packages such as Babel and React Native, because somewhere deep in their dependency chains there was <code class="md-code md-code-inline">left-pad</code>, a popular package that became unpublished. This event <strong>raises serious security concerns</strong> about how we&#x2019;re handling dependencies in the JavaScript world.</p></div>

<div></div>

<div><p>For context, here&#x2019;s a recap of the events leading up to the short-lived <code class="md-code md-code-inline">npm install</code> issues earlier this week.</p> <ul> <li>Azer published <a href="https://github.com/starters/kik" target="_blank" aria-label="starters/kik on GitHub">an open-source library</a> as the <code class="md-code md-code-inline">kik</code> package on <code class="md-code md-code-inline">npm</code></li> <li><a href="https://www.kik.com/" target="_blank">Kik</a> wanted to use the <code class="md-code md-code-inline">kik</code> package, and they approached Azer about it</li> <li>Azer doesn&#x2019;t want to give up the <code class="md-code md-code-inline">kik</code> package name</li> <li>Kik approaches <code class="md-code md-code-inline">npm</code> through their conflict resolution policy <a href="https://medium.com/@mproberts/a-discussion-about-the-breaking-of-the-internet-3d4d2a83aa4d" target="_blank" aria-label="A discussion about the breaking of the Internet">about a solution</a></li> <li><code class="md-code md-code-inline">npm</code> <a href="http://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm" target="_blank" aria-label="kik, left-pad, and npm">transfers ownership</a> of <code class="md-code md-code-inline">kik</code> to Kik</li> <li>Azer retaliates by <a href="https://medium.com/@azerbike/i-ve-just-liberated-my-modules-9045c06be67c" target="_blank" aria-label="I&#x2019;ve Just Liberated My Modules">unpublishing all of his packages</a> from <code class="md-code md-code-inline">npm</code></li> <li>One of those packages, <a href="https://github.com/azer/left-pad" target="_blank" aria-label="azer/left-pad on GitHub"><code class="md-code md-code-inline">left-pad</code></a>, was a popular dependency, underlying many other packages in the ecosystem</li> <li><code class="md-code md-code-inline">npm install</code> started failing across the board for every package that has a dependency on <code class="md-code md-code-inline">left-pad@0.0.3</code></li> <li>A third party published <code class="md-code md-code-inline">left-pad@1.0.0</code> with a copy of <code class="md-code md-code-inline">left-pad@0.0.3</code>, but it didn&#x2019;t help a lot</li> <li><code class="md-code md-code-inline">npm</code> allowed that same third party to re-publish <code class="md-code md-code-inline">left-pad@0.0.3</code> as an exact copy of the unpublished package</li> <li>Service was restored</li> </ul> <p>From there, dozens of articles and tweets about the event were dispatched. Some questioned Kik&#x2019;s claim to ownership of the <code class="md-code md-code-inline">kik</code> package name. Some questioned Azer&#x2019;s retaliation causing more damage to the community than to Kik. Some questioned <code class="md-code md-code-inline">npm</code> for allowing a user to un-break the ecosystem by re-publishing an unpublished and fully open-source package. Some questioned <code class="md-code md-code-inline">npm</code> for allowing users to <code class="md-code md-code-inline">npm unpublish</code> in the first place. Some questioned <code class="md-code md-code-inline">npm</code> for defending their interests over Azer&#x2019;s and giving up ownership of <code class="md-code md-code-inline">kik</code>.</p> <p>The root cause of all of the above is, of course, <strong>trust</strong>. And it runs deep. In this article I want to go over the implications and hopefully trigger a constructive discussion around the topic.</p></div>

<div><h1 id="trust-issues">Trust Issues</h1> <p>A few hours ago, a discussion started on <a href="https://github.com/npm/npm/issues/12045#issuecomment-200976024" target="_blank" aria-label="&apos;Should I trust npm?&apos; - #12045 on GitHub"><code class="md-code md-code-inline">npm/npm#12045</code></a> about whether we should trust <code class="md-code md-code-inline">npm</code>. Trusting <code class="md-code md-code-inline">npm</code> as a company is beside the point, though. A more important question is whether we can trust what people publish on <code class="md-code md-code-inline">npm</code>.</p> <blockquote> <p>Can we trust package authors?</p> </blockquote> <p>There are about <code class="md-code md-code-inline">Infinity</code> possible security risks posed by an <code class="md-code md-code-inline">npm</code> package author &#x201C;going rogue&#x201D;, having his account compromised, or even making a mistake. Let&#x2019;s enumerate a few scenarios where if <em>&quot;a package author decided to <code class="md-code md-code-inline">${action}</code>&quot;</em> would result in pain and suffering for the ecosystem as a whole.</p> <ul> <li>Unpublish a popular module preventing their dependants, and their dependants&#x2019; dependants from ever being installed again unless <code class="md-code md-code-inline">npm</code> chimed in</li> <li>Include a <code class="md-code md-code-inline">postinstall</code> script such as <code class="md-code md-code-inline">rf -rf /</code></li> <li>Include a <code class="md-code md-code-inline">postinstall</code> script such as <code class="md-code md-code-inline">npm unpublish</code></li> <li>Include a <code class="md-code md-code-inline">postinstall</code> script that allows for remote code execution</li> <li>Publish a semver patch version containing a bug that makes the package unusable</li> </ul> <p>Even if we make <code class="md-code md-code-inline">npm unpublish</code> harder <em>or even impossible</em>, the community&#x2019;s reliance on semver means that we would still be exposed to multiple other vulnerabilities, that may well fly under our radars, and that could be introduced at any point in time by a bad actor such as a rogue package author or someone taking over the account of a popular package holder.</p> <p>The vast majority of <code class="md-code md-code-inline">npm</code> users are benevolent, though. This is why semver mostly works.</p> <blockquote> <p>Trusting package authors mostly works. <strong>Until it doesn&#x2019;t.</strong></p> </blockquote> <p>Thus, we came up with techniques such as <code class="md-code md-code-inline">npm shrinkwrap</code> or simply <a href="https://medium.com/@Rich_Harris/how-to-not-break-the-internet-with-this-one-weird-trick-e3e2d57fee28" target="_blank" aria-label="How to not break the internet with this one weird trick">bundling your dependencies on <code class="md-code md-code-inline">npm publish</code></a> so that we can trust a snapshot of what package authors produce, and not all of it. How is doing that any different than getting rid of semver, something that has <a href="https://ponyfoo.com/articles/immutable-npm-dependencies" aria-label="Keeping Your npm Dependencies Immutable on Pony Foo">been posited in the past without gaining much traction</a>?</p> <p>Again, semver mostly works, so we&#x2019;re reluctant to not rely on it. There is value to semver, though.</p> <h1 id="the-fix-bundling-before-publishing">The Fix: Bundling Before Publishing</h1> <p>Bundling on publish means we take advantage of our dependencies being semantically versioned during development, but that we won&#x2019;t allow ourselves to publish a package that may mutate over time. At the same time, installs will be faster because we won&#x2019;t be relying on <code class="md-code md-code-inline">npm</code> to resolve a bunch of dependencies. This is basically <a href="https://medium.com/@Rich_Harris/how-to-not-break-the-internet-with-this-one-weird-trick-e3e2d57fee28" target="_blank" aria-label="How to not break the internet with this one weird trick">what Rich argues in his Medium article</a>, and partly what I&#x2019;ve argued <a href="https://ponyfoo.com/articles/immutable-npm-dependencies" aria-label="Keeping Your npm Dependencies Immutable on Pony Foo">in my article about semver</a>.</p> <p>Does bundling on publish mean our dependants lose the ability to take advantage of semver?</p> <blockquote> <p><em>No.</em></p> </blockquote> <h1 id="semantic-versioning-can-still-help-us-during-development">Semantic Versioning Can Still Help us During Development</h1> <p>Not allowing semantic versioning to leak through the entire dependency tree is the <em>healthy approach to take here</em>.</p> <p>This is no different to Browserify having transforms run only at the local package level: the package author knows what transforms are best for their package, but they don&#x2019;t really know their dependencies, or whether something will break at some point by running those transforms on a global scale. The author of dependencies can&#x2019;t foresee every possible transform that&#x2019;d be run against their code, so Browserify compromises on defaulting to local transforms. Semantic versioning is the same thing, but it&#x2019;s lacking a sensible default.</p> <p>Then there&#x2019;s the issue of code duplication, but that&#x2019;s a story for another day. I&#x2019;ll take code duplication over fear of bringing services down any day. When it comes to front-end development, code duplication should be taken seriously, though, and <code class="md-code md-code-inline">npm</code> is probably the best place where we can come up with a solution to that problem.</p> <h1 id="immutability-predictability-and-a-possibly-service-provided-solution">Immutability, Predictability, and a Possibly-Service-Provided Solution</h1> <p>Another take on fixing this issue would be having an immutable version of <code class="md-code md-code-inline">npm</code>, let&#x2019;s call it <code class="md-code md-code-inline">ipm</code>. In this scenario, we&#x2019;d keep semver for local development but there&#x2019;d be a twist: anything ever published to <code class="md-code md-code-inline">ipm</code> would remain on <code class="md-code md-code-inline">ipm</code> forever. Unpublishing would only be possible through a DMCA process. At the time of publishing an <code class="md-code md-code-inline">example@version</code> package, <code class="md-code md-code-inline">ipm</code> would take care of computing all dependencies for <code class="md-code md-code-inline">example@version</code>, respecting semver throughout the dependency graph, and bundling them together with the published <code class="md-code md-code-inline">example@version</code> package. When <code class="md-code md-code-inline">example@version</code> is installed, <strong>the exact same content would be downloaded every time</strong>. There wouldn&#x2019;t be any need for package authors to take on the obnoxious task of bundling things together, because the <code class="md-code md-code-inline">ipm</code> service would take care of that for them. The service should also be smart enough to bundle packages in such a way that code duplication is reduced to a minimum.</p> <p>A service like <code class="md-code md-code-inline">ipm</code>, when widely adopted by the community, would accomplish two things.</p> <p><strong>First</strong>, situations such as a package author unpublishing a popular module and causing <code class="md-code md-code-inline">ipm install</code> to fail across the board would be avoided by preventing user-powered unpublishing entirely. If a DMCA notice or similar legal reason were to trigger the take-down of the <code class="md-code md-code-inline">doge</code> package from the registry, then things that depended on <code class="md-code md-code-inline">doge</code> would remain unaffected because <code class="md-code md-code-inline">doge</code> was previously bundled into their dependants. Similarly, if a malicious user decided to introduce a <code class="md-code md-code-inline">postinstall</code> vulnerability, it would only affect development environments and those who decide to update their <code class="md-code md-code-inline">doge</code> dependency without verifying its integrity through one of those monitoring solutions which ensure packages on <code class="md-code md-code-inline">npm</code> don&#x2019;t go rogue.</p> <blockquote> <p>Trusting others is the foundation of our community, but everyone can make mistakes and some can go rogue. <strong>We can&#x2019;t rely on trust alone.</strong></p> </blockquote> <p><strong>Second</strong>, and perhaps even most importantly, it&#x2019;d introduce predictability, something we&#x2019;ve been sorely missing lately in the grand scheme of all things web development. By staying immutable at the source, <code class="md-code md-code-inline">ipm</code> would allow intermediary services such as Travis <em>&#x2013; as well as <code class="md-code md-code-inline">npm</code> end users &#x2013;</em> to heavily cache those immutable packages that are known never to change. Even if development versions take full advantage of <em>(one level deep)</em> semver ranges, each package downloaded with <code class="md-code md-code-inline">ipm install</code> would be a never-changing bundle. Installation time would also significantly go down, even when the bundles aren&#x2019;t cached, <code class="md-code md-code-inline">ipm</code> would have pre-computed all the necessary files for each dependency, no more tree-deep request-fests! <img class="tj-emoji" draggable="false" alt="&#x1F333;" src="https://twemoji.maxcdn.com/2/72x72/1f333.png"></p> <blockquote> <p>Predictability shouldn&#x2019;t be as undervalued as it is today.</p> </blockquote> <p>If anything, predictability speeds up our development and deployment processes. At its best, it prevents mistakes that stem from <em>&#x201C;lazy developers not bundling their code before deployment for every single package they create ever&#x201D;</em>. Of course, I disagree with the notion of lazy developers &#x2013; that&#x2019;s an oxymoron. But, as the lazy developers we strive to be, this problem should be resolved at the source, and not at the individual community contributor level. It&#x2019;s far too important an issue for each individual to be expected to take responsibility. The service needs to step up.</p></div>
