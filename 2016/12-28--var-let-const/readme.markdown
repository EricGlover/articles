<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/var-let-const">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/var-let-const"><div><img src="https://i.imgur.com/URl6zyr.jpg" alt="Let&#x2019;s use const! Here&#x2019;s why."></div></a>

<h1>Let&#x2019;s use <code class="md-code md-code-inline">const</code>! Here&#x2019;s why.</h1>

<p><kbd>const</kbd> <kbd>es6</kbd> <kbd>best-practices</kbd></p>

<blockquote><p>When reading a piece of code, others can take cues from these signals in order to better understand what we did. ES6 offers <code>let</code> and <code>const</code> as new flavors of variable declaration, are they better signals than <code>var</code>?</p>
</blockquote>

<div><p>When developing software, most of our time is spent reading code. ES6 offers <code class="md-code md-code-inline">let</code> and <code class="md-code md-code-inline">const</code> as new flavors of variable declaration, and part of the value in these statements is that they can signal how a variable is used. When reading a piece of code, others can take cues from these signals in order to better understand what we did. Cues like these are crucial to reducing the amount of time someone spends interpreting what a piece of code does, and as such we should try and leverage them whenever possible.</p></div>

<blockquote></blockquote>

<div><p>A <code class="md-code md-code-inline">let</code> statement indicates that a variable can&#x2019;t be used before its declaration, due to the Temporal Dead Zone rule. This isn&#x2019;t a convention, it is a fact: if we tried accessing the variable before its declaration statement was reached, the program would fail. These statements are block-scoped and not function-scoped; this means we need to read less code in order to fully grasp how a <code class="md-code md-code-inline">let</code> variable is used.</p> <p>The <code class="md-code md-code-inline">const</code> statement is block-scoped as well, and it follows TDZ semantics too. The upside is that <code class="md-code md-code-inline">const</code> bindings can only be assigned during declaration.</p> <p>Note that this means that the variable binding can&#x2019;t change, but it doesn&#x2019;t mean that the value itself is immutable or constant in any way. A <code class="md-code md-code-inline">const</code> binding that references an object can&#x2019;t later reference a different value, but the underlying object can indeed mutate.</p> <p>In addition to the signals offered by <code class="md-code md-code-inline">let</code>, the <code class="md-code md-code-inline">const</code> keyword indicates that a variable binding can&#x2019;t be reassigned. This is a strong signal. You know what the value is going to be; you know that the binding can&#x2019;t be accessed outside of its immediately containing block, due to block scoping; and you know that the binding is never accessed before declaration, because of TDZ semantics.</p> <p>You know all of this just by reading the <code class="md-code md-code-inline">const</code> declaration statement and without scanning for other references to that variable.</p> <p>Constraints such as those offered by <code class="md-code md-code-inline">let</code> and <code class="md-code md-code-inline">const</code> are a powerful way of making code easier to understand. Try to accrue as many of these constraints as possible in the code you write. The more declarative constraints that limit what a piece of code could mean, the easier and faster it is for humans to read, parse, and understand a piece of code in the future.</p></div>

<div><p>Granted, there&#x2019;s more rules to a <code class="md-code md-code-inline">const</code> declaration than to a <code class="md-code md-code-inline">var</code> declaration: block-scoped, TDZ, assign at declaration, no reassignment. Whereas <code class="md-code md-code-inline">var</code> statements only signal function scoping. Rule-counting, however, doesn&#x2019;t offer a lot of insight. It is better to weigh these rules in terms of complexity: does the rule add or subtract complexity? In the case of <code class="md-code md-code-inline">const</code>, block scoping means a narrower scope than function scoping, TDZ means that we don&#x2019;t need to scan the scope backwards from the declaration in order to spot usage before declaration, and assignment rules mean that the binding will always preserve the same reference.</p> <p>The more constrained statements are, the simpler a piece of code becomes. As we add constraints to what a statement might mean, code becomes less unpredictable. This is one of the biggest reasons why statically typed programs are generally easier to read than dynamically typed ones. Static typing places a big constraint on the program writer, but it also places a big constraint on how the program can be interpreted, making its code easier to understand.</p> <p>With these arguments in mind, it is recommended that you use <code class="md-code md-code-inline">const</code> where possible, as it&#x2019;s the statement that gives us the least possibilities to think about.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">if</span> (condition) {
  <span class="md-code-comment">// can&apos;t access `isReady` before declaration is reached</span>
  <span class="md-code-keyword">const</span> isReady = <span class="md-code-literal">true</span>
  <span class="md-code-comment">// `isReady` binding can&apos;t be reassigned</span>
}
<span class="md-code-comment">// can&apos;t access `isReady` outside of its containing block scope</span>
</code></pre> <p>When <code class="md-code md-code-inline">const</code> isn&#x2019;t an option, because the variable needs to be reassigned later, we may resort to a <code class="md-code md-code-inline">let</code> statement. Using <code class="md-code md-code-inline">let</code> carries all the benefits of <code class="md-code md-code-inline">const</code>, except that the variable can be reassigned. This may be necessary in order to increment a counter, flip a boolean flag, or to defer initialization.</p> <p>Consider the following example, where we take a number of megabytes and return a string such as <code class="md-code md-code-inline">1.2 GB</code>. We&#x2019;re using <code class="md-code md-code-inline">let</code>, as the values need to change if a condition is met.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">prettySize</span> <span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">let</span> value = input
  <span class="md-code-keyword">let</span> unit = `MB`
  <span class="md-code-keyword">if</span> (value &gt;= <span class="md-code-number">1024</span>) {
    value /= <span class="md-code-number">1024</span>
    unit = `GB`
  }
  <span class="md-code-keyword">if</span> (value &gt;= <span class="md-code-number">1024</span>) {
    value /= <span class="md-code-number">1024</span>
    unit = `TB`
  }
  <span class="md-code-keyword">return</span> `${ value.toFixed(<span class="md-code-number">1</span>) } ${ unit }`
}
</code></pre> <p>Adding support for petabytes would involve a new <code class="md-code md-code-inline">if</code> branch before the <code class="md-code md-code-inline">return</code> statement.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">if</span> (value &gt;= <span class="md-code-number">1024</span>) {
  value /= <span class="md-code-number">1024</span>
  unit = `PB`
}
</code></pre> <p>If we were looking to make <code class="md-code md-code-inline">prettySize</code> easier to extend with new units, we could consider implementing a <code class="md-code md-code-inline">toLargestUnit</code> function that computes the <code class="md-code md-code-inline">unit</code> and <code class="md-code md-code-inline">value</code> for any given <code class="md-code md-code-inline">input</code> and its current unit. We could then consume <code class="md-code md-code-inline">toLargestUnit</code> in <code class="md-code md-code-inline">prettySize</code> to return the formatted string.</p> <p>The following code snippet implements such a function. It relies on a list of supported <code class="md-code md-code-inline">units</code> instead of using a new branch for each unit. When the input <code class="md-code md-code-inline">value</code> is at least <code class="md-code md-code-inline">1024</code> and there&#x2019;s larger units, we divide the input by <code class="md-code md-code-inline">1024</code> and move to the next unit. Then we call <code class="md-code md-code-inline">toLargestUnit</code> with the updated values, which will continue recursively reducing the <code class="md-code md-code-inline">value</code> until it&#x2019;s small enough or we reach the largest unit.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">toLargestUnit</span> <span class="md-code-params">(value, unit = `MB`)</span> </span>{
  <span class="md-code-keyword">const</span> units = [`MB`, `GB`, `TB`]
  <span class="md-code-keyword">const</span> i = units.indexOf(unit)
  <span class="md-code-keyword">const</span> nextUnit = units[i + <span class="md-code-number">1</span>]
  <span class="md-code-keyword">if</span> (value &gt;= <span class="md-code-number">1024</span> &amp;&amp; nextUnit) {
    <span class="md-code-keyword">return</span> toLargestUnit(value / <span class="md-code-number">1024</span>, nextUnit)
  }
  <span class="md-code-keyword">return</span> { value, unit }
}
</code></pre> <p>Introducing petabyte support used to involve a new <code class="md-code md-code-inline">if</code> branch and repeating logic, but now it&#x2019;s only a matter of adding the <code class="md-code md-code-inline">PB</code> string at the end of the <code class="md-code md-code-inline">units</code> array.</p> <p>The <code class="md-code md-code-inline">prettySize</code> function becomes concerned only with how to display the string, as it can offload its calculations to the <code class="md-code md-code-inline">toLargestUnit</code> function. This separation of concerns is also instrumental in producing more readable code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">prettySize</span> <span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> { value, unit } = toLargestUnit(input)
  <span class="md-code-keyword">return</span> `${ value.toFixed(<span class="md-code-number">1</span>) } ${ unit }`
}
</code></pre> <p>Whenever a piece of code has variables that need to be reassigned, we should spend a few minutes thinking about whether there&#x2019;s a better pattern that could resolve the same problem without reassignment. This is not always possible, but it can be accomplished most of the time.</p> <p>Once you&#x2019;ve arrived at a different solution, compare it to what you used to have. Make sure that code readability has actually improved and that the implementation is still correct. Unit tests can be instrumental in this regard, as they&#x2019;ll ensure you don&#x2019;t run into the same shortcomings twice. If the refactored piece of code seems worse in terms of readability or extensibility, carefully consider going back to the previous solution.</p> <p>Consider the following contrived example, where we use array concatenation to generate the <code class="md-code md-code-inline">result</code> array. Here, too, we could change from <code class="md-code md-code-inline">let</code> to <code class="md-code md-code-inline">const</code> by making a simple adjustment.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">makeCollection</span> <span class="md-code-params">(size)</span> </span>{
  <span class="md-code-keyword">let</span> result = []
  <span class="md-code-keyword">if</span> (size &gt; <span class="md-code-number">0</span>) {
    result = result.concat([<span class="md-code-number">1</span>, <span class="md-code-number">2</span>])
  }
  <span class="md-code-keyword">if</span> (size &gt; <span class="md-code-number">1</span>) {
    result = result.concat([<span class="md-code-number">3</span>, <span class="md-code-number">4</span>])
  }
  <span class="md-code-keyword">if</span> (size &gt; <span class="md-code-number">2</span>) {
    result = result.concat([<span class="md-code-number">5</span>, <span class="md-code-number">6</span>])
  }
  <span class="md-code-keyword">return</span> result
}
makeCollection(<span class="md-code-number">0</span>) <span class="md-code-comment">// &lt;- []</span>
makeCollection(<span class="md-code-number">1</span>) <span class="md-code-comment">// &lt;- [1, 2]</span>
makeCollection(<span class="md-code-number">2</span>) <span class="md-code-comment">// &lt;- [1, 2, 3, 4]</span>
makeCollection(<span class="md-code-number">3</span>) <span class="md-code-comment">// &lt;- [1, 2, 3, 4, 5, 6]</span>
</code></pre> <p>We can replace the reassignment operations with <code class="md-code md-code-inline">Array#push</code>, which accepts multiple values. If we had a dynamic list, we could use the spread operator to push as many <code class="md-code md-code-inline">...items</code> as necessary.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">makeCollection</span> <span class="md-code-params">(size)</span> </span>{
  <span class="md-code-keyword">const</span> result = []
  <span class="md-code-keyword">if</span> (size &gt; <span class="md-code-number">0</span>) {
    result.push(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>)
  }
  <span class="md-code-keyword">if</span> (size &gt; <span class="md-code-number">1</span>) {
    result.push(<span class="md-code-number">3</span>, <span class="md-code-number">4</span>)
  }
  <span class="md-code-keyword">if</span> (size &gt; <span class="md-code-number">2</span>) {
    result.push(<span class="md-code-number">5</span>, <span class="md-code-number">6</span>)
  }
  <span class="md-code-keyword">return</span> result
}
makeCollection(<span class="md-code-number">0</span>) <span class="md-code-comment">// &lt;- []</span>
makeCollection(<span class="md-code-number">1</span>) <span class="md-code-comment">// &lt;- [1, 2]</span>
makeCollection(<span class="md-code-number">2</span>) <span class="md-code-comment">// &lt;- [1, 2, 3, 4]</span>
makeCollection(<span class="md-code-number">3</span>) <span class="md-code-comment">// &lt;- [1, 2, 3, 4, 5, 6]</span>
</code></pre> <p>When you do need to use <code class="md-code md-code-inline">Array#concat</code>, you should probably use <code class="md-code md-code-inline">[...result, 1, 2]</code> instead, to keep it simpler.</p> <p>The last case we&#x2019;ll cover is one of refactoring. Sometimes, we write code like the next snippet, usually in the context of a larger function.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">let</span> completionText = `<span class="md-code-keyword">in</span> progress`
<span class="md-code-keyword">if</span> (completionPercent &gt;= <span class="md-code-number">85</span>) {
  completionText = `almost done`
} <span class="md-code-keyword">else</span> <span class="md-code-keyword">if</span> (completionPercent &gt;= <span class="md-code-number">70</span>) {
  completionText = `reticulating splines`
}
</code></pre> <p>In these cases, it makes sense to extract the logic into a pure function. This way we avoid the initialization complexity near the top of the larger function, while clustering all the logic about computing the completion text in one place.</p> <p>The following piece of code shows how we could extract the completion text logic into its own function. We can then move <code class="md-code md-code-inline">getCompletionText</code> out of the way, making the code more linear in terms of readability.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> completionText = getCompletionText(completionPercent)
<span class="md-code-comment">// ...</span>
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getCompletionText</span><span class="md-code-params">(progress)</span> </span>{
  <span class="md-code-keyword">if</span> (progress &gt;= <span class="md-code-number">85</span>) {
    <span class="md-code-keyword">return</span> `almost done`
  }
  <span class="md-code-keyword">if</span> (progress &gt;= <span class="md-code-number">70</span>) {
    <span class="md-code-keyword">return</span> `reticulating splines`
  }
  <span class="md-code-keyword">return</span> `<span class="md-code-keyword">in</span> progress`
}
</code></pre> <p>What&#x2019;s your stance in <code class="md-code md-code-inline">const</code> vs. <code class="md-code md-code-inline">let</code> vs. <code class="md-code md-code-inline">var</code>?</p> <blockquote> <p><em>This article was extracted from <a href="https://ponyfoo.com/books/practical-es6/chapters#toc" aria-label="Check out its table of contents!">Practical ES6</a>, a book I&#x2019;m writing. It&#x2019;s openly available online under <a href="https://ponyfoo.com/books/practical-es6/chapters/9#read" aria-label="Read chapter 9 on Pony Foo">HTML</a> format, and on GitHub as <a href="https://github.com/mjavascript/practical-es6" target="_blank" rel="noopener noreferrer" aria-label="mjavascript/practical-es6 on GitHub">AsciiDoc</a>. It recently <strong>raised over $12,000 &#x1F4B0;</strong> in funding <a href="https://www.indiegogo.com/projects/modular-javascript-a-pragmatic-js-book-series#/" target="_blank" rel="noopener noreferrer" aria-label="Modular JavaScript on Indiegogo">on Indiegogo</a> and is available as an <a href="http://shop.oreilly.com/product/0636920047124.do" target="_blank" rel="noopener noreferrer" aria-label="Practical ES6 Early Release">Early Release</a> by the publisher, O&#x2019;Reilly Media.</em></p> </blockquote></div>
