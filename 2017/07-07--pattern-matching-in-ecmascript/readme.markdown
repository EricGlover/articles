<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/pattern-matching-in-ecmascript">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/pattern-matching-in-ecmascript"><div><img src="https://i.imgur.com/DWA1qqb.jpg" alt="Pattern Matching in ECMAScript"></div></a>

<h1>Pattern Matching in ECMAScript</h1>

<p><kbd>ecmascript</kbd> <kbd>proposal-draft</kbd></p>

<blockquote><p>There&#x2019;s a stage 0 proposal for pattern matching in JavaScript. In this article we&#x2019;ll take a look at what the proposal entails and also show how you might &#x2026;</p></blockquote>

<div></div>

<blockquote></blockquote>

<div></div>

<div><p>There&#x2019;s a stage 0 proposal for pattern matching in JavaScript. In this article we&#x2019;ll take a look at what the proposal entails and also show how you might find it useful.</p> <p>The <a href="https://github.com/tc39/proposal-pattern-matching" target="_blank" rel="noopener noreferrer" aria-label="tc39/proposal-pattern-matching on GitHub">proposal document</a> has a few code examples, as usual. Here is one of them.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">let</span> length = vector =&gt; match (vector) {
  { x, y, z }: <span class="md-code-built_in">Math</span>.sqrt(x ** <span class="md-code-number">2</span> + y ** <span class="md-code-number">2</span> + z ** <span class="md-code-number">2</span>),
  { x, y }: <span class="md-code-built_in">Math</span>.sqrt(x ** <span class="md-code-number">2</span> + y ** <span class="md-code-number">2</span>),
  [...]: vector.length,
  <span class="md-code-keyword">else</span>: {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`Unknown vector type`)
  }
}
</code></pre> <p>Trying to make sense of that bit of code might prove challenging, given all the unfamiliar code, paired with an arrow function, let assignment, and a boatload of exponentiation operators. Let&#x2019;s reduce it.</p> <h1 id="the-basics-of-ecmascript-pattern-matching">The Basics of ECMAScript Pattern Matching</h1> <p>The following example is a match <em>expression</em> which receives a <code class="md-code md-code-inline">point</code> parameter. When <code class="md-code md-code-inline">point</code> has an <code class="md-code md-code-inline">x</code> property and a <code class="md-code md-code-inline">y</code> property, the expression evaluates to <code class="md-code md-code-inline">[point.x, point.y]</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> point = { x: <span class="md-code-number">5</span>, y: <span class="md-code-number">7</span> }
<span class="md-code-keyword">const</span> result = match (<mark class="md-mark md-code-mark">point</mark>) {
  <mark class="md-mark md-code-mark">{ x, y }</mark>: <mark class="md-mark md-code-mark">[point.x, point.y]</mark>
}
<span class="md-code-built_in">console</span>.log(result) <span class="md-code-comment">// &lt;- [5, 7]</span>
</code></pre> <p>For convenience, we might turn this into a function.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">matchPoint</span><span class="md-code-params">(point)</span> </span>{
  <span class="md-code-keyword">return</span> match (point) {
    { x, y }: [point.x, point.y]
  }
}
</code></pre> <p>Or an arrow function. See how terse this is?</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> matchPoint = point =&gt; match (point) {
  { x, y }: [point.x, point.y]
}
</code></pre> <p>We could make it more terse! In the <code class="md-code md-code-inline">{ x, y }</code> pattern above, <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code> are bound to the properties on <code class="md-code md-code-inline">point</code> by the same name, meaning we could write code like the following. Note that <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code> would only be bound in the &#x201C;match leg&#x201D; for the <code class="md-code md-code-inline">{ x, y }</code> pattern, meaning that the only place where we can reference those bindings is in the case where that pattern is matched.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> matchPoint = point =&gt; match (point) {
  { x, y }: [x, y]
}
</code></pre> <p>We could take this a step further, and match on arrays as well. In this case we&#x2019;re matching an array with two elements, and binding them as <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code>. Just for fun, we&#x2019;ll call this one <code class="md-code md-code-inline">flipPoint</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> flipPoint = point =&gt; match (point) {
  { x, y }: [x, y],
  [x, y]: { x, y }
}
flipPoint([<span class="md-code-number">3</span>, <span class="md-code-number">7</span>]) <span class="md-code-comment">// { x: 3, y: 7 }</span>
flipPoint({ x: <span class="md-code-number">3</span>, y: <span class="md-code-number">7</span> }) <span class="md-code-comment">// [3, 7]</span>
</code></pre> <p>Note that if <code class="md-code md-code-inline">point</code> doesn&#x2019;t match any pattern, a runtime error will occur.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">matchPoint({ x: <span class="md-code-number">3</span>, z: <span class="md-code-number">7</span> })
<span class="md-code-comment">// &lt;- Error</span>
</code></pre> <p>Alternatively, we can set up an <code class="md-code md-code-inline">else</code> pattern. This will match when nothing else does.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> matchPoint = point =&gt; match (point) {
  { x, y }: [x, y],
  <mark class="md-mark md-code-mark">else</mark>: [<span class="md-code-number">0</span>, <span class="md-code-number">0</span>]
}

matchPoint({ x: <span class="md-code-number">3</span>, z: <span class="md-code-number">7</span> })
<span class="md-code-comment">// &lt;- [0, 0]</span>
</code></pre> <p>Instead of a implicitly returning an expression for the match leg, you can use a block. This is akin to how it works for arrow functions.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">const matchPoint = point =&gt; match (point) {
  { x, y }: <mark class="md-mark md-code-mark">{</mark>
    return [x, y]
  <mark class="md-mark md-code-mark">}</mark>,
  else: <mark class="md-mark md-code-mark">{</mark>
    throw new Error(`That&apos;s not even a point!`)
  <mark class="md-mark md-code-mark">}</mark>
}
</code></pre> <h1 id="more-patterns">More Patterns!</h1> <p>There are literal patterns. This means we can match things like <code class="md-code md-code-inline">null</code>, <code class="md-code md-code-inline">undefined</code>, <code class="md-code md-code-inline">true</code>, <code class="md-code md-code-inline">false</code>, in addition to numbers like <code class="md-code md-code-inline">0</code>, and strings like <code class="md-code md-code-inline">&apos;two&apos;</code>. These don&#x2019;t seem all that useful but they may come in handy depending on your use case for pattern matching.</p> <p>Object patterns are <strong>inclusive</strong>: the <code class="md-code md-code-inline">{ x, y }</code> pattern will match on an object shaped like <code class="md-code md-code-inline">{ x, y ,z }</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> matchPoint = point =&gt; match (point) {
  { x, y }: [x, y]
}
matchPoint({ x: <span class="md-code-number">2</span>, y: <span class="md-code-number">5</span>, z: -<span class="md-code-number">1</span> })
<span class="md-code-comment">// &lt;- [2, 5]</span>
</code></pre> <p>If we still want to get all other properties like we would do while destructuring &#x2014; maybe we consider them options &#x2014; we can use a similar dot dot dot operator in pattern matching.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> matchPoint = point =&gt; match (point) {
  { x, y, ...options }: { point: [x, y], options }
}
matchPoint({ x: <span class="md-code-number">2</span>, y: <span class="md-code-number">5</span>, radius: <span class="md-code-number">50</span>, width: <span class="md-code-number">3</span> })
<span class="md-code-comment">// &lt;- { point: [2, 5], options: { radius: 50, width: 3 } }</span>
</code></pre> <p>Object patterns allow for nesting. We can match an object that literally has <code class="md-code md-code-inline">{ x: 3, y: 4 }</code>, for example.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> matchNullPoint = point =&gt; match (point) {
  { x: <span class="md-code-number">0</span>, y: <span class="md-code-number">0</span> }: [x, y]
}
matchNullPoint({ x: <span class="md-code-number">0</span>, y: <span class="md-code-number">0</span> })
<span class="md-code-comment">// &lt;- [0, 0]</span>
</code></pre> <p>The nested pattern could also contain other object matchers.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> isUSD = point =&gt; match (item) {
  { options: { currency: <span class="md-code-string">&apos;USD&apos;</span> } }: <span class="md-code-literal">true</span>,
  <span class="md-code-keyword">else</span>: <span class="md-code-literal">false</span>
}
isUSD({ value: <span class="md-code-number">19.99</span>, options: { currency: <span class="md-code-string">&apos;USD&apos;</span> } })
<span class="md-code-comment">// &lt;- true</span>
isUSD({ value: <span class="md-code-number">19.99</span>, options: { currency: <span class="md-code-string">&apos;ARS&apos;</span> } })
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>Array pattern matching is a little different in that it is <strong>exclusive</strong> by default: the <code class="md-code md-code-inline">[]</code> pattern only matches empty array-like objects with a <code class="md-code md-code-inline">length</code> property, unlike <code class="md-code md-code-inline">{}</code> which would match any object.</p> <p>Arrays can be made <strong>inclusive</strong> by adding the <code class="md-code md-code-inline">...</code> pattern. Unlike in rest, spread, or object pattern matching, it&#x2019;s not necessary to name the rest parameter. We could simply do <code class="md-code md-code-inline">[...]</code>, meaning match an array of any length. Or we could do <code class="md-code md-code-inline">[first, ...]</code> to match an array of any length and place the first item on a binding. Doing <code class="md-code md-code-inline">[...rest]</code> places every element in a binding, and so on.</p> <p>Arrays also support nested pattern matching just like objects did. The following examples matches an array, with a single element (because array patterns are <strong>exclusive</strong> unless we make them <strong>inclusive</strong> by adding <code class="md-code md-code-inline">...</code> to them), that is an object, that has <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code> properties (and maybe some other properties because object patterns are <strong>inclusive</strong>).</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> matchPoint = point =&gt; match (point) {
  [{ x, y }]: [x, y]
}
matchPoint([{ x: <span class="md-code-number">1</span>, y: <span class="md-code-number">2</span> }]) <span class="md-code-comment">// &lt;- [1, 2]</span>
</code></pre> <h1 id="identifiers-and-symbolmatches">Identifiers and <code class="md-code md-code-inline">Symbol.matches</code></h1> <p>We can also match with a regular expression. Note that we can only pass the identifier as a valid match pattern &#x2014; <code class="md-code md-code-inline">numbers</code> &#x2014; and not the regular expression or any expression literal directly. This makes the syntax less complicated while keeping <code class="md-code md-code-inline">match</code> powerful.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> numbers = <mark class="md-mark md-code-mark">/^-?\d+,\s*-?\d+$/</mark>
<span class="md-code-keyword">const</span> matchPoint = point =&gt; match (point) {
  { x, y }: [x, y],
  [x, y]: [x, y],
  <mark class="md-mark md-code-mark">numbers</mark>: point.split(<span class="md-code-regexp">/,\s*/</span>).map(n =&gt; <span class="md-code-built_in">parseInt</span>(n))
}

matchPoint(`{ x: <span class="md-code-number">7</span>, y: -<span class="md-code-number">3</span> }) <span class="md-code-comment">// &lt;- [7, -3]</span>
matchPoint([<span class="md-code-number">7</span>, -<span class="md-code-number">3</span>]) <span class="md-code-comment">// &lt;- [7, -3]</span>
matchPoint(`<span class="md-code-number">7</span>, -<span class="md-code-number">3</span>`) <span class="md-code-comment">// &lt;- [7, -3]</span>
</code></pre> <p>Regular expressions as a pattern matcher are made possible thanks to symbols. The proposal includes <code class="md-code md-code-inline">Symbol.matches</code>, which can be used to determine whether the host object matches the received value.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> threeDigitNumber = {
  [Symbol.matches](value) {
    <span class="md-code-keyword">return</span> value &gt;= <span class="md-code-number">100</span> &amp;&amp; value &lt; <span class="md-code-number">1000</span>
  }
}
</code></pre> <p>Now we can match using the identifier for <code class="md-code md-code-inline">threeDigitNumber</code> in our match patterns.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> matchPoint = point =&gt; match (point) {
  threeDigitNumber: point.toString.split(``).map(n =&gt; <span class="md-code-built_in">parseInt</span>(n))
}
matchPoint(<span class="md-code-number">735</span>) <span class="md-code-comment">// &lt;- [7, 3, 5]</span>
</code></pre> <p>The proposal is in active development, and a few useful <code class="md-code md-code-inline">Symbol.matches</code> extensions and built-in implementations are being considered at this time.</p> <p>If something like basic type pattern matching <code class="md-code md-code-inline">Symbol.matches</code> are offered natively, we&#x2019;d be able to do something akin to type checking in native JavaScript, at least at runtime. This opens up the specification for interesting static type checking possibilities using a similar syntax, though, so the potential is there! &#x1F618;</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> matchPoint = point =&gt; match (point) {
  { x: <span class="md-code-built_in">Number</span>, y: <span class="md-code-built_in">Number</span> }: [x, y]
}
matchPoint({ x: <span class="md-code-number">1</span>, y: <span class="md-code-number">2</span> }) <span class="md-code-comment">// &lt;- [1, 2]</span>
matchPoint({ x: <span class="md-code-number">1</span>, z: <span class="md-code-number">2</span> }) <span class="md-code-comment">// &lt;- Error</span>
matchPoint({ x: <span class="md-code-number">1</span>, y: <span class="md-code-string">&apos;two&apos;</span> }) <span class="md-code-comment">// &lt;- Error</span>
</code></pre> <p>As always, remember this proposal is at stage 0 and thus highly likely to change or fail to materialize as an official JavaScript language feature. &#x1F605;</p></div>
