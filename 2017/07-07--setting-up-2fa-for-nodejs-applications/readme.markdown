<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/setting-up-2fa-for-nodejs-applications">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/setting-up-2fa-for-nodejs-applications"><div><img src="https://i.imgur.com/epv7mbC.jpg" alt="Setting up 2FA for Node.js Applications"></div></a>

<h1>Setting up 2FA for Node.js Applications</h1>

<p><kbd>nodejs</kbd> <kbd>security</kbd></p>

<blockquote><p>Let&#x2019;s take a look at how we can quickly hash out a correct two-factor authentication <em>(2FA)</em> solution for our web applications. First off, let&#x2019;s work out the &#x2026;</p></blockquote>

<div></div>

<blockquote></blockquote>

<div></div>

<div><p>Let&#x2019;s take a look at how we can quickly hash out a correct two-factor authentication <em>(2FA)</em> solution for our web applications. First off, let&#x2019;s work out the required flow.</p> <p>2FA relies on unique shared secrets we&#x2019;ll give our users. Users can then take those shared secrets to generate time-based six-digit tokens on their phone or any other OTP device to log onto our site. This is more secure than plain password-based authentication: in addition to obtaining access to the user&#x2019;s password, a malicious actor would also need the shared secret in order to compromise their account.</p> <p>At this point, let&#x2019;s assume users can already create accounts on our application. To get a minimum viable 2FA out, we&#x2019;ll need:</p> <ul> <li>An enrollment flow where users can <strong>set up 2FA for the first time</strong> <ul> <li>A way to generate the shared secret</li> <li>Somewhere to store each user&#x2019;s secret</li> <li>A way to display a QR code with the shared secret for a more convenient user experience</li> </ul> </li> <li>A challenge flow where we <strong>prompt users</strong> for their 2FA tokens <em>after they log in</em> but <strong>before granting them access</strong> to their account <ul> <li>A place where we&#x2019;ll store whether the user is only partially authenticated but not multi-factor authenticated</li> </ul> </li> <li>A way for the user to turn off 2FA</li> </ul> <p>While most tutorials like this one encourage it, I&#x2019;m going to assume we don&#x2019;t want to force 2FA on every user, which is more practical and seems to be more popular in the wild. For the enrollment flow, the first step is to set up some views. Here&#x2019;s the new <code class="md-code md-code-inline">/account/security</code> view on Pony Foo.</p> <figure><img alt="Account Security on Pony Foo. Note I&apos;ll be using MFA and 2FA interchangeably throughout this post." class="" src="https://i.imgur.com/XExGevg.png"></figure> <p>When clicking on the button, we&#x2019;ll be taken to <code class="md-code md-code-inline">/account/security/multifactor</code>.</p> <figure><img alt="The first-time user experience when setting up 2FA" class="" src="https://i.imgur.com/5V2C1e3.png"></figure> <p>Whoa. Slow down a minute. What&#x2019;s that garbled text thing? How did we generate that QR code?</p> <h1 id="generating-the-shared-secret">Generating the Shared Secret</h1> <p>Well, the &#x201C;garbled text thing&#x201D; is the shared secret we discussed a bit earlier. To get a shared secret that&#x2019;s unique to our user, we&#x2019;ll use the <a href="https://github.com/speakeasyjs/speakeasy" target="_blank" rel="noopener noreferrer" aria-label="speakeasyjs/speakeasy on GitHub"><code class="md-code md-code-inline">speakeasy</code></a> package. In the bit of code below, we call <code class="md-code md-code-inline">speakeasy.generateSecret</code>, which produces an object containing &#x2013; among other things &#x2013; a property called <code class="md-code md-code-inline">base32</code>, which is the base32-encoded shared secret; and a property called <code class="md-code md-code-inline">otpauth_url</code>, which is the endpoint we&#x2019;ll want to encode as a QR code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> speakeasy = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;speakeasy&apos;</span>)

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">setupSecret</span><span class="md-code-params">(user, done)</span> </span>{
  <span class="md-code-keyword">const</span> options = {
    issuer: `Pony Foo`,
    name: `Pony Foo (${ user.email })`,
    length: <span class="md-code-number">64</span>
  }
  <span class="md-code-keyword">const</span> { base32, otpauth_url } = <mark class="md-mark md-code-mark">speakeasy.generateSecret(options)</mark>
  <span class="md-code-comment">// &#x2026;</span>
}
</code></pre> <p>Note that the <code class="md-code md-code-inline">name</code> option is what the user will see on their OTP device upon scanning the QR code, and it&#x2019;s generally recommended that we indicate <code class="md-code md-code-inline">$SITE ($USERNAME)</code> as the name for our shared secret. The <code class="md-code md-code-inline">name</code> will be encoded in the <code class="md-code md-code-inline">otpauth://</code> resource locator generated by <code class="md-code md-code-inline">speakeasy</code> along with the shared secret.</p> <p>We&#x2019;ll need to store this stuff somewhere so that we can later validate the user&#x2019;s tokens against our shared secret. The catch-22 here is that we don&#x2019;t want to treat this shared secret as active until we can verify the user is able to generate valid tokens. This is because the user might fail to scan the QR code for some reason, abandon the enrollment flow before writing down the shared secret, or otherwise end up effectively locked out of their own account because of their inability to generate tokens. For that reason, it&#x2019;s a best practice to ask the user to give us a valid token before we consider their account to have 2FA enabled.</p> <p>One possible solution is to store the shared secret on their user account anyways, but flag it as not being enrolled yet, as shown next.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">setupSecret</span><span class="md-code-params">(user, done)</span> </span>{
  <span class="md-code-keyword">const</span> options = {
    issuer: `Pony Foo`,
    name: `Pony Foo (${ user.email })`,
    length: <span class="md-code-number">64</span>
  }
  <span class="md-code-keyword">const</span> { base32, otpauth_url } = speakeasy.generateSecret(options)
  <span class="md-code-keyword">const</span> mfa = {
    created: <span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>(),
    <mark class="md-mark md-code-mark">enrolled: null</mark>,
    secret: base32,
    otp: otpauth_url
  }
  user.mfa = mfa
  user.save(done)
}
</code></pre> <p>Now that we&#x2019;ve sorted out the algorithm we&#x2019;ll need to create a shared secret for our users, we can use it when they visit <code class="md-code md-code-inline">/account/security/multifactor</code>. To that end, we might set them up with a new secret whenever they visit this page, or we could store the secret until they click on cancel, we&#x2019;ll leave that up to you to decide. In the bit of code below, we&#x2019;ll set up a new secret on every visit, generate a base64-encoded data URI for the QR code to the <code class="md-code md-code-inline">otpauth://</code> url, and respond with that. Note that it&#x2019;s assumed <code class="md-code md-code-inline">req.user</code> exposes the currently authenticated user document from an ORM like <code class="md-code md-code-inline">mongoose</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> QRCode = <span class="md-code-built_in">require</span>(`qrcode`)

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">controller</span><span class="md-code-params">(req, res, next)</span> </span>{
  setupSecret(req.user, hasSecret)

  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">hasSecret</span><span class="md-code-params">(err)</span> </span>{
    <span class="md-code-keyword">if</span> (err) {
      next(err)
      <span class="md-code-keyword">return</span>
    }

    QRCode.toDataURL(req.user.mfa.otp, gotQrCode)
  }

  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">gotQrCode</span><span class="md-code-params">(err, qr)</span> </span>{
    <span class="md-code-keyword">if</span> (err) {
      next(err)
      <span class="md-code-keyword">return</span>
    }

    <span class="md-code-comment">// render view with QR code and plain text shared secret &#x2026;</span>
  }
}
</code></pre> <p>The next step is to plug in the verification form. I&#x2019;ll leave the details of actually connecting the client to the server to you, and meanwhile I&#x2019;ll focus on the token verification parts.</p> <h1 id="verifying-totp-tokens">Verifying TOTP Tokens</h1> <p>In the following chunk of code we&#x2019;ll take a <code class="md-code md-code-inline">mongoose</code> user document and the user-provided token that we want to validate against the shared secret. If the user doesn&#x2019;t even have an <code class="md-code md-code-inline">mfa</code> field, we&#x2019;ll call that a sanity check that&#x2019;s enough for us to know that they can&#x2019;t verify any tokens at all, since they never even visited <code class="md-code md-code-inline">/account/security/multifactor</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">function verifyToken({ user, token }, done) {
  if (!user.mfa) {
    done(new Error(`User doesn&apos;t have MFA enabled.`))
    return
  }
  // &#x2026;
}
</code></pre> <p>Next, we use <code class="md-code md-code-inline">speakeasy.totp.verify</code> comparing the base32-encoded shared secret we stored on the <code class="md-code md-code-inline">user</code> document with the user-provided token. Note that I&#x2019;ve set a mystifying <code class="md-code md-code-inline">window</code> parameter to <code class="md-code md-code-inline">1</code>. This means that we won&#x2019;t just accept the token for the current 30 second OTP time-step window, but that we&#x2019;ll accept a valid token that matches the last time-step window, too. It&#x2019;s pretty common for anxious users &#x2013; okay, for myself, it&#x2019;s pretty common for myself &#x2013; to start entering tokens into a website when the time-step window is about to close, and by the time the form is submitted a new time-step window kicks in and their perfectly valid token &#x201C;Does Not Meet Expectations&#x201D;. Setting the <code class="md-code md-code-inline">window</code> parameter to <code class="md-code md-code-inline">1</code> will make those kinds of users &#x2013; me &#x2013; a bit happier about the site&#x2019;s UX.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">  &#x2026;

  <span class="md-code-keyword">const</span> success = speakeasy.totp.verify({
    secret: user.mfa.secret,
    encoding: `base32`,
    <span class="md-code-built_in">window</span>: <span class="md-code-number">1</span>, <span class="md-code-comment">// let user enter previous totp token because ux</span>
    token
  })

  &#x2026;
</code></pre> <p>Now, <code class="md-code md-code-inline">success</code> is a boolean value indicating whether the provided token is indeed valid. If the token is invalid, we&#x2019;ll call <code class="md-code md-code-inline">done</code> and bail. When it&#x2019;s valid, there&#x2019;s two branches. If the user is already enrolled in 2FA, we&#x2019;ll consider the verification successful and be done with it. When the user is not yet enrolled, we&#x2019;ll first mark them as enrolled as of this moment, and then call <code class="md-code md-code-inline">done</code> with a successful verification.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">  &#x2026;

  <span class="md-code-keyword">const</span> { enrolled } = user.mfa

  <span class="md-code-keyword">if</span> (!success) {
    finished(<span class="md-code-literal">null</span>)
    <span class="md-code-keyword">return</span>
  }

  <span class="md-code-keyword">if</span> (enrolled) {
    finished(<span class="md-code-literal">null</span>)
    <span class="md-code-keyword">return</span>
  }

  user.mfa.enrolled = <span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>()
  user.markModified(`mfa`)
  user.save(finished)

  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">finished</span><span class="md-code-params">(err)</span> </span>{
    done(err, { success, enrolled })
  }
}
</code></pre> <p>After you hook up the verification function to the form, we can consider the enrollment flow complete. Users can now visit a page that displays a QR code with a link that Google Authenticator and friends understand, and from there they can enter the code, submit the form, and complete their enrollment in our 2FA program.</p> <p>The challenge flow is not all that different from the enrollment flow, except we want to lock the users out of their account after they log in, or when they want to perform sensitive actions. Onto the least fun part.</p> <h1 id="challenge-flow">Challenge Flow</h1> <p>How you implement this side of the 2FA flow is up to you. One way is to avoid provisioning user details on the request object until they&#x2019;ve successfully provided proof of second factor authentication (a valid token).</p> <p>The first step towards that goal is to add a middleware like <code class="md-code md-code-inline">ensureMultifactor</code> right after the user has authenticated on a login form or through an OAuth provider, before they&#x2019;re redirected to where they were going.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">ensureMultifactor</span><span class="md-code-params">(req, res, next)</span> </span>{
  <span class="md-code-keyword">if</span> (!req.user.mfa || !req.user.mfa.enrolled) {
    next()
    <span class="md-code-keyword">return</span>
  }
  req.session.mfaLock = <span class="md-code-literal">true</span>
  res.redirect(`/account/login/multifactor`)
}
</code></pre> <p>For illustration purposes, this is what the middleware chain looks like when logging onto Pony Foo:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">app.post(`/account/login/local`, ensureAnonymous, rememberReturnUrl, loginController, ensureMultifactor, redirect)
</code></pre> <p>This means that when the user posts their credentials to <code class="md-code md-code-inline">/account/login/local</code>:</p> <ul> <li>We ignore them if they&#x2019;re already authenticated</li> <li>We store the <code class="md-code md-code-inline">redirectTo</code> query parameter in the user&#x2019;s session</li> <li>We authenticate the user with their username and password</li> <li>We redirect the user to the 2FA page if they are enrolled in the program</li> <li>If they&#x2019;re not enrolled in 2FA, we redirect them to <code class="md-code md-code-inline">redirectTo</code></li> </ul> <figure><img alt="Upon logging in, the user is challenged to enter their TOTP token before they get access to their account." class="" src="https://i.imgur.com/OERbAfb.png"></figure> <p>The form on the 2FA authentication page should post to something that runs <code class="md-code md-code-inline">verifyToken</code> like we did for the enrollment flow, except it should also remove the lock from the user&#x2019;s session.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">delete</span> req.session.mfaLock
</code></pre> <p>Okay, let&#x2019;s take a step back. The user logs in, we set an <code class="md-code md-code-inline">mfaLock</code> flag on their session and redirect them to the 2FA page. They are free to navigate away, but they won&#x2019;t get rid of the lock unless they pass the challenge, which is when we remove the lock. You might&#x2019;ve noticed that the user is already logged in, even if they are &#x201C;MFA locked&#x201D;, they have this authentication credential that grants them access to all the wrong places. How do we prevent that?</p> <p>I happen to have this route sitting atop Pony Foo&#x2019;s routing layer. I use <code class="md-code md-code-inline">passport</code> to serialize and deserialize the user&#x2019;s <code class="md-code md-code-inline">id</code> onto their session <em>(stored on Redis)</em>. Anyway, once <code class="md-code md-code-inline">passport</code> deserializes the <code class="md-code md-code-inline">id</code> from Redis, this route will look for a few of the user&#x2019;s details such as their name, email, roles, and avatar on MongoDB, and store them under <code class="md-code md-code-inline">req.userObject</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">app.all(`<span class="md-code-comment">/*`, hydrateUserObject)
</span></code></pre> <p>Now, this route relies on <code class="md-code md-code-inline">req.user</code> being the user&#x2019;s <code class="md-code md-code-inline">id</code>. If we were to check whether the session has an MFA lock and act as if there was no authenticated user, the rest of the application wouldn&#x2019;t know any different. Almost too easy!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">hydrateUserObject</span><span class="md-code-params">(req, res, next)</span> </span>{
  <span class="md-code-keyword">if</span> (req.session.mfaLock &amp;&amp; shouldVerifyMultifactor()) {
    req.user = <span class="md-code-literal">null</span> <span class="md-code-comment">// act as if user isn&apos;t authenticated</span>
  }
  &#x2026;
}
</code></pre> <p>Virtually every request should have this check, because otherwise something might believe the user to be fully authenticated even though they didn&#x2019;t pass the challenge flow. There is a single exception, which is that requests to verify the challenge should be treated as authenticated. This is why we have <code class="md-code md-code-inline">shouldVerifyMultifactor</code>: when we get a <code class="md-code md-code-inline">POST /api/account/security/multifactor/verify</code> we don&#x2019;t want to treat the user as unauthenticated, because we&#x2019;ll need to look up their shared secret!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">shouldVerifyMultifactor</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> (
    req.method !== `POST` &amp;&amp;
    req.path !== `/api/account/security/multifactor/verify`
  )
}
</code></pre> <p>Finally, you&#x2019;ll want to let users turn off MFA.</p> <figure><img alt="Maybe provide a candid warning message after they&apos;ve turned it off. Here&apos;s Pony Foo: &amp;quot;You&#x2019;ve disabled MFA. Your account is now less secure.&amp;quot;" class="" src="https://i.imgur.com/TYhpuJy.png"></figure> <p>With the set up I&#x2019;ve presented in this article, all you&#x2019;ll have to do is the following:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">user.mfa = <span class="md-code-literal">null</span>
user.save(next)
</code></pre> <p>That is all there is to a simple MFA setup. Here are some things you can do to take this further if you&#x2019;re planning on implementing 2FA on a serious business and not on a glorified blogging website:</p> <ul> <li>Generate backup codes and email them to your user or provide them as a download option</li> <li>Consider a flow where you send codes via SMS, but then avoid it because <a href="https://twitter.com/justin/status/883171036283285508" target="_blank" rel="noopener noreferrer">it&#x2019;s horribly insecure</a></li> <li>You can learn about some more nuanced parts of 2FA by reading the excellent <a href="https://github.com/speakeasyjs/speakeasy" target="_blank" rel="noopener noreferrer" aria-label="speakeasyjs/speakeasy on GitHub"><code class="md-code md-code-inline">speakeasy</code> documentation</a></li> </ul></div>
