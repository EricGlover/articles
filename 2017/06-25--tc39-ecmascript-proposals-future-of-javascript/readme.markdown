<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/tc39-ecmascript-proposals-future-of-javascript">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/tc39-ecmascript-proposals-future-of-javascript"><div><img src="https://i.imgur.com/W4y3Rby.jpg" alt="TC39, ECMAScript, and the Future of JavaScript"></div></a>

<h1>TC39, ECMAScript, and the Future of JavaScript</h1>

<p><kbd>tc39</kbd> <kbd>ecmascript</kbd> <kbd>standards</kbd> <kbd>talks</kbd> <kbd>presentations</kbd></p>

<blockquote><blockquote>
<p><em>Last week, I gave a presentation at Tencent Frontend Conference in Shenzhen, China. For this article, I&#x2019;ve adapted its transcript.</em></p>
</blockquote>
</blockquote>

<div><blockquote> <p><em>Last week, I gave <a href="https://ponyfoo.com/presentations/tc39-ecmascript-and-the-future-of-javascript">a presentation</a> by the same name as this article at <a href="http://tfc.alloyteam.com/" target="_blank" rel="noopener noreferrer">Tencent Frontend Conference</a> in Shenzhen, China. In this article, I&#x2019;m adapting its transcript to a format more suitable for Pony Foo. I hope you enjoy it!</em></p> </blockquote></div>

<blockquote></blockquote>

<div><h1 id="what-s-tc39">What&#x2019;s TC39?</h1> <p>TC39 means Technical Committee number 39. It&#x2019;s part of ECMA, the institution which standardizes the JavaScript language under the &#x201C;ECMAScript&#x201D; specification.</p> <p>The ECMAScript specification defines how JavaScript works on a discrete step-by-step basis. Among other things, the specification explains:</p> <ul> <li>how the string <code class="md-code md-code-inline">&apos;A&apos;</code> is <code class="md-code md-code-inline">NaN</code></li> <li>how the string <code class="md-code md-code-inline">&apos;A&apos;</code> <em>is not equal</em> to <code class="md-code md-code-inline">NaN</code></li> <li>how <code class="md-code md-code-inline">NaN</code> is <code class="md-code md-code-inline">NaN</code> but <em>is not equal</em> to <code class="md-code md-code-inline">NaN</code></li> <li>and why introducing <code class="md-code md-code-inline">Number.isNaN</code> was obviously a very good idea&#x2026;</li> </ul> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">isNaN</span>(<span class="md-code-literal">NaN</span>) <span class="md-code-comment">// true</span>
<span class="md-code-built_in">isNaN</span>(<span class="md-code-string">&apos;A&apos;</span>) <span class="md-code-comment">// true</span>
<span class="md-code-string">&apos;A&apos;</span> == <span class="md-code-literal">NaN</span> <span class="md-code-comment">// false</span>
<span class="md-code-string">&apos;A&apos;</span> === <span class="md-code-literal">NaN</span> <span class="md-code-comment">// false</span>
<span class="md-code-literal">NaN</span> === <span class="md-code-literal">NaN</span> <span class="md-code-comment">// false</span>

<span class="md-code-comment">// &#x2026; solution!</span>

<span class="md-code-built_in">Number</span>.isNaN(<span class="md-code-string">&apos;A&apos;</span>) <span class="md-code-comment">// false</span>
<span class="md-code-built_in">Number</span>.isNaN(<span class="md-code-literal">NaN</span>) <span class="md-code-comment">// true</span>
</code></pre> <p>It explains details about <em>when</em> positive zero is equal to negative zero <em>&#x2013; and when it isn&#x2019;t&#x2026;</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript">+<span class="md-code-number">0</span> == -<span class="md-code-number">0</span> <span class="md-code-comment">// true</span>
+<span class="md-code-number">0</span> === -<span class="md-code-number">0</span> <span class="md-code-comment">// true</span>
<span class="md-code-number">1</span>/+<span class="md-code-number">0</span> === <span class="md-code-number">1</span> / -<span class="md-code-number">0</span> <span class="md-code-comment">// false</span>
</code></pre> <p>And they also make other jewels possible, such as encoding any valid JavaScript expression using only exclamation points, parenthesis, square brackets, and plus signs. Check out <a href="http://jsfuck.com/" target="_blank" rel="noopener noreferrer">JSFuck</a> to learn more about how to write any JavaScript using <code class="md-code md-code-inline">+!()[]</code>.</p> <p><em>But, in all seriousness, the thankless work done by TC39 is <strong>invaluable</strong>.</em></p></div>

<div><p>TC39 follows a process to develop language features that&#x2019;s based on maturity stages. Once a proposal is mature enough, TC39 updates the specification with the changes presented in the proposal. Up until recently, TC39 relied on an older flow based on Microsoft Word. But after ES3 came out, they spent <strong>ten years with virtually no changes</strong> making their way to the specification. After that, it took them <em>another four years</em> for ES6 to materialize.</p> <blockquote> <p>It became evident that their process had to improve.</p> </blockquote> <p>Since ES6 came out, they streamlined the proposal revisioning process to meet modern expectations. The new process uses a superset of HTML to format the proposals. They use <a href="https://github.com/tc39/proposals" target="_blank" rel="noopener noreferrer" aria-label="tc39/proposals on GitHub">GitHub pull requests</a>, which helped boost participation from the community and the number of proposals being made also increased. The specification is now more of a <a href="https://tc39.github.io/ecma262" target="_blank" rel="noopener noreferrer" aria-label="The Living Standard is at tc39.github.io/ecma262">living standard</a>, meaning that proposals see adoption faster, and we don&#x2019;t spend years waiting for a new edition of the specification to come out.</p> <p>The new process involves four different maturity stages. The more mature a proposal is, the more likely it is to eventually make it into the specification.</p> <h1 id="stage-0">Stage 0</h1> <p>Any discussion, idea, change, or addition which has not yet been submitted as a formal proposal is considered to be a &#x201C;strawman&#x201D; proposal at Stage 0. Only members of TC39 can create these proposals, and there&#x2019;s over a dozen active strawman proposals today.</p> <p>Proposals currently in Stage 0 include <a href="https://github.com/tc39/proposal-cancellation" target="_blank" rel="noopener noreferrer">cancellation tokens</a> for asynchronous operations, <a href="https://github.com/domenic/zones" target="_blank" rel="noopener noreferrer">Zones</a> as the ones originally hailed by the Angular team, along with many proposals that never made it into Stage 1.</p> <p>Later in this article, we&#x2019;ll take a closer look at individual proposals.</p> <h1 id="stage-1">Stage 1</h1> <p>At Stage 1 a proposal is formalized and expected to address cross-cutting concerns, interactions with other proposals, and implementation concerns. Proposals in this stage identify a discrete problem and offer a concrete solution to that problem.</p> <p>A Stage 1 proposal often includes a high level API description, usage examples and a discussion of internal semantics and algorithms. These proposals are <em>likely to change significantly</em> as they make their way through the process.</p> <p>Examples of proposals currently in Stage 1 include: <a href="https://ponyfoo.com/articles/observables-coming-to-ecmascript" aria-label="Observables Proposal for ECMAScript! on Pony Foo">Observable</a>, <a href="https://ponyfoo.com/articles/proposal-statements-as-expressions-using-do" aria-label="Proposal: &#x201C;Statements as Expressions&#x201D; using do on Pony Foo"><code class="md-code md-code-inline">do</code></a> expressions, generator arrow functions, and <a href="https://github.com/tc39/proposal-promise-try" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">Promise.try</code></a>.</p> <h1 id="stage-2">Stage 2</h1> <p>Proposals in Stage 2 should offer an initial draft of the specification.</p> <p>At this point, it&#x2019;s reasonable for implementers to begin experimenting with actual implementations in runtimes. The implementation could come in the form of a polyfill, user code that mangles the runtime into adhering to the proposal; an engine implementation, which natively provides support for the proposal; or it could be support by a build-time compiler like Babel.</p> <p>In Stage 2 we currently have <a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener noreferrer">public class fields</a>, <a href="https://medium.com/the-thinkmill/javascripts-new-private-class-fields-93106e37647a" target="_blank" rel="noopener noreferrer">private class fields</a>, <a href="https://ponyfoo.com/articles/javascript-decorators-proposal" aria-label="ECMAScript Proposal for JavaScript Decorators on Pony Foo">decorators</a>, and <a href="https://github.com/tc39/proposal-promise-finally" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">Promise#finally</code></a>, to name a few.</p> <h1 id="stage-3">Stage 3</h1> <p>Proposals in Stage 3 are candidate recommendations. At this advanced stage, the specification editor and designated reviewers must have signed off on the final specification. A Stage 3 proposal is unlikely to change beyond fixes to issues identified in the wild.</p> <p>Implementors should have expressed interest in the proposal as well &#x2014; a proposal without support from implementors is dead in the water. In practice, proposals move to this level with at least one browser implementation, a high-fidelity polyfill or when supported by a build-time transpiler like Babel.</p> <p>Stage 3 has exciting features like <a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener noreferrer">object rest and spread</a>, <a href="https://ponyfoo.com/articles/javascript-asynchronous-iteration-proposal">asynchronous iteration</a>, the <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">import()</code></a> method, and <a href="https://ponyfoo.com/articles/regular-expressions-post-es6">better Unicode support</a> for regular expressions.</p> <h1 id="stage-4">Stage 4</h1> <p>Finally, proposals get to Stage 4 when there are at least two independent implementations that pass acceptance tests.</p> <p>Proposals that make their way through to stage four will be included in the next revision of ECMAScript.</p> <p><a href="https://ponyfoo.com/articles/understanding-javascript-async-await">Async functions</a>, <a href="https://github.com/tc39/Array.prototype.includes/" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">Array#includes</code></a>, and the <a href="https://github.com/rwaldron/exponentiation-operator" target="_blank" rel="noopener noreferrer">exponentiation operator</a> are some examples that made it to stage 4 since the revision process was overhauled.</p> <h1 id="staying-up-to-date">Staying Up To Date</h1> <p>I made a website that shows a list of currently active proposals. It describes what stage they&#x2019;re in and links to each proposal so that you can learn more about them.</p> <p>It lives at <a href="https://prop-tc39.now.sh/" target="_blank" rel="noopener noreferrer">prop-tc39.now.sh</a>.</p> <p>New formal specification releases are now expected every year, but the streamlined process also means formal releases are becoming less relevant. The focus is now on proposal stages, and we can expect references to specific revisions of the standard to become uncommon after ES6.</p> <h1 id="proposals">Proposals</h1> <p>Let&#x2019;s look at some of the most interesting proposals that are currently in development.</p> <h2 id="array-includes-stage-4"><code class="md-code md-code-inline">Array#includes</code> (Stage 4)</h2> <p>Before <code class="md-code md-code-inline">Array#includes</code> was introduced, we had to rely on <code class="md-code md-code-inline">Array#indexOf</code> and checking whether the index was out of bounds to figure out whether an element belonged to an array.</p> <p>With <code class="md-code md-code-inline">Array#includes</code> now in stage 4, we can use that instead. It complements <code class="md-code md-code-inline">Array#find</code> and <code class="md-code md-code-inline">Array#findIndex</code>, which were introduced in ES6.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>].indexOf(<span class="md-code-number">2</span>) !== -<span class="md-code-number">1</span> <span class="md-code-comment">// true</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>].indexOf(<span class="md-code-number">3</span>) !== -<span class="md-code-number">1</span> <span class="md-code-comment">// false</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>].includes(<span class="md-code-number">2</span>) <span class="md-code-comment">// true</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>].includes(<span class="md-code-number">3</span>) <span class="md-code-comment">// false</span>
</code></pre> <h2 id="async-functions-stage-4">Async Functions (Stage 4)</h2> <p>When working with promises, we often think in terms of execution threads where we have an async task, like <code class="md-code md-code-inline">fetch</code>, and other tasks which depend on the response, but are blocked until that data is received.</p> <p>In the following example we&#x2019;re fetching a list of products from our API, which returns a <code class="md-code md-code-inline">Promise</code>. This promise will resolve with the response to our request. We then read the response stream as JSON and update a view with data from the response. If any errors happened during this process, we could log them to the console, to understand what&#x2019;s going on.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;/api/products&apos;</span>)
  .then(response =&gt; response.json())
  .then(data =&gt; {
    updateView(data)
  })
  .catch(err =&gt; {
    <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;Update failed&apos;</span>, err)
  })
</code></pre> <p>Async functions are sugar that can be used to improve how we write Promise-based code. Let&#x2019;s start transforming our promise-based code line-by-line. We can prefix any expression using the <code class="md-code md-code-inline">await</code> keyword. When we <code class="md-code md-code-inline">await</code> on a promise, we get an expression that evaluates to that promise&#x2019;s fulfillment value.</p> <p>Promises gave a meaning to our code that was like &#x201C;I want to run this operation, and <em>then</em> I want to use its result within this other operation&#x201D;.</p> <p>Meanwhile, <code class="md-code md-code-inline">await</code> effectively inverts that meaning, making it more like &#x201C;I want to get back the result of this operation&#x201D;, which I like, because it sounds simpler.</p> <p>In our example, the response object is what we&#x2019;re after, so we&#x2019;ll flip things over and assign the result of <code class="md-code md-code-inline">await fetch</code> to the <code class="md-code md-code-inline">response</code> variable, instead of using a promise reaction.</p> <pre class="md-code-block"><code class="md-code md-lang-diff"><span class="md-code-addition">+ const response = await fetch(&apos;/api/products&apos;)</span>
<span class="md-code-deletion">- fetch(&apos;/api/products&apos;)</span>
    .then(response =&gt; response.json())
    .then(data =&gt; {
      updateView(data)
    })
    .catch(err =&gt; {
      console.log(&apos;Update failed&apos;, err)
    })
</code></pre> <p>We give <code class="md-code md-code-inline">response.json()</code> the same treatment. We <code class="md-code md-code-inline">await</code> on its promise and assign that to the <code class="md-code md-code-inline">data</code> variable.</p> <pre class="md-code-block"><code class="md-code md-lang-diff">  const response = await fetch(&apos;/api/products&apos;)
<span class="md-code-addition">+ const data = await response.json()</span>
<span class="md-code-deletion">-   .then(response =&gt; response.json())</span>
    .then(data =&gt; {
      updateView(data)
    })
    .catch(err =&gt; {
      console.log(&apos;Update failed&apos;, err)
    })
</code></pre> <p>Now that the reactions are gone, <code class="md-code md-code-inline">updateView</code> is its own statement, since we don&#x2019;t need to await on any other promises, given we&#x2019;ve reached the end of our old promise chain.</p> <pre class="md-code-block"><code class="md-code md-lang-diff">  const response = await fetch(&apos;/api/products&apos;)
  const data = await response.json()
<span class="md-code-addition">+ updateView(data)</span>
<span class="md-code-deletion">-   .then(data =&gt; {</span>
<span class="md-code-deletion">-     updateView(data)</span>
<span class="md-code-deletion">-   })</span>
    .catch(err =&gt; {
      console.log(&apos;Update failed&apos;, err)
    })
</code></pre> <p>We can now just use <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> blocks instead of the <code class="md-code md-code-inline">.catch</code> reaction we used in the promise-based code, leading us to more semantic code.</p> <pre class="md-code-block"><code class="md-code md-lang-diff"><span class="md-code-addition">+ try {</span>
    const response = await fetch(&apos;/api/products&apos;)
    const data = await response.json()
    updateView(data)
<span class="md-code-addition">+ } catch(err) {</span>
<span class="md-code-deletion">- .catch(err =&gt; {</span>
    console.log(&apos;Update failed&apos;, err)
<span class="md-code-addition">+ }</span>
<span class="md-code-deletion">- )}</span>
</code></pre> <p>One limitation is that <code class="md-code md-code-inline">await</code> only works inside async functions.</p> <pre class="md-code-block"><code class="md-code md-lang-diff"><span class="md-code-addition">+ async function run() {</span>
    try {
      const response = await fetch(&apos;/api/products&apos;)
      const data = await response.json()
      updateView(data)
    } catch(err) {
      console.log(&apos;Update failed&apos;, err)
    }
<span class="md-code-addition">+ }</span>
</code></pre> <p>We could, however, turn our async function into a self-invoking function expression. If we wrap our top-level code in an expression like this, we can use <code class="md-code md-code-inline">await</code> expressions anywhere in our codebase.</p> <p>Some of the community wants native top level await, while some others think it would have a negative effect in user-land, making it all too easy for libraries to block on asynchronous operations while loading, considerably slowing down the load time of our applications.</p> <pre class="md-code-block"><code class="md-code md-lang-diff"><span class="md-code-addition">+ (async () =&gt; {</span>
<span class="md-code-deletion">- async function run() {</span>
    try {
      const response = await fetch(&apos;/api/products&apos;)
      const data = await response.json()
      updateView(data)
    } catch(err) {
      console.log(&apos;Update failed&apos;, err)
    }
<span class="md-code-addition">+ })()</span>
<span class="md-code-deletion">- }</span>
</code></pre> <p>Personally, I think there&#x2019;s more than enough room already to do silly things in the JavaScript performance space, and libraries that block initialization with <code class="md-code md-code-inline">await</code> will never thrive and become popular.</p> <p>Note that you could also <code class="md-code md-code-inline">await</code> on non-promise values, even writing code like <code class="md-code md-code-inline">await (2 + 3)</code>. In this case, the result of the <code class="md-code md-code-inline">(2 + 3)</code> expression is boxed in a promise, and that promise&#x2019;s fulfillment value, which is <code class="md-code md-code-inline">5</code>, becomes the result of the <code class="md-code md-code-inline">await</code> expression.</p> <p>Note that <code class="md-code md-code-inline">await</code> plus any JavaScript expression is also an expression. This means we aren&#x2019;t limited to awaiting for values that get assigned to variables, but that we can also, for instance, <code class="md-code md-code-inline">await</code> on a function call as part of a template literal interpolation.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">`Price: ${ await getPrice() }`
</code></pre> <p>Or as part of another function call&#x2026;</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">renderView(await getPrice())
</code></pre> <p>Or even as part of a mathematical equation.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-number">2</span> * (await getPrice())
</code></pre> <p>Finally, regardless of their contents, async functions <strong>always return a promise</strong>. This means we can add <code class="md-code md-code-inline">.then</code> or <code class="md-code md-code-inline">.catch</code> reactions to an async function, and it also means we can <code class="md-code md-code-inline">await</code> on its result.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> sleep = delay =&gt; <span class="md-code-keyword">new</span> Promise(resolve =&gt;
  setTimeout(resolve, delay)
)
<span class="md-code-keyword">const</span> slowLog = async (...terms) =&gt; {
  await sleep(<span class="md-code-number">2000</span>)
  <span class="md-code-built_in">console</span>.log(...terms)
}
slowLog(<span class="md-code-string">&apos;Well that was underwhelming&apos;</span>)
  .then(() =&gt; <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;Nailed it!&apos;</span>))
  .catch(reason =&gt; <span class="md-code-built_in">console</span>.error(<span class="md-code-string">&apos;Failed&apos;</span>, reason))
</code></pre> <p>As you would expect, the returned promise settles with the value returned from the async function, or is rejected with any uncaught exceptions that arised inside the async function.</p> <h2 id="async-iteration-stage-3">Async Iteration (Stage 3)</h2> <p>Moving onto Stage 3, we have async iteration. Before diving into it, let&#x2019;s talk briefly about <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo">iterables</a>, which were introduced in ES6. An iterable can be any object which adheres to the iterator protocol.</p> <p>To make an object iterable, we define a <code class="md-code md-code-inline">Symbol.iterator</code> method. The iterator method should return an object that has a <code class="md-code md-code-inline">next</code> method. This object describes the sequence for our iterable. When an object is being iterated, the <code class="md-code md-code-inline">next</code> method will be called each time we need to read the next element in the sequence. Each <code class="md-code md-code-inline">value</code> from the returned objects is used to construct the sequence. When the returned object is marked as <code class="md-code md-code-inline">done</code>, the sequence ends.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> list = {
  <mark class="md-mark md-code-mark">[Symbol.iterator]</mark>() {
    <span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>
    <span class="md-code-keyword">return</span> {
      next: () =&gt; ({
        value: i++,
        done: i &gt; <span class="md-code-number">5</span>
      })
    }
  }
}
[...list]
<span class="md-code-comment">// &lt;- [0, 1, 2, 3, 4]</span>
<span class="md-code-built_in">Array</span>.from(list)
<span class="md-code-comment">// &lt;- [0, 1, 2, 3, 4]</span>
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">const</span> i of list) {
  <span class="md-code-comment">// &lt;- 0, 1, 2, 3, 4</span>
}
</code></pre> <p>Iterables can be consumed all at once with <code class="md-code md-code-inline">Array.from</code> or by using the spread operator. They can also be consumed element by element using a <code class="md-code md-code-inline">for..of</code> loop.</p> <p>Async iterators are only a little bit different. Under this proposal, an object can use <code class="md-code md-code-inline">Symbol.asyncIterator</code> to advertise that they are iterable asynchronously. The contract for an async iterator is only slightly different from that for a regular iterator: the <code class="md-code md-code-inline">next</code> method needs to return a <code class="md-code md-code-inline">Promise</code> for a <code class="md-code md-code-inline">{ value, done }</code> pair instead of returning <code class="md-code md-code-inline">{ value, done }</code> directly.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> list = {
  [Symbol.asyncIterator]() {
    <span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>
    <span class="md-code-keyword">return</span> {
      next: () =&gt; Promise.resolve({
        value: i++,
        done: i &gt; <span class="md-code-number">5</span>
      })
    }
  }
}
</code></pre> <p>This simple change is sufficient and elegant, since promises can easily represent the eventual elements of the sequence.</p> <p>An async iterable can&#x2019;t be consumed with the array spread operator, nor with <code class="md-code md-code-inline">Array.from</code>, nor with <code class="md-code md-code-inline">for..of</code>, since all three were exclusively purpose-built for synchronous iteration.</p> <p>This proposal introduces a new <code class="md-code md-code-inline">for await..of</code> construct as well. It can be used to semantically iterate over an asynchronously iterable sequence.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> await (<span class="md-code-keyword">const</span> i of items) {
  <span class="md-code-comment">// &lt;- 0, 1, 2, 3, 4</span>
}
</code></pre> <p>Note that the <code class="md-code md-code-inline">for await..of</code> construct can only be used inside async functions. Otherwise we&#x2019;ll get syntax errors. Just like with any other async functions, we could also use <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> blocks around or inside our <code class="md-code md-code-inline">for await..of</code> loops.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">async <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">readItems</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">for</span> await (<span class="md-code-keyword">const</span> i of items) {
    <span class="md-code-comment">// &lt;- 0, 1, 2, 3, 4</span>
  }
}
</code></pre> <p>The rabbit hole goes deeper of course. There&#x2019;s also async generator functions. These are somewhat similar to plain generator functions, except async generator functions support <code class="md-code md-code-inline">async</code> <code class="md-code md-code-inline">await</code> semantics, allowing <code class="md-code md-code-inline">await</code> statements as well as <code class="md-code md-code-inline">for await..of</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">async <span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">getProducts</span><span class="md-code-params">(categoryUrl)</span> </span>{
  <span class="md-code-keyword">const</span> listReq = await fetch(categoryUrl)
  <span class="md-code-keyword">const</span> list = await listReq.json()
  <span class="md-code-keyword">for</span> (<span class="md-code-keyword">const</span> product of list) {
    <span class="md-code-keyword">const</span> productReq = await fetch(product.url)
    <span class="md-code-keyword">const</span> product = await productReq.json()
    <span class="md-code-keyword">yield</span> product
  }
}
</code></pre> <p>Inside async generator functions, we can use <code class="md-code md-code-inline">yield*</code> with other async generators and with plain generators as well. When invoked, async generator functions return async generator objects, whose methods return promises for <code class="md-code md-code-inline">{ value, done }</code> pairs, instead of the plain <code class="md-code md-code-inline">{ value, done }</code> pairs returned by plain generators.</p> <p>Finally, an async generator object can be consumed with <code class="md-code md-code-inline">for await..of</code>, just like an async iterable. This is because async generator objects are async iterables, just like plain generator objects are plain iterables.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">async <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">readProducts</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">const</span> g = getProducts(category)
  <span class="md-code-keyword">for</span> await (<span class="md-code-keyword">const</span> product of g) {
    <span class="md-code-comment">// use product details</span>
  }
}
</code></pre> <h2 id="object-rest-and-spread-stage-3">Object Rest and Spread (Stage 3)</h2> <p>Starting with ES6, we can use <code class="md-code md-code-inline">Object.assign</code> to copy the properties from one or more source objects onto one target object. In the next example we&#x2019;re copying a few properties onto an empty object, and getting that same object back.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Object</span>.assign(
 {},
 { a: <span class="md-code-string">&apos;a&apos;</span> },
 { b: <span class="md-code-string">&apos;b&apos;</span> },
 { a: <span class="md-code-string">&apos;c&apos;</span> }
)
</code></pre> <p>The object spread proposal allows us to write equivalent code using plain syntax. We start with an empty object where <code class="md-code md-code-inline">Object.assign</code> is implicitly buried in the syntax. Every object we spread onto an object literal acts as a source for assigning its own properties to that object literal.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">{
 ...{ a: <span class="md-code-string">&apos;a&apos;</span> },
 ...{ b: <span class="md-code-string">&apos;b&apos;</span> },
 ...{ a: <span class="md-code-string">&apos;c&apos;</span> }
}
<span class="md-code-comment">// &lt;- { a: &apos;c&apos;, b: &apos;b&apos; }</span>
</code></pre> <p>There&#x2019;s also a rest counterpart to object spread, just like with spread in arrays and rest parameters. When destructuring an object, we can use the object spread operator to destructure any own properties not explicitly named in the pattern into another object.</p> <p>In the following example, the <code class="md-code md-code-inline">id</code> is explicitly named and will not be included in the rest object. Object rest can be read literally as <em>&#x201C;everything else goes to an object named rest&#x201D;</em>, and of course, the variable name is for you to choose.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> item = {
 id: <span class="md-code-string">&apos;4fe09c27&apos;</span>,
 name: <span class="md-code-string">&apos;Banana&apos;</span>,
 amount: <span class="md-code-number">3</span>
}
<span class="md-code-keyword">const</span> { id, ...rest } = item
<span class="md-code-comment">// &lt;- { name: &apos;Banana&apos;, amount: 3 }</span>
</code></pre> <p>When destructuring an object in a function&#x2019;s parameter list, we can use object rest as well.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">print</span><span class="md-code-params">({ id, ...rest })</span> </span>{
  <span class="md-code-built_in">console</span>.log(rest)
}
print({ id: <span class="md-code-string">&apos;4fe09c27&apos;</span>, name: <span class="md-code-string">&apos;Banana&apos;</span> })
<span class="md-code-comment">// &lt;- { name: &apos;Banana&apos; }</span>
</code></pre> <h2 id="dynamic-import-stage-3">Dynamic <code class="md-code md-code-inline">import()</code> (Stage 3)</h2> <p>ES6 introduced native JavaScript modules. Unlike CommonJS and similar, JavaScript modules opted for static statements. Tooling has an easier time analyzing and building dependency trees out of static source code, which makes it a great default.</p> <pre class="md-code-block"><code class="md-code">import markdown from &apos;./markdown&apos;
// &#x2026;
export default compile
</code></pre> <p>However, as developers we don&#x2019;t always know the modules we need to import ahead of time. For these cases, such as when we depend on localization to load a module with strings under the user&#x2019;s language, the dynamic <code class="md-code md-code-inline">import()</code> proposal in Stage 3 comes into play.</p> <p>Dynamic <code class="md-code md-code-inline">import()</code> loads modules at runtime. It returns a promise for the module&#x2019;s namespace object, which resolves after fetching, parsing, and executing the requested module and all of its dependencies. If the module fails to load, the promise will be rejected.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import(`./i18n.${ navigator.language }.js`)
  .then(<span class="md-code-built_in">module</span> =&gt; <span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">module</span>.messages))
  .catch(reason =&gt; <span class="md-code-built_in">console</span>.error(reason))
</code></pre> <h2 id="named-captures-stage-3">Named Captures (Stage 3)</h2> <p>Regular expressions are not that hard to write, but they&#x2019;re many times harder to read. The expression on the next bit of code can be used to capture parts of a URL. I took the liberty of adding non-normative spaces and line breaks so that the expression isn&#x2019;t as daunting to read, feel free to remove these if you want to try out the regular expression.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">const urlRegExp = /
  ^
  (?:(http[s]?|ftp):\/)?
  \/?
  ([^:\/\s]+)
  ((?:\/\w+)*\/)
  ([\w\-\.]+[^#?\s]+)
  ([^#]*)?
  (#[\w\-]+)?
  $
/
</code></pre> <p>Which parts are captured? Well, you&#x2019;ll probably have to try a few matches to figure that out. Or maybe you can put the regular expression through <a href="http://bit.ly/2rPIotw" target="_blank" rel="noopener noreferrer" aria-label="Regexper is my favorite tool to explore regular expressions">a tool that tells you what it does</a>.</p> <p>The named captures proposal allows us to name capture groups so that expressions become a little bit easier to read and use.</p> <p>In the following piece, the highlighted parts are the names I gave to each interesting capture group in the expression. Note I had to turn on the Unicode flag <code class="md-code md-code-inline">/u</code> in order to use named captures.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">const urlRegExp = /
  ^
  (?:(<mark class="md-mark md-code-mark">?&lt;protocol&gt;</mark>http[s]?|ftp):\/)?
  \/?
  (<mark class="md-mark md-code-mark">?&lt;host&gt;</mark>[^:\/\s]+)
  (<mark class="md-mark md-code-mark">?&lt;path&gt;</mark>(?:\/\w+)*\/)
  (<mark class="md-mark md-code-mark">?&lt;file&gt;</mark>[\w\-\.]+[^#?\s]+)
  (<mark class="md-mark md-code-mark">?&lt;query&gt;</mark>[^#]*)?
  (<mark class="md-mark md-code-mark">?&lt;hash&gt;</mark>#[\w\-]+)?
  $
/u
</code></pre> <p>Reading the expression is a little better now that the important groups have names.</p> <p>When matching against a regular expression, the resulting array will now also contain a <code class="md-code md-code-inline">groups</code> property with key/value pairs matching each of the groups named in the regular expression.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> url = <span class="md-code-string">&apos;https://commits.com/8b48e3/diff?w=1#readme&apos;</span>
<span class="md-code-keyword">const</span> { groups } = urlRegExp.exec(url)
</code></pre> <p>The snippet shown above produces the following object:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">{
  protocol: <span class="md-code-string">&apos;https&apos;</span>,
  host: <span class="md-code-string">&apos;commits.com&apos;</span>,
  path: <span class="md-code-string">&apos;/8b48e3/&apos;</span>,
  file: <span class="md-code-string">&apos;diff&apos;</span>,
  query: <span class="md-code-string">&apos;?w=1&apos;</span>,
  hash: <span class="md-code-string">&apos;#readme&apos;</span>
}
</code></pre> <p>When doing <code class="md-code md-code-inline">String#replace</code>, we can use named capture groups instead of numbered capture groups, making our code easier to follow than if we used indices. Our code is now less brittle too, because new capturing groups might change the indices of the captures we care about, they won&#x2019;t affect their names.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> url = <span class="md-code-string">&apos;https://commits.com/8b48e3/diff?w=1#readme&apos;</span>
<span class="md-code-keyword">const</span> pattern = <span class="md-code-string">&apos;$&lt;protocol&gt;://github.com/$&lt;file&gt;&apos;</span>
<span class="md-code-keyword">const</span> replaced = url.replace(urlRegExp, pattern)
<span class="md-code-built_in">console</span>.log(replaced)
<span class="md-code-comment">// &lt;- &apos;https://github.com/diff&apos;</span>
</code></pre> <p>Named captures can be reused to capture the same pattern later in the same regular expression, just like we could do with numbered backreferences.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> duplicateRegExp = <span class="md-code-regexp">/^(.*)=\1$/</span>
<span class="md-code-keyword">const</span> duplicateRegExp = <span class="md-code-regexp">/^(?&lt;thing&gt;.*)=\k&lt;thing&gt;$/u</span>
duplicateRegExp.test(<span class="md-code-string">&apos;a=b&apos;</span>) <span class="md-code-comment">// &lt;- false</span>
duplicateRegExp.test(<span class="md-code-string">&apos;a=a&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
duplicateRegExp.test(<span class="md-code-string">&apos;aa=a&apos;</span>) <span class="md-code-comment">// &lt;- false</span>
duplicateRegExp.test(<span class="md-code-string">&apos;bbb=bbb&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
</code></pre> <h2 id="unicode-escapes-stage-3">Unicode Escapes (Stage 3)</h2> <p>The Unicode escapes proposal adds a pattern to test whether the input has a certain Unicode property value. It can be used to match certain Unicode properties of a symbol, such as the Script that symbol belongs to.</p> <p>The examples in the next piece of code show how you can use the lowercase <code class="md-code md-code-inline">\p</code> escape to test whether <code class="md-code md-code-inline">&#x3C0;</code> is a greek symbol. The uppercase <code class="md-code md-code-inline">\P</code> escape negates the condition: in the example, it matches everything except for greek symbols.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">/^\p{Script=Greek}$/u.test(<span class="md-code-string">&apos;&#x3C0;&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
/^\P{Script=Greek}$/u.test(<span class="md-code-string">&apos;&#x3C0;&apos;</span>)
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <h2 id="lookbehind-assertions-stage-3">Lookbehind Assertions (Stage 3)</h2> <p>Lookbehind assertions test whether a pattern is matched to the left of the current position. They look like the highlighted patterns in the code snippet, which test against the Yuan symbol.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">/\d+/.test(&apos;&#xA5;1245&apos;) // &lt;- true
/<mark class="md-mark md-code-mark">(?&lt;=&#xA5;)</mark>\d+/.test(&apos;&#xA5;1245&apos;) // &lt;- true
/<mark class="md-mark md-code-mark">(?&lt;=&#xA5;)</mark>\d+/.test(&apos;$1245&apos;) // &lt;- false
/<mark class="md-mark md-code-mark">(?&lt;!&#xA5;)</mark>\d+/.test(&apos;&#xA5;1245&apos;) // &lt;- false
/<mark class="md-mark md-code-mark">(?&lt;!&#xA5;)</mark>\d+/.test(&apos;$1245&apos;) // &lt;- true
</code></pre> <p>The less than means this is a lookbehind expression and not a lookahead. The equals sign means this is a <em>positive</em> lookbehind assertion. If the pattern is matched then the regular expression will match. In the first example the Yuan is matched in the input, so the positive lookbehind assertion succeeds. In the second, the Yuan is not matched and the assertion fails.</p> <p>When the equals sign is an exclamation point instead <em>&#x2013; like in the third and fourth highlighted examples &#x2013;</em> then the assertion would be a <em>negative</em> lookbehind. It will match when the pattern is not matched.</p> <h2 id="class-decorators-stage-2">Class Decorators (Stage 2)</h2> <p>Decorators are in Stage 2. They can be applied to classes or to statically defined properties of classes.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">@pure
@decorators.elastic()
<span class="md-code-keyword">class</span> View {
  @throttle(<span class="md-code-number">200</span>)
  reconcile() {
  }
}
</code></pre> <p>Decorators are implemented as a function and can be used to make a property readonly or wrap a method with error-logging.</p> <p>Here we have a <code class="md-code md-code-inline">readonly</code> decorator which simply transforms the descriptor to be nonwritable. When we decorate a property as <code class="md-code md-code-inline">@readonly</code> it will become non-writable.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">readonly</span><span class="md-code-params">({ descriptor, ...rest })</span> </span>{
  <span class="md-code-keyword">return</span> {
    ...rest,
    descriptor: {
      ...descriptor,
      writable: <span class="md-code-literal">false</span>
    }
  }
}
</code></pre> <h2 id="promise-finally-stage-2"><code class="md-code md-code-inline">Promise#finally</code> (Stage 2)</h2> <p>Finally, the last proposal we&#x2019;ll discuss is <code class="md-code md-code-inline">Promise#finally</code>. This proposal is very simple. It helps us avoid repetition when we want to run a callback after a promise settles, regardless of whether it resolved or was rejected.</p> <p>We can think of <code class="md-code md-code-inline">Promise#finally(fn)</code> as the equivalent of <code class="md-code md-code-inline">Promise#then(fn, fn)</code>, except <code class="md-code md-code-inline">Promise#finally</code> does not receive any arguments.</p> <pre class="md-code-block"><code class="md-code md-lang-diff">  showSpinner()
  fetch(productUrl)
    .then(renderProduct)
<span class="md-code-addition">+   .finally(</span>
<span class="md-code-deletion">-   .then(</span>
<span class="md-code-deletion">-     hideSpinner,</span>
      hideSpinner
    )
</code></pre> <h1 id="future-of-javascript">Future of JavaScript</h1> <p>TC39 is currently working on over 30 active proposals. What else does the future hold in store?</p> <p>These days we download our packages from npm. We use webpack to manage the complexity of our applications. We use Babel to get the latest language features. We use tools like <code class="md-code md-code-inline">uglifyjs</code> and <code class="md-code md-code-inline">rollup</code> to optimize the size of our payloads. We use <code class="md-code md-code-inline">eslint</code> and <code class="md-code md-code-inline">prettier</code> to uphold code quality and a consistent coding style. We use Node.js and Electron to run our JavaScript code everywhere.</p> <h2 id="transpilation-and-the-ecmascript-standard">Transpilation and the ECMAScript Standard</h2> <p>All of ES6 will soon be available in the majority of runtime engines, but thanks to Babel we&#x2019;ve been using ES6 features for a long time already. Babel has long started evolving away from being just an ES6 compiler: today, you can play around with most late stage proposals thanks to Babel plugins. As browser support for ES6 becomes more prominent, we can expect Babel to stop transpiling ES6 features. By that time, we&#x2019;ll already be using newer features like async functions or class decorators, that will still need transpiling.</p> <p>In this sense, we can think of transpilation as a moving window where we transpile only the absolute necessary in order to maximize browser support for production. A key aspect of modern web development is evergreen browsers, which auto-update. Auto-updating browsers keep Babel thin. As browsers rush to implement the latest features, there&#x2019;s less code for Babel to transpile. However, Babel still plays a key role as well, by providing easy access to proposals while they&#x2019;re in development.</p> <p>This simplifies the feedback loop between practising web developers and implementors, preventing proposals from being developed in a vacuum.</p> <h2 id="linting-and-code-quality">Linting and Code Quality</h2> <p>In the past we had linters like JSLint and JSHint, which were a little too concerned with enforcing a coding style. ESLint arose as a solution which is entirely configurable, allowing us to control exactly which aspects of our codebase we want linted in addition to syntax errors.</p> <p>In the future, we can expect more innovative tools like Prettier, which automatically formats our code to follow a certain coding style, making it consistent throughout the codebase.</p> <h2 id="bundling-bloat-and-complexity">Bundling, Bloat, and complexity</h2> <p>By bringing true CommonJS modules to the browser, Browserify reshaped front-end development. Webpack won over browserify by offering a wealth of features like automated code splitting and the ability to manage CSS or images, becoming not just a JavaScript bundler but the bundler for all front-end assets.</p> <p>This centralization is interesting because webpack makes it easy to build bloated apps but is also uniquely positioned to combat the web of bloat. In the future, I wish webpack becomes as simple as some other tools we&#x2019;ve discussed, or is replaced by a simpler tool.</p> <h2 id="experimentation">Experimentation</h2> <p>Last, we have <a href="https://prepack.io/" target="_blank" rel="noopener noreferrer">Prepack</a>, a new tool from Facebook. It is quite unique in that it&#x2019;s a full-blown JavaScript interpreter specifically aimed to reducing the amount of indirection in our code.</p> <p>Its goal is to reduce initialization costs by precomputing code away during the build step. For example, we might originally have the following piece of code:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">fibonacci</span><span class="md-code-params">(x)</span> </span>{
    <span class="md-code-keyword">return</span> x &lt;= <span class="md-code-number">1</span> ? x : fibonacci(x - <span class="md-code-number">1</span>) + fibonacci(x - <span class="md-code-number">2</span>)
  }
  global.x = fibonacci(<span class="md-code-number">23</span>)
})()
</code></pre> <p>Prepack would interpret our code using a full-blown interpreter during our build, and produce code like the following:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  x = <span class="md-code-number">28657</span>
})()
</code></pre> <p>Prepack might eventually become the gold standard, but for now it&#x2019;s just an experiment.</p> <h1 id="resources">Resources</h1> <p>If you&#x2019;d like to learn more about the things I&#x2019;ve discussed in this article, here are some links!</p> <ul> <li><a href="https://ponyfoo.com/articles/es6">ES6 Overview in 350 Bullet Points</a></li> <li><a href="https://ponyfoo.com/articles/understanding-javascript-async-await">Understanding JavaScript&#x2019;s <code class="md-code md-code-inline">async</code> <code class="md-code md-code-inline">await</code></a></li> <li><a href="https://ponyfoo.com/articles/regular-expressions-post-es6">Regular Expressions in a post-ES6 World</a></li> <li><a href="https://ponyfoo.com/articles/standard">The JavaScript Standard</a></li> <li><a href="https://ponyfoo.com/articles/javascript-asynchronous-iteration-proposal">JavaScript Asynchronous Iteration Proposal</a></li> <li><a href="https://ponyfoo.com/books/practical-modern-javascript/chapters">Practical Modern JavaScript</a></li> <li><a href="https://prop-tc39.now.sh/" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">prop-tc39</code></a></li> <li><a href="https://github.com/tc39/proposals" target="_blank" rel="noopener noreferrer" aria-label="tc39/proposals on GitHub"><code class="md-code md-code-inline">tc39/proposals</code></a></li> <li><a href="https://prepack.io/" target="_blank" rel="noopener noreferrer">Prepack</a></li> <li><a href="https://twitter.com/nzgb" target="_blank" rel="noopener noreferrer">@nzgb</a></li> </ul> <p>Thanks for tuning in!</p></div>
