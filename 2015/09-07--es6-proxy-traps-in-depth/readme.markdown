<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth"><div></div></a>

<h1>ES6 Proxy Traps in Depth</h1>

<p><kbd>es6</kbd> <kbd>proxies</kbd> <kbd>traps</kbd> <kbd>es6-in-depth</kbd></p>

<blockquote><p>Welcome to <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Please, not again&#x201D;</em> &#x2013; in Depth</a>. Looking for other ES6 goodness? Refer to <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way &#x2026;</p></blockquote>

<div><p>Welcome to <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Please, not again&#x201D;</em> &#x2013; in Depth</a>. Looking for other ES6 goodness? Refer to <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="https://ponyfoo.com/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>, <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a>, <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>, <a href="https://ponyfoo.com/articles/es6-symbols-in-depth">Symbols</a>, <a href="https://ponyfoo.com/articles/es6-maps-in-depth">Maps</a>, <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, and <a href="https://ponyfoo.com/articles/es6-proxies-in-depth">proxies</a>. We&#x2019;ll be discussing <em>ES6 proxy <strong>traps</strong></em> today.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> <p>Note that <code class="md-code md-code-inline">Proxy</code> is harder to play around with as Babel doesn&#x2019;t support it unless the underlying browser has support for it. You can check out the <a href="http://kangax.github.io/compat-table/es6/" target="_blank">ES6 compatibility table</a> for supporting browsers. At the time of this writing, you can use <em>Microsoft Edge</em> or <em>Mozilla Firefox</em> to try out <code class="md-code md-code-inline">Proxy</code>. Personally, I&#x2019;ll be verifying my examples using <em>Firefox</em>.</p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for reading that, and let&#x2019;s go into more <code class="md-code md-code-inline">Proxy</code> <em>traps</em> now! If you haven&#x2019;t yet, I encourage you to read <a href="https://ponyfoo.com/articles/es6-proxies-in-depth">yesterday&#x2019;s article on the <code class="md-code md-code-inline">Proxy</code> built-in</a> for an introduction to the subject.</p></div>

<div><h2 id="proxy-trap-handlers">Proxy Trap Handlers</h2> <p>An interesting aspect of proxies is how you can use them to intercept just about any interaction with a <code class="md-code md-code-inline">target</code> object &#x2013; not just <code class="md-code md-code-inline">get</code> or <code class="md-code md-code-inline">set</code> operations. Below are some of the traps you can set up, here&#x2019;s a summary.</p> <ul> <li><a href="https://ponyfoo.com/#has"><code class="md-code md-code-inline">has</code></a> &#x2013; traps <code class="md-code md-code-inline">in</code> operator</li> <li><a href="https://ponyfoo.com/#deleteproperty"><code class="md-code md-code-inline">deleteProperty</code></a> &#x2013; traps <code class="md-code md-code-inline">delete</code> operator</li> <li><a href="https://ponyfoo.com/#defineproperty"><code class="md-code md-code-inline">defineProperty</code></a> &#x2013; traps <code class="md-code md-code-inline">Object.defineProperty</code> and declarative alternatives</li> <li><a href="https://ponyfoo.com/#enumerate"><code class="md-code md-code-inline">enumerate</code></a> &#x2013; traps <code class="md-code md-code-inline">for..in</code> loops</li> <li><a href="https://ponyfoo.com/#ownkeys"><code class="md-code md-code-inline">ownKeys</code></a> &#x2013; traps <code class="md-code md-code-inline">Object.keys</code> and related methods</li> <li><a href="https://ponyfoo.com/#apply"><code class="md-code md-code-inline">apply</code></a> &#x2013; traps <em>function calls</em></li> </ul> <p>We&#x2019;ll bypass <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code>, because we <a href="https://ponyfoo.com/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo">already covered those two</a> yesterday; and there&#x2019;s a few more traps that aren&#x2019;t listed here that will make it into an article published tomorrow. <em>Stay tuned!</em></p> <h3 id="has"><code class="md-code md-code-inline">has</code></h3> <p>You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/has" target="_blank" aria-label="handler.has() on MDN"><code class="md-code md-code-inline">handler.has</code></a> to <em>&#x201C;hide&#x201D;</em> any property you want. It&#x2019;s a trap for the <code class="md-code md-code-inline">in</code> operator. In the <a href="https://ponyfoo.com/articles/es6-proxies-in-depth#set" aria-label="ES6 Proxy set trap example"><code class="md-code md-code-inline">set</code></a> trap example we prevented changes and even access to <em><code class="md-code md-code-inline">_</code>-prefixed</em> properties, but unwanted accessors could still ping our proxy to figure out whether these properties are actually there or not. <em>Like <a href="https://en.wikipedia.org/wiki/Goldilocks_and_the_Three_Bears" target="_blank" aria-label="Goldilocks and the Three Bears on Wikipedia">Goldilocks</a></em>, we have three options here.</p> <ul> <li>We can let <code class="md-code md-code-inline">key in proxy</code> <em>fall through</em> to <code class="md-code md-code-inline">key in target</code></li> <li>We can <code class="md-code md-code-inline">return false</code> <em>(or <code class="md-code md-code-inline">true</code>)</em> &#x2013; even though <code class="md-code md-code-inline">key</code> <strong>may or may not</strong> actually be there</li> <li>We can <code class="md-code md-code-inline">throw</code> an error and deem the question <strong>invalid</strong> in the first place</li> </ul> <p>The last option is quite harsh, and I imagine it being indeed a valid choice in some situations &#x2013; but you would be acknowledging that the property <em>(or &#x201C;property space&#x201D;)</em> is, in fact, <em>protected</em>. It&#x2019;s often best to just smoothly indicate that the property is not <code class="md-code md-code-inline">in</code> the object. Usually, a fall-through case where you just return the result of the <code class="md-code md-code-inline">key in target</code> expression is a good default case to have.</p> <p>In our example, we probably want to <code class="md-code md-code-inline">return false</code> for properties in the <em><code class="md-code md-code-inline">_</code>-prefixed &#x201C;property space&#x201D;</em> and the default of <code class="md-code md-code-inline">key in target</code> for all other properties. This will keep our inaccessible properties well hidden from unwanted visitors.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  get (target, key) {
    invariant(key, <span class="md-code-string">&apos;get&apos;</span>)
    <span class="md-code-keyword">return</span> target[key]
  },
  set (target, key, value) {
    invariant(key, <span class="md-code-string">&apos;set&apos;</span>)
    <span class="md-code-keyword">return</span> <span class="md-code-literal">true</span>
  },
  <mark class="md-mark md-code-mark">has (target, key) {</mark>
    <span class="md-code-keyword">if</span> (key[<span class="md-code-number">0</span>] === <span class="md-code-string">&apos;_&apos;</span>) {
      <mark class="md-mark md-code-mark">return false</mark>
    }
    <mark class="md-mark md-code-mark">return key <span class="md-code-keyword">in</span> target</mark>
  }
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">invariant</span> <span class="md-code-params">(key, action)</span> </span>{
  <span class="md-code-keyword">if</span> (key[<span class="md-code-number">0</span>] === <span class="md-code-string">&apos;_&apos;</span>) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`Invalid attempt to ${action} private <span class="md-code-string">&quot;${key}&quot;</span> property`)
  }
}
</code></pre> <p>Note how accessing properties through the proxy will now return <code class="md-code md-code-inline">false</code> whenever accessing one of our private properties, with the consumer being none the wiser &#x2013; completely unaware that we&#x2019;ve intentionally hid the property from them.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = { _prop: <span class="md-code-string">&apos;foo&apos;</span>, pony: <span class="md-code-string">&apos;foo&apos;</span> }
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;pony&apos;</span> <span class="md-code-keyword">in</span> proxy)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;_prop&apos;</span> <span class="md-code-keyword">in</span> proxy)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;_prop&apos;</span> <span class="md-code-keyword">in</span> target)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Sure, we could&#x2019;ve thrown an exception instead. That&#x2019;d be useful in situations where attempts to access properties in the private space is seen more of <strong>as a mistake that results in broken modularity</strong> than as a <em>security concern</em> in code that aims to be embedded into third party websites.</p> <blockquote> <p>It really depends on your use case!</p> </blockquote> <h3 id="deleteproperty"><code class="md-code md-code-inline">deleteProperty</code></h3> <p>I use the <code class="md-code md-code-inline">delete</code> operator a lot. Setting a property to <code class="md-code md-code-inline">undefined</code> clears its value, but the property is still part of the object. Using the <code class="md-code md-code-inline">delete</code> operator on a property with code like <code class="md-code md-code-inline">delete foo.bar</code> means that the <code class="md-code md-code-inline">bar</code> property will be forever gone from the <code class="md-code md-code-inline">foo</code> object.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = { bar: <span class="md-code-string">&apos;baz&apos;</span> }
foo.bar = <span class="md-code-string">&apos;baz&apos;</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;bar&apos;</span> <span class="md-code-keyword">in</span> foo)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-keyword">delete</span> foo.bar
<span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;bar&apos;</span> <span class="md-code-keyword">in</span> foo)
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>Remember our <a href="https://ponyfoo.com/articles/es6-proxies-in-depth#set" aria-label="ES6 Proxy set trap example"><code class="md-code md-code-inline">set</code></a> trap example where we prevented access to <em><code class="md-code md-code-inline">_</code>-prefixed</em> properties? That code had a problem. Even though you couldn&#x2019;t change the value of <code class="md-code md-code-inline">_prop</code>, you could remove the property entirely using the <code class="md-code md-code-inline">delete</code> operator. Even through the <code class="md-code md-code-inline">proxy</code> object!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = { _prop: <span class="md-code-string">&apos;foo&apos;</span> }
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;_prop&apos;</span> <span class="md-code-keyword">in</span> proxy)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-keyword">delete</span> proxy._prop
<span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;_prop&apos;</span> <span class="md-code-keyword">in</span> proxy)
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/deleteProperty" target="_blank" aria-label="handler.deleteProperty() on MDN"><code class="md-code md-code-inline">handler.deleteProperty</code></a> to prevent a <code class="md-code md-code-inline">delete</code> operation from working. Just like with the <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code> traps, throwing in the <code class="md-code md-code-inline">deleteProperty</code> trap will be enough to prevent the deletion of a property.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  get (target, key) {
    invariant(key, <span class="md-code-string">&apos;get&apos;</span>)
    <span class="md-code-keyword">return</span> target[key]
  },
  set (target, key, value) {
    invariant(key, <span class="md-code-string">&apos;set&apos;</span>)
    <span class="md-code-keyword">return</span> <span class="md-code-literal">true</span>
  },
  <mark class="md-mark md-code-mark">deleteProperty (target, key) {</mark>
    invariant(key, <span class="md-code-string">&apos;delete&apos;</span>)
    <span class="md-code-keyword">return</span> <span class="md-code-literal">true</span>
  }
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">invariant</span> <span class="md-code-params">(key, action)</span> </span>{
  <span class="md-code-keyword">if</span> (key[<span class="md-code-number">0</span>] === <span class="md-code-string">&apos;_&apos;</span>) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`Invalid attempt to ${action} private <span class="md-code-string">&quot;${key}&quot;</span> property`)
  }
}
</code></pre> <p>If we run the exact same piece of code we tried earlier, we&#x2019;ll run into the exception while trying to delete <code class="md-code md-code-inline">_prop</code> from the <code class="md-code md-code-inline">proxy</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = { _prop: <span class="md-code-string">&apos;foo&apos;</span> }
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;_prop&apos;</span> <span class="md-code-keyword">in</span> proxy)
<span class="md-code-comment">// &lt;- true</span>
<mark class="md-mark md-code-mark">delete proxy._prop</mark>
<span class="md-code-comment">// &lt;- Error: Invalid attempt to delete private &quot;_prop&quot; property</span>
</code></pre> <p>Deleting properties in your <code class="md-code md-code-inline">_private</code> property space is no longer possible for consumers interacting with <code class="md-code md-code-inline">target</code> through the <code class="md-code md-code-inline">proxy</code>.</p> <h3 id="defineproperty"><code class="md-code md-code-inline">defineProperty</code></h3> <p>We typically use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" aria-label="Object.defineProperty() on MDN"><code class="md-code md-code-inline">Object.defineProperty(obj, key, descriptor)</code></a> in two types of situations.</p> <ol> <li>When we wanted to ensure cross-browser support of <em>getters and setters</em></li> <li>Whenever we want to define a custom property accessor</li> </ol> <p>Properties added by hand are read-write, they are deletable, and they are enumerable. Properties added through <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" aria-label="Object.defineProperty() on MDN"><code class="md-code md-code-inline">Object.defineProperty</code></a>, <em>in contrast</em>, default to being <em>read-only</em>, <em>write-only</em>, <em>non-deletable</em>, and <em>non-enumerable</em> &#x2013; in other words, the property starts off being completely <strong>immutable</strong>. You can customize these aspects of the property descriptor, and you can find them below &#x2013; alongside with their <em>default values</em> when using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" aria-label="Object.defineProperty() on MDN"><code class="md-code md-code-inline">Object.defineProperty</code></a>.</p> <ul> <li><code class="md-code md-code-inline">configurable: false</code> disables most changes to the property descriptor and makes the property <em>undeletable</em></li> <li><code class="md-code md-code-inline">enumerable: false</code> hides the property from <code class="md-code md-code-inline">for..in</code> loops and <code class="md-code md-code-inline">Object.keys</code></li> <li><code class="md-code md-code-inline">value: undefined</code> is the initial value for the property</li> <li><code class="md-code md-code-inline">writable: false</code> makes the property value immutable</li> <li><code class="md-code md-code-inline">get: undefined</code> is a method that acts as the getter for the property</li> <li><code class="md-code md-code-inline">set: undefined</code> is a method that receives the new <code class="md-code md-code-inline">value</code> and updates the property&#x2019;s <code class="md-code md-code-inline">value</code></li> </ul> <p>Note that when defining a property you&#x2019;ll have to choose between using <code class="md-code md-code-inline">value</code> and <code class="md-code md-code-inline">writable</code> or <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code>. When choosing the former you&#x2019;re configuring a <em>data descriptor</em> &#x2013; this is the kind you get when declaring properties like <code class="md-code md-code-inline">foo.bar = &apos;baz&apos;</code>, it has a <code class="md-code md-code-inline">value</code> and it <em>may or may not</em> be <code class="md-code md-code-inline">writable</code>. When choosing the latter you&#x2019;re creating an <em>accessor descriptor</em>, which is entirely defined by the methods you can use to <code class="md-code md-code-inline">get()</code> or <code class="md-code md-code-inline">set(value)</code> the value for the property.</p> <p>The code sample below shows how property descriptors are completely different depending on whether you went for the declarative option or through the programmatic API.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = {}
<mark class="md-mark md-code-mark">target.foo = <span class="md-code-string">&apos;bar&apos;</span></mark>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.getOwnPropertyDescriptor(target, <span class="md-code-string">&apos;foo&apos;</span>))
<span class="md-code-comment">// &lt;- { value: &apos;bar&apos;, writable: true, enumerable: true, configurable: true }</span>
<mark class="md-mark md-code-mark">Object.defineProperty(target, <span class="md-code-string">&apos;baz&apos;</span>, { value: <span class="md-code-string">&apos;ponyfoo&apos;</span> })</mark>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.getOwnPropertyDescriptor(target, <span class="md-code-string">&apos;baz&apos;</span>))
<span class="md-code-comment">// &lt;- { value: &apos;ponyfoo&apos;, writable: false, enumerable: false, configurable: false }</span>
</code></pre> <p>Now that we went over a blitzkrieg overview of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" aria-label="Object.defineProperty() on MDN"><code class="md-code md-code-inline">Object.defineProperty</code></a>, we can move on to the trap.</p> <h4 id="it-s-a-trap">It&#x2019;s a Trap</h4> <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/defineProperty" target="_blank" aria-label="handler.defineProperty() on MDN"><code class="md-code md-code-inline">handler.defineProperty</code></a> trap can be used to intercept calls to <code class="md-code md-code-inline">Object.defineProperty</code>. You get the <code class="md-code md-code-inline">key</code> and the <code class="md-code md-code-inline">descriptor</code> being used. The example below completely prevents the addition of properties through the <code class="md-code md-code-inline">proxy</code>. How cool is it that this intercepts the declarative <code class="md-code md-code-inline">foo.bar = &apos;baz&apos;</code> property declaration alternative as well? <em>Quite cool!</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  defineProperty (target, key, descriptor) {
    <mark class="md-mark md-code-mark">return false</mark>
  }
}
<span class="md-code-keyword">var</span> target = {}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
proxy.foo = <span class="md-code-string">&apos;bar&apos;</span>
<span class="md-code-comment">// &lt;- TypeError: proxy defineProperty handler returned false for property &apos;&quot;foo&quot;&apos;</span>
</code></pre> <p>If we go back to our <em>&#x201C;private properties&#x201D;</em> example, we could use the <code class="md-code md-code-inline">defineProperty</code> trap to prevent the creation of private properties through the proxy. We&#x2019;ll reuse the <code class="md-code md-code-inline">invariant</code> method we had to <code class="md-code md-code-inline">throw</code> on attempts to define a property in the <em>&#x201C;private <code class="md-code md-code-inline">_</code>-prefixed space&#x201D;</em>, and that&#x2019;s it.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  defineProperty (target, key, descriptor) {
    <mark class="md-mark md-code-mark">invariant(key, <span class="md-code-string">&apos;define&apos;</span>)</mark>
    <span class="md-code-keyword">return</span> <span class="md-code-literal">true</span>
  }
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">invariant</span> <span class="md-code-params">(key, action)</span> </span>{
  <span class="md-code-keyword">if</span> (key[<span class="md-code-number">0</span>] === <span class="md-code-string">&apos;_&apos;</span>) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`Invalid attempt to ${action} private <span class="md-code-string">&quot;${key}&quot;</span> property`)
  }
}
</code></pre> <p>You could then try it out on a <code class="md-code md-code-inline">target</code> object, setting properties with a <code class="md-code md-code-inline">_</code> prefix will now throw an error. You could make it fail silently by returning <code class="md-code md-code-inline">false</code> <em>&#x2013; depends on your use case!</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = {}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
proxy._foo = <span class="md-code-string">&apos;bar&apos;</span>
<span class="md-code-comment">// &lt;- Error: Invalid attempt to define private &quot;_foo&quot; property</span>
</code></pre> <p>Your <code class="md-code md-code-inline">proxy</code> is now safely hiding <code class="md-code md-code-inline">_private</code> properties behind a trap that guards them from definition through either <code class="md-code md-code-inline">proxy[key] = value</code> or <code class="md-code md-code-inline">Object.defineProperty(proxy, key, { value })</code> <em>&#x2013; pretty amazing!</em></p> <h3 id="enumerate"><code class="md-code md-code-inline">enumerate</code></h3> <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/enumerate" target="_blank" aria-label="handler.enumerate() on MDN"><code class="md-code md-code-inline">handler.enumerate</code></a> method can be used to trap <code class="md-code md-code-inline">for..in</code> statements. With <a href="https://ponyfoo.com/#has" aria-label="ES6 Proxy has trap example"><code class="md-code md-code-inline">has</code></a> we could prevent <code class="md-code md-code-inline">key in proxy</code> from returning <code class="md-code md-code-inline">true</code> for any property in our underscored private space, but what about a <code class="md-code md-code-inline">for..in</code> loop? Even though our <code class="md-code md-code-inline">has</code> trap hides the property from a <code class="md-code md-code-inline">key in proxy</code> check, the consumer will accidentally stumble upon the property when using a <code class="md-code md-code-inline">for..in</code> loop!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  has (target, key) {
    <span class="md-code-keyword">if</span> (key[<span class="md-code-number">0</span>] === <span class="md-code-string">&apos;_&apos;</span>) {
      <span class="md-code-keyword">return</span> <span class="md-code-literal">false</span>
    }
    <span class="md-code-keyword">return</span> key <span class="md-code-keyword">in</span> target
  }
}
<span class="md-code-keyword">var</span> target = { _prop: <span class="md-code-string">&apos;foo&apos;</span> }
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<mark class="md-mark md-code-mark">for (<span class="md-code-keyword">let</span> key <span class="md-code-keyword">in</span> proxy) {</mark>
  <span class="md-code-built_in">console</span>.log(key)
  <span class="md-code-comment">// &lt;- &apos;_prop&apos;</span>
}
</code></pre> <p>We can use the <code class="md-code md-code-inline">enumerate</code> trap to return an <em>iterator</em> that&#x2019;ll be used instead of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in#Description" target="_blank" aria-label="for..in loops on MDN"><em>enumerable properties</em></a> found in <code class="md-code md-code-inline">proxy</code> during a <code class="md-code md-code-inline">for..in</code> loop. The returned iterator must conform to the iterator protocol, such as the iterators returned from any <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">Symbol.iterator</code></a> method. Here&#x2019;s a possible implementation of such a <code class="md-code md-code-inline">proxy</code> that would return the output of <code class="md-code md-code-inline">Object.keys</code> minus the properties found in our <em>private space</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  has (target, key) {
    <span class="md-code-keyword">if</span> (key[<span class="md-code-number">0</span>] === <span class="md-code-string">&apos;_&apos;</span>) {
      <span class="md-code-keyword">return</span> <span class="md-code-literal">false</span>
    }
    <span class="md-code-keyword">return</span> key <span class="md-code-keyword">in</span> target
  },
  enumerate (target) {
    <span class="md-code-keyword">return</span> <span class="md-code-built_in">Object</span>.keys(target).filter(key =&gt; key[<span class="md-code-number">0</span>] !== <span class="md-code-string">&apos;_&apos;</span>)<mark class="md-mark md-code-mark">[Symbol.iterator]()</mark>
  }
}
<span class="md-code-keyword">var</span> target = { pony: <span class="md-code-string">&apos;foo&apos;</span>, _bar: <span class="md-code-string">&apos;baz&apos;</span>, _prop: <span class="md-code-string">&apos;foo&apos;</span> }
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> key <span class="md-code-keyword">in</span> proxy) {
  <span class="md-code-built_in">console</span>.log(key)
  <span class="md-code-comment">// &lt;- &apos;pony&apos;</span>
}
</code></pre> <p>Now your private properties are hidden from those prying <code class="md-code md-code-inline">for..in</code> eyes!</p> <h3 id="ownkeys"><code class="md-code md-code-inline">ownKeys</code></h3> <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/ownKeys" target="_blank" aria-label="handler.ownKeys() on MDN"><code class="md-code md-code-inline">handler.ownKeys</code></a> method may be used to return an <code class="md-code md-code-inline">Array</code> of properties that will be used as a result for <code class="md-code md-code-inline">Reflect.ownKeys()</code> <em>&#x2013; it should include all properties of <code class="md-code md-code-inline">target</code> (enumerable or not, and symbols too).</em> A default implementation, <em>as seen below</em>, could just call <code class="md-code md-code-inline">Reflect.ownKeys</code> on the proxied <code class="md-code md-code-inline">target</code> object. Don&#x2019;t worry, we&#x2019;ll get to the <code class="md-code md-code-inline">Reflect</code> built-in later in the <a href="https://ponyfoo.com/articles/tagged/es6-in-depth" aria-label="Articles tagged es6-in-depth on Pony Foo"><code class="md-code md-code-inline">es6-in-depth</code></a> series.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  ownKeys (target) {
    <mark class="md-mark md-code-mark">return Reflect.ownKeys(target)</mark>
  }
}
</code></pre> <p>Interception wouldn&#x2019;t affect the output of <code class="md-code md-code-inline">Object.keys</code> in this case.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = {
  _bar: <span class="md-code-string">&apos;foo&apos;</span>,
  _prop: <span class="md-code-string">&apos;bar&apos;</span>,
  [Symbol(<span class="md-code-string">&apos;secret&apos;</span>)]: <span class="md-code-string">&apos;baz&apos;</span>,
  pony: <span class="md-code-string">&apos;ponyfoo&apos;</span>
}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> key of <span class="md-code-built_in">Object</span>.keys(proxy)) {
  <span class="md-code-built_in">console</span>.log(key)
  <span class="md-code-comment">// &lt;- &apos;_bar&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;_prop&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;pony&apos;</span>
}
</code></pre> <p>Do note that the <code class="md-code md-code-inline">ownKeys</code> interceptor is used during all of the following operations.</p> <ul> <li><code class="md-code md-code-inline">Object.getOwnPropertyNames()</code> &#x2013; just non-symbol properties</li> <li><code class="md-code md-code-inline">Object.getOwnPropertySymbols()</code> &#x2013; just symbol properties</li> <li><code class="md-code md-code-inline">Object.keys()</code> &#x2013; just non-symbol enumerable properties</li> <li><code class="md-code md-code-inline">Reflect.ownKeys()</code> &#x2013; we&#x2019;ll get to <code class="md-code md-code-inline">Reflect</code> later in the series!</li> </ul> <p>In the use case where we want to shut off access to a property space prefixed by <code class="md-code md-code-inline">_</code>, we could take the output of <code class="md-code md-code-inline">Reflect.ownKeys(target)</code> and filter that.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  ownKeys (target) {
    <span class="md-code-keyword">return</span> Reflect.ownKeys(target).filter(<mark class="md-mark md-code-mark">key =&gt; key[<span class="md-code-number">0</span>] !== <span class="md-code-string">&apos;_&apos;</span></mark>)
  }
}
</code></pre> <p>If we now used the <code class="md-code md-code-inline">handler</code> in the snippet above to pull the object keys, we&#x2019;ll just find the properties in the public, non <code class="md-code md-code-inline">_</code>-prefixed space.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = {
  _bar: <span class="md-code-string">&apos;foo&apos;</span>,
  _prop: <span class="md-code-string">&apos;bar&apos;</span>,
  [Symbol(<span class="md-code-string">&apos;secret&apos;</span>)]: <span class="md-code-string">&apos;baz&apos;</span>,
  pony: <span class="md-code-string">&apos;ponyfoo&apos;</span>
}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> key of <mark class="md-mark md-code-mark">Object.keys(proxy)</mark>) {
  <span class="md-code-built_in">console</span>.log(key)
  <span class="md-code-comment">// &lt;- &apos;pony&apos;</span>
}
</code></pre> <p>Symbol iteration wouldn&#x2019;t be affected by this as <code class="md-code md-code-inline">sym[0]</code> yields <code class="md-code md-code-inline">undefined</code> <em>&#x2013; and in any case decidedly not <code class="md-code md-code-inline">&apos;_&apos;</code>.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = {
  _bar: <span class="md-code-string">&apos;foo&apos;</span>,
  _prop: <span class="md-code-string">&apos;bar&apos;</span>,
  [<mark class="md-mark md-code-mark">Symbol(<span class="md-code-string">&apos;secret&apos;</span>)</mark>]: <span class="md-code-string">&apos;baz&apos;</span>,
  pony: <span class="md-code-string">&apos;ponyfoo&apos;</span>
}
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> key of <mark class="md-mark md-code-mark">Object.getOwnPropertySymbols(proxy)</mark>) {
  <span class="md-code-built_in">console</span>.log(key)
  <span class="md-code-comment">// &lt;- Symbol(secret)</span>
}
</code></pre> <p>We were able to hide properties prefixed with <code class="md-code md-code-inline">_</code> from key enumeration while leaving symbols and other properties unaffected.</p> <h3 id="apply"><code class="md-code md-code-inline">apply</code></h3> <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply" target="_blank" aria-label="handler.apply() on MDN"><code class="md-code md-code-inline">handler.apply</code></a> method is quite interesting. You can use it as a trap on any invocation of <code class="md-code md-code-inline">proxy</code>. All of the following will go through the <code class="md-code md-code-inline">apply</code> trap for your proxy.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">proxy(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>)
proxy(...args)
proxy.call(<span class="md-code-literal">null</span>, <span class="md-code-number">1</span>, <span class="md-code-number">2</span>)
proxy.apply(<span class="md-code-literal">null</span>, [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>])
</code></pre> <p>The <code class="md-code md-code-inline">apply</code> method takes three arguments.</p> <ul> <li><code class="md-code md-code-inline">target</code> &#x2013; the function being proxied</li> <li><code class="md-code md-code-inline">ctx</code> &#x2013; the context passed as <code class="md-code md-code-inline">this</code> to <code class="md-code md-code-inline">target</code> when applying a call</li> <li><code class="md-code md-code-inline">args</code> &#x2013; the arguments passed to <code class="md-code md-code-inline">target</code> when applying the call</li> </ul> <p>A na&#xEF;ve implementation might look like <code class="md-code md-code-inline">target.apply(ctx, args)</code>, but below we&#x2019;ll be using <code class="md-code md-code-inline">Reflect.apply(...arguments)</code>. We&#x2019;ll dig deeper into the <code class="md-code md-code-inline">Reflect</code> built-in later in the series. For now, just think of them as equivalent, and take into account that the value returned by the <code class="md-code md-code-inline">apply</code> trap is also going to be used as the result of a function call through <code class="md-code md-code-inline">proxy</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  apply (target, ctx, args) {
    <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">Reflect.apply(...arguments)</mark>
  }
}
</code></pre> <p>Besides the obvious <em>&quot;being able to log all parameters of every function call for <code class="md-code md-code-inline">proxy</code>&quot;</em>, this trap can be used for parameter balancing and to tweak the results of a function call without changing the method itself <em>&#x2013; and without changing the calling code either.</em></p> <p>The example below proxies a <code class="md-code md-code-inline">sum</code> method through a <code class="md-code md-code-inline">twice</code> trap handler that doubles the results of <code class="md-code md-code-inline">sum</code> without affecting the code around it other than using the <code class="md-code md-code-inline">proxy</code> instead of the <code class="md-code md-code-inline">sum</code> method directly.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> twice = {
  apply (target, ctx, args) {
    <span class="md-code-keyword">return</span> Reflect.apply(...arguments) <mark class="md-mark md-code-mark">* <span class="md-code-number">2</span></mark>
  }
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span> <span class="md-code-params">(left, right)</span> </span>{
  <span class="md-code-keyword">return</span> left + right
}
<span class="md-code-keyword">var</span> proxy = <mark class="md-mark md-code-mark">new Proxy(sum, twice)</mark>
<span class="md-code-built_in">console</span>.log(proxy(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>))
<span class="md-code-comment">// &lt;- 6</span>
<span class="md-code-built_in">console</span>.log(proxy(...[<span class="md-code-number">3</span>, <span class="md-code-number">4</span>]))
<span class="md-code-comment">// &lt;- 14</span>
<span class="md-code-built_in">console</span>.log(proxy.call(<span class="md-code-literal">null</span>, <span class="md-code-number">5</span>, <span class="md-code-number">6</span>))
<span class="md-code-comment">// &lt;- 22</span>
<span class="md-code-built_in">console</span>.log(proxy.apply(<span class="md-code-literal">null</span>, [<span class="md-code-number">7</span>, <span class="md-code-number">8</span>]))
<span class="md-code-comment">// &lt;- 30</span>
</code></pre> <p>Naturally, calling <code class="md-code md-code-inline">Reflect.apply</code> on the <code class="md-code md-code-inline">proxy</code> will be caught by the <code class="md-code md-code-inline">apply</code> <em>trap</em> as well.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">Reflect.apply(proxy, <span class="md-code-literal">null</span>, [<span class="md-code-number">9</span>, <span class="md-code-number">10</span>])
<span class="md-code-comment">// &lt;- 38</span>
</code></pre> <blockquote> <p>What else would you use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply" target="_blank" aria-label="handler.apply() on MDN"><code class="md-code md-code-inline">handler.apply</code></a> for?</p> </blockquote> <p>Tomorrow I&#x2019;ll publish the last article on <code class="md-code md-code-inline">Proxy</code> <em>&#x2013; Promise! &#x2013;</em> It&#x2019;ll include the remaining <em>trap</em> handlers, such as <code class="md-code md-code-inline">construct</code> and <code class="md-code md-code-inline">getPrototypeOf</code>. <em>Subscribe below so you don&#x2019;t miss them.</em></p></div>
