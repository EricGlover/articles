<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/master/contributing.markdown"><code>contributing.markdown</code></a> for details.</sub>

<a href="https://ponyfoo.com/articles/designing-front-end-components"><div></div></a>

<h1>Designing Front-End Components</h1>

<p><kbd>front-end</kbd> <kbd>modularity</kbd> <kbd>rome</kbd> <kbd>insignia</kbd> <kbd>dragula</kbd> <kbd>horsey</kbd></p>

<blockquote><p>Last monday I published an open-source library to easily take control of <em>drag &amp; drop</em> in the front-end, <a href="https://github.com/bevacqua/dragula" target="_blank">dragula</a>, and it has amassed over 2000 stars on GitHub in under &#x2026;</p></blockquote>

<div><p>Last monday I published an open-source library to easily take control of <em>drag &amp; drop</em> in the front-end, <a href="https://github.com/bevacqua/dragula" target="_blank">dragula</a>, and it has amassed over 2000 stars on GitHub in under a week. Previously I had published <em>a date picker component</em>, <a href="https://github.com/bevacqua/rome" target="_blank">Rome</a>, that&#x2019;s somewhat popular among the nerds. In this article we&#x2019;ll discuss how you can build and isolate components that have a simple API.</p></div>

<div></div>

<div><p><a href="https://github.com/bevacqua/dragula" target="_blank">Dragula</a> had a much faster growth rate than <a href="https://github.com/bevacqua/rome" target="_blank">rome</a> did, and that&#x2019;s mostly due to the fact that there were basically <em>zero</em> proven libraries that <strong>solve drag &amp; drop</strong> <em>(and drag &amp; drop alone)</em> while being flexible and simple. I emphasize the fact that it does <em>less</em> as a feature, and not a problem. In my experience, I&#x2019;ve found that the best pieces of code I&#x2019;ve ever used tend to follow the UNIX philosophy of <strong>doing one thing very well</strong>. Having that kind of focused approach to front-end modules typically isn&#x2019;t the case. Instead, we often develop solutions that are only useful in our specific use. For example, we may put together an entrenched AngularJS directive that uses other directives or relies on data-binding provided by Angular.</p> <p>What&#x2019;s worse, most often we don&#x2019;t <em>just</em> limit ourselves to the scope of the libraries we&#x2019;re currently using, but to the specific scope of the one project we&#x2019;re working on. This means that now our library can&#x2019;t be extricated from that database without considerable work. For instance, consider that one time you developed a UI component where the user would type tags in plain text and after typing a delimiter <em>(a comma or a space)</em>, they would get visual feedback into the tag being accepted. Something like the screenshot below.</p> <p><a href="http://bevacqua.github.io/insignia/" target="_blank"><img src="https://camo.githubusercontent.com/2c61248fb1272df8a619c95c7acfdb8a3f7193bd/687474703a2f2f692e696d6775722e636f6d2f6d6879334676392e706e67" alt="Screenshot of Insignia in action"></a></p> <p>Except for the fact that, unless you found what you needed on the open web in the form of a decoupled module, we sometimes commit the crime of tightly coupling the tagging feature to the framework we&#x2019;re using. Or to a library. Or to our application. Or to a specific part of our application.</p> <p>It would be best if were able to identify what it is that we&#x2019;re trying to accomplish <em>(in this case, improve the UX on an input field for tags)</em>, isolate that into its own module, and come up with the simplest possible API. Coming up with a simple API is often a dreadful task, and in this article I&#x2019;ll try to put together advice and explain my thought process while designing them.</p></div>

<div><p>After coming up with <a href="https://github.com/bevacqua/rome" target="_blank" aria-label="bevacqua/rome on GitHub">Rome</a>, I&#x2019;ve used it as a template for other <em>&#x201C;philosophically similar&#x201D;</em> front-end components, such as <a href="https://github.com/bevacqua/insignia" target="_blank" aria-label="bevacqua/insignia on GitHub">insignia</a>, <a href="https://github.com/bevacqua/horsey" target="_blank" aria-label="bevacqua/horsey on GitHub">horsey</a>, and <a href="https://github.com/bevacqua/dragula" target="_blank" aria-label="bevacqua/dragula on GitHub">dragula</a>. Pretty much the only change I&#x2019;ve made to the template in almost a year was switching from <a href="https://ponyfoo.com/articles/my-first-gulp-adventure" aria-label="My First Gulp Adventure on Pony Foo">Gulp</a> to <a href="http://substack.net/task_automation_with_npm_run" target="_blank" aria-label="Task automation with npm run, by @substack">npm run</a> in the build process, and <a href="https://ponyfoo.com/articles/gulp-grunt-whatever" aria-label="Gulp, Grunt, Whatever on Pony Foo">that&#x2019;s just a matter of personal preference</a>. These libraries focus on doing one thing well, and share a theme across their API, demo page, and documentation. Furthermore, they&#x2019;ve been designed to enable composability, or in other words, there shouldn&#x2019;t be any reason why one of these components couldn&#x2019;t be used with one or more other libraries.</p> <p>For example, <a href="https://ponyfoo.com/articles/baking-modularity-tag-editing" aria-label="Baking Modularity into Tag Editing">Insignia attempts to improve the UX</a> on tag inputs by acting as a <a href="http://en.wikipedia.org/wiki/WYSIWYG" target="_blank" aria-label="WYSIWYG defined on Wikipedia">WYSIWYG</a> input of sorts, where tags become easier to identify, remove, and manipulate by the user. It builds on the notion of <a href="https://ponyfoo.com/articles/tagged/progressive-enhancement" aria-label="Articles tagged &apos;progressive-enhancement&apos; on Pony Foo">progressive enhancement</a>, or the principle that <strong>the web should mostly work</strong> <em>&#x201C;before JavaScript&#x201D;</em>. To that end, existing input on a field is converted into tags, providing a consistent experience before and after JavaScript kicks in. Here is where I&#x2019;d like to emphasize that sometimes we build things with UX in mind that are actually detrimental to the human experiencing what we&#x2019;ve built.</p> <blockquote> <p>Always try and ask yourself, is this actually better for the end user or is it <strong>just more productive for me</strong> as a developer to do it this way?</p> <p>A lot of the time, the former simply isn&#x2019;t the case.</p> </blockquote> <p>Composability isn&#x2019;t just a matter of <a href="https://ponyfoo.com/articles/building-high-quality-front-end-modules" aria-label="Building High Quality Front-End Modules on Pony Foo">playing well with the web platform</a>. In practice, playing well with other libraries is just as important. Getting composability right is quite hard, how are you supposed to provide support for every other library out there that may interact with things you are using in the most unexpected ways imaginable? The answer is that you&#x2019;re not. You are not supposed, for example, to account for libraries that arbitrarily remove DOM nodes, move them, or wrap them in some other nodes. You are, however, supposed to <strong>make sure you keep the noise your module produces to a minimum</strong>, ideally producing zero noise.</p> <p>There&#x2019;s a number of ways you can keep the noise to a minimum. One of them involves keeping CSS in check.</p> <h1 id="turn-down-the-css">Turn down the CSS</h1> <p>If you look closely at <a href="https://github.com/bevacqua/rome" target="_blank" aria-label="bevacqua/rome on GitHub">any</a> <a href="https://github.com/bevacqua/insignia" target="_blank" aria-label="bevacqua/insignia on GitHub">of</a> <a href="https://github.com/bevacqua/horsey" target="_blank" aria-label="bevacqua/horsey on GitHub">the</a> <a href="https://github.com/bevacqua/dragula" target="_blank" aria-label="bevacqua/dragula on GitHub">four</a> libraries I&#x2019;ve mentioned thus far, you&#x2019;ll notice how simplistic their styling is.</p> <p><a href="http://bevacqua.github.io/horsey/" target="_blank" aria-label="Try a demo of Horsey online!"><img alt="An screenshot of Horsey&apos;s autocompletion feature in action" class="" src="https://camo.githubusercontent.com/ba466d12f9a3175daa526c67b2cdf7f0e628df81/687474703a2f2f692e696d6775722e636f6d2f696d44464330432e706e67"></a></p> <p>This is <em>decidedly intentional</em>, and aimed at making it easier to integrate the components with whatever styles your application may have. There&#x2019;s a few rules I follow with regards to styling within components.</p> <ul> <li>Shy away from inline styles</li> <li>Always prefix your CSS classes</li> <li>Keep styles to a minimum</li> <li>Distribute plain CSS along with the source</li> </ul> <p>These seemingly simple rules have a deeper meaning, which I&#x2019;ll lay out next.</p> <h3 id="shy-away-from-inline-styles">Shy away from inline styles</h3> <p>Avoiding inline styles is crucial. Inline styles are really hard to override, leading to a lot of unnecessary <code class="md-code md-code-inline">!important</code> rule-sprinkling. Most of the time, a CSS class will do a better job at grouping a set of styles together, making it easier for the developer to identify what the styles are trying to accomplish, change the component stylistically, and generally have more control over the styles of the component. Not every inline style can be avoided. Positioning styles, such as <code class="md-code md-code-inline">left</code> <code class="md-code md-code-inline">top</code> <code class="md-code md-code-inline">right</code> and <code class="md-code md-code-inline">bottom</code>, that frequently change over time have a place inline. Coincidentally, the developer is expected not to have a need for modifying these styles, where control is deferred to the library author to do as they intended.</p> <h3 id="always-prefix-your-css-classes">Always prefix your CSS classes</h3> <p>This one should be fairly obvious. Now that we&#x2019;ve moved most of the styles in our library to CSS classes, we&#x2019;ll abide by this rule to create a semantic namespace for our component&#x2019;s classes. If you want a deeper reasoning into the topic I suggest you read <a href="https://ponyfoo.com/articles/css-the-good-parts" aria-label="CSS: The Good Parts on Pony Foo">CSS: The Good Parts</a>, which discusses best practices when it comes to writing and maintaining modular CSS.</p> <p>This point seems almost trivial, why make such a big deal out of adding <code class="md-code md-code-inline">rd-</code> at the beginning of every class name? What is a 2 letter prefix on every single class name going to do for me? It&#x2019;s probably not going to do as much for you, as a module author, since every class name will probably have the same prefix. However, when you start taking into account a few modules working in tandem, or an entire array of components working under the same application <em>(which has plenty of styles on its own)</em>, creating faux namespaces via prefixing every class in a component becomes a glaringly obvious thing to do.</p> <p>Namespaces make it faster to figure out what component a class name belongs to, help reduce class name clashes <em>(<code class="md-code md-code-inline">.dialog</code> anyone?)</em>. This not only mitigates the chance that you mess up the existing styles of an application, but it also prevents the styles of that application from unwittingly breaking those of the component.</p> <p>CSS is a two way street, but with the advent of flying cars we have to be extra careful.</p> <h3 id="keep-styles-to-a-minimum">Keep styles to a minimum</h3> <p>Allowing the consumer some control over the styles in a component, and making sure those styles don&#x2019;t clash with others, will only have an impact as long as your component doesn&#x2019;t think too fancily of itself. The more styles you apply to a class name, the harder it&#x2019;ll be for a consumer to style that to their needs. Seriously, think about this. If you are providing me with a tag editing library, <strong>why would you include styles for round borders and a box shadow on the input?</strong> If the answer is purely stylistic <em>(it looks great!)</em>, then chances are those styles never belonged with the library in the first place.</p> <p>Overstyling components is an easy mistake to make. After all, who wouldn&#x2019;t want to have this <strong>sweet sweet transition</strong> when the tag input moves after a tag is edited? It just takes a line of CSS! <code class="md-code md-code-inline">transition: all 0.2s ease-in-out</code>. People will surely love that. It&#x2019;s fine to get fancy, but always strive to make it so that if a consumer doesn&#x2019;t want an style, he can get rid of it with a single line of CSS. If your users need to reset a lot of CSS in order to get a component to look and feel how they need it to, <strong>that&#x2019;s on you</strong>.</p> <p>In fewer words, there shouldn&#x2019;t be anything stopping the consumer from <strong>styling your component so that it perfectly blends into their designs</strong>.</p> <h3 id="distribute-plain-css-along-with-the-source">Distribute plain CSS along with the source</h3> <p>Packaging the CSS in a component has always been a debated topic. Some argue that it should be bundled with the JavaScript, so that consumers get everything by simply including your module. Complicated solutions exist too, such as <a href="http://webpack.github.io/docs/stylesheets.html" target="_blank" aria-label="Stylesheets in Webpack">Webpack allowing you to <code class="md-code md-code-inline">require</code> CSS</a>, whatever that may mean. My preferred approach is to compile CSS in every build from whatever source code I have, <em>which has been Stylus for a long time now</em>. I can then distribute that CSS, along with the source <code class="md-code md-code-inline">*.styl</code> file(s), directly on GitHub. Nowadays my builds create a tag on <code class="md-code md-code-inline">git</code>, and publish updates to both Bower and npm.</p> <p>As far as consuming these modules goes, I&#x2019;ll typically install them from <code class="md-code md-code-inline">npm</code>, include them with Browserify, and import any CSS into my Stylus bundle. Meanwhile, other users could just take the <code class="md-code md-code-inline">*.css</code> files directly, whatever floats their boat. If you go through <a href="https://ponyfoo.com/articles/tagged/build" aria-label="Articles tagged &apos;build&apos; on Pony Foo">articles on this blog tagged [build]</a>, I&#x2019;ve covered the topic pretty extensively so I won&#x2019;t go into further detail here.</p> <p>I asked people on Twitter what specific concerns they had regarding modular front-end component design. One of the questions I got was about how to deal with CSS, which we&#x2019;ve just covered. The other questions were concerned with <a href="https://ponyfoo.com/articles/building-high-quality-front-end-modules" aria-label="Building High Quality Front-End Modules on Pony Foo">clean, well-abstracted API design</a>, as well as effectively structuring modular code. These two go hand-in-hand.</p> <blockquote class="twitter-tweet"><p>Writing a new article for <a href="https://twitter.com/ponyfoo">@ponyfoo</a> on designing modular front-end components. Is there a specific topic you&apos;d like me to address?</p>&#x2014; Nicolas Bevacqua (@nzgb) <a href="https://twitter.com/nzgb/status/589842423351746560">abril 19, 2015</a></blockquote> <h1 id="be-the-api-you-wish-to-see-in-the-world">Be the API you wish to see in the world</h1> <p>Even though it may not seem that way, whenever I set out to build my own component I start by scouring the web for existing, usable alternatives to writing my own. Typically this yields a mixture of things I like and things I don&#x2019;t like, and helps shape the ideas I have about designing an API of my own. If you sift through a few libraries that sort of do what you want, you should be able to come up with a decent set of needs and use cases other people have, and add those to your own. Once you have that, the next step involves coming up with an API that&#x2019;s the most common denominator for all of those use cases.</p> <blockquote> <p>In the simplest possible use case, there should be <strong>little or no configuration</strong> involved.</p> </blockquote> <p>When it comes to components for the front-end, I think the recipe that best fits most use cases is having an API consisting of a single function that takes a DOM element, and an entirely optional configuration object. You should be able to come up with a reasonable default behavior for your component that will just work by indicating the DOM element to use. Beyond that, a configuration object will provide the consumer with customization for the appearance of the component, as well as assist them in covering the more advanced use cases.</p> <p>I think <a href="https://github.com/bevacqua/rome" target="_blank" aria-label="bevacqua/rome on GitHub">Rome</a> is a great case study of this approach.</p> <p><a href="http://bevacqua.github.io/rome/" target="_blank" aria-label="Try a demo of Rome online!"><img alt="A screenshot of Rome in action" class="" src="https://cloud.githubusercontent.com/assets/934293/3803583/387125ea-1c1c-11e4-974e-467984e4d1f0.png"></a></p> <p><a href="https://github.com/bevacqua/rome" target="_blank" aria-label="bevacqua/rome on GitHub">Rome</a> just takes an HTML <code class="md-code md-code-inline">&lt;input&gt;</code>, and the consumer is ready to go. Clicking on the provided element will pop a simple calendar right below the input, and the user can choose a date from the calendar. This is the most basic use case and shouldn&#x2019;t involve any configuration whatsoever. Therefore, it doesn&#x2019;t. The consumer may definitely have more advanced use cases than this. They may want to hide the time, as only the date matters to them. This is, again, a very common thing to wish for, so Rome makes sure that&#x2019;s easy to do: <code class="md-code md-code-inline">rome(input, { time: false })</code>.</p> <p>Some use cases are clearly more complicated than others, and they don&#x2019;t deserve a pinpointed solution such as a configuration flag, but rather a more generic solution. The example below changes the calendar so that only a certain date range is deemed valid and selectable. While an arguably advanced use case, having the ability to determine a valid date range is sure to up often enough in a date picker that being able to handle these directly as configurable options makes sense.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">rome(input, { min: <span class="md-code-string">&apos;2013-12-30&apos;</span>, max: <span class="md-code-string">&apos;2014-10-01&apos;</span> });
</code></pre> <p>The most important aspect of API design is to <strong>find the right abstractions</strong>, though. Suppose a library user creates an issue because they want to allow users to choose dates in summer, spring, or autumn, but not winter. You might be thinking &quot;well, I could just create a configuration option called <code class="md-code md-code-inline">seasons</code> with an array of the valid seasons. That sounds like a perfectly acceptable solution. It meets the user&#x2019;s needs, and it&#x2019;s abstracted enough to work for any season.</p> <p>You&#x2019;ve got to ask yourself, though. <strong>Would you use such an option? Would you find it simple?</strong> Most importantly, what happens when the next user comes along asking for a way to make the second week of each month invalid? Sundays? An specific point in time? Will you add a configuration option for each of these use cases? Of course not. Will you just cater to the needs of those who better align with the needs you have today for the library? Or will you go for a more generalized approach that just determined if any given date is valid?</p> <p>In the case of Rome, the answer was to create a <code class="md-code md-code-inline">dateValidator</code> option that allowed consumers to determine whether any given date was valid.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">rome(input, {
  dateValidator: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(d)</span> </span>{
    <span class="md-code-keyword">var</span> m = moment(d);
    <span class="md-code-keyword">var</span> y = m.year();
    <span class="md-code-keyword">var</span> f = <span class="md-code-string">&apos;MM-DD&apos;</span>;
    <span class="md-code-keyword">var</span> start = moment(<span class="md-code-string">&apos;12-21&apos;</span>, f).year(y).startOf(<span class="md-code-string">&apos;day&apos;</span>);
    <span class="md-code-keyword">var</span> end = moment(<span class="md-code-string">&apos;03-19&apos;</span>, f).year(y).endOf(<span class="md-code-string">&apos;day&apos;</span>);
    <span class="md-code-keyword">return</span> m.isBefore(start) &amp;&amp; m.isAfter(end);
  }
});
</code></pre> <p>Yes, <code class="md-code md-code-inline">min</code> and <code class="md-code md-code-inline">max</code> are effectively shadowed by this option, and internally they could very well function as an alias for <code class="md-code md-code-inline">dateValidator</code>. That&#x2019;s perfectly okay. Easy of use of an API endpoint should roughly match how frequently use cases come up in a given area.</p> <p>In the same vein, you should strive to reutilize parts of the API effectively. Originally, Rome didn&#x2019;t have a way to <em>&#x201C;link&#x201D;</em> two calendars, a common feature enabling the user to choose a <em>&#x201C;start date&#x201D;</em> and an <em>&#x201C;end date&#x201D;</em> for some sort of event or query. Given that I already had the generic <code class="md-code md-code-inline">dateValidator</code> configuration property in place I could <a href="https://github.com/bevacqua/rome/blob/master/src/validators.js" target="_blank" aria-label="Rome date validators on GitHub">come up with a few validators</a> that would determine if dates are valid for a given calendar based on the selection in some other calendar. Effectively building ranges, but without changing the public API, besides exposing the validators themselves.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">rome(left, {
  dateValidator: rome.val.beforeEq(right)
});

rome(right, {
  dateValidator: rome.val.afterEq(left)
});
</code></pre> <p>Rome even goes as far as to provide the consumer with the ability <a href="https://github.com/bevacqua/rome#default-options" target="_blank" aria-label="Default options for Rome on GitHub">to rename all CSS classes</a>.</p> <h1 id="the-api-behind-the-api">The API behind the API</h1> <p>Once we get past the API used to create a calendar using Rome, we get back an object containing an API of its own. This object can be used to interact with the calendar after it has been created. When following this pattern I like providing, as an starting point, a <code class="md-code md-code-inline">destroy</code> method which removes any DOM elements and unbinds any event listeners produced when instantiating the component. This makes sure you play well with single page applications, highly dynamic views, and other advanced use cases. The other method I find quite necessary to include is a <code class="md-code md-code-inline">.find</code> method on the public API that returns these instance API objects. Typically you&#x2019;d do something like <code class="md-code md-code-inline">rome.find(input)</code> and get back the calendar API associated with that <code class="md-code md-code-inline">input</code>, or <code class="md-code md-code-inline">null</code> if there wasn&#x2019;t any calendar associated to it yet.</p> <p>Beyond these two methods, the API behind the API should be mostly in charge of exposing parts of the component you&#x2019;ll sometimes want to trigger manually. In the case of Rome, besides displaying the calendar when clicking or focusing on the input, the consumer may want to add a keyboard shortcut to display the calendar, and the API should be perfectly fine supporting that use case. Beyond these simple methods, the most crucial aspect of the API behind the API is events. Emitting a few events at important milestones, such as when a calendar is displayed or a date is selected, allows the consumer to have fine grained hooks and control over what the user does, and to manipulate the outcome of those actions every step of the way. These events could be handled through synthetic events on the DOM element itself, or using a library to convert your API into an event emitter. You can use <a href="https://github.com/bevacqua/crossvent" target="_blank" aria-label="bevacqua/crossvent on GitHub">crossvent</a> and <a href="https://github.com/bevacqua/contra" target="_blank" aria-label="bevacqua/contra on GitHub">contra.emitter</a> respectively for these two approaches.</p> <p>I tend to keep the API behind the API really simple beyond that. Following a declarative configuration style is typically going to work wonders for your component, as there will be far less coding involved for the library consumer.</p> <h1 id="wrapping-up"><code class="md-code md-code-inline">wrapping(&apos;up&apos;)</code></h1> <p>As far as keeping your code modular effectively, you should treat every <code class="md-code md-code-inline">function</code> in your code the same way as we discussed for the public API itself. Strive to make it simple, to identify common patterns and use cases and abstract away just enough so that you can accomodate for the most frequent use cases in the most elegant way, and then handle the least frequent use cases a bit differently. You should try and put together methods that make logical sense. Make an effort to give <code class="md-code md-code-inline">function</code>s names that are as descriptive as possible <em>(but not too verbose)</em>, and keep everything that doesn&#x2019;t fit the name you gave a <code class="md-code md-code-inline">function</code> in some other <code class="md-code md-code-inline">function</code>.</p> <p>Eventually, you should start to notice how the very methods you want to promote to public API citizenship map quite logically to what you already have. For example, when I was developing <code class="md-code md-code-inline">dragula</code> I already had <code class="md-code md-code-inline">cancel</code>, <code class="md-code md-code-inline">remove</code>, and <code class="md-code md-code-inline">end</code> methods by the time I wanted to promote them to <em>&#x201C;API behind the API&#x201D;</em> level, which made it a very natural decision to make for me.</p> <p>Lastly, I&#x2019;d mention that keeping the dependency count low will make your modules more attractive to the public eye, as they&#x2019;ll become more decoupled from everything else and easier to integrate into whatever your potential consumers are doing.</p></div>
