<div><blockquote>
  <h1>Fixing Performance in the Web Stack</h1>
  <div><p>There&#x2019;s plenty of performance optimization techniques in web development. Particularly, if you look into each portion of the web stack in detail. In <a href="https://speakerdeck.com/bevacqua/high-performance-in-the-critical-path" target="_blank">the &#x2026;</a></p></div>
</blockquote></div>

<div><p>There&#x2019;s plenty of performance optimization techniques in web development. Particularly, if you look into each portion of the web stack in detail. In <a href="https://speakerdeck.com/bevacqua/high-performance-in-the-critical-path" target="_blank">the presentation</a> I covered <mark class="md-mark"><strong>TCP, HTTP, HTML, CSS, Fonts, Images, and JavaScript</strong></mark>. Let&#x2019;s go over the <em>potential improvements</em> on each of those fronts.</p></div>

<div></div>

<div><blockquote> <p>This is <em>the second part</em> of <a href="https://ponyfoo.com/articles/talk-about-web-performance">a previous article</a>, where I outlined how to measure performance and identify issues, how to enforce a <a href="http://timkadlec.com/2013/01/setting-a-performance-budget/" target="_blank">performance budget</a>, and how to do those things <em><mark class="md-mark">in every push to continuous integration</mark></em>.</p> </blockquote> <p>This time around, we&#x2019;ll focus on <em>finding fixes</em> for some of the most common performance pitfalls of the web today. To that end, we&#x2019;ll <strong>crawl the web stack</strong>. Each section describes the problem space and provides <em>a possible solution</em> you could implement. Here&#x2019;s an overview of what you&#x2019;ll find in this article.</p> <ul> <li>TCP connection optimizations</li> <li>HTTP and HTTP/2 improvements</li> <li>Caching and CDN usage</li> <li>HTML and server-side rendering</li> <li>Critical CSS inlining and other CSS techniques</li> <li>Font loading strategies</li> <li>Efficiency when serving images</li> <li>A couple of tips regarding your JavaScript</li> </ul> <p><strong>Let&#x2019;s dive into it.</strong> We&#x2019;ll start <em>at the very bottom of the stack</em>: the TCP transport layer.</p></div>

<div><h2 id="understanding-tcp-the-bowels-of-the-web">Understanding TCP, the Bowels of the Web</h2> <p>You would assume there isn&#x2019;t a whole lot we can do about TCP, or that it wouldn&#x2019;t have a big impact on web performance, but it turns out there&#x2019;s a couple of things we can do that are quite useful to web applications. To implement these optimizations you <strong>generally need to be either hosting the application on your own hardware, or on an IaaS service</strong> such as Amazon Web Services or Digital Ocean.</p> <p>It might also apply to a few PaaS services where you can run arbitrary command line arguments, but <em>I wouldn&#x2019;t bet the farm on that</em>.</p> <h3 id="increasing-the-initial-tcp-cwnd-size">Increasing the initial TCP <code class="md-code md-code-inline">cwnd</code> size</h3> <p>One of the configuration values in TCP is <code class="md-code md-code-inline">cwnd</code>, or the <em>&#x201C;congestion window&#x201D;</em>. This value determines how much data can be sent through the wire, and it grows as connection roundtrips can effectively handle the throughput. If we increase the initial TCP <code class="md-code md-code-inline">cwnd</code> size, we could <a href="https://developers.google.com/speed/articles/tcp_initcwnd_paper.pdf" target="_blank" aria-label="An Argument for Increasing TCP&#x2019;s Initial Congestion Window">essentially be saving a few roundtrips on the connection</a> that would otherwise end up transferring too little data.</p> <p>Increasing the <code class="md-code md-code-inline">cwnd</code> is useful because you might make it so that the entire <code class="md-code md-code-inline">&lt;head&gt;</code> of a page fits in the first roundtrip on the connection, for example. That&#x2019;s a big deal because we could start rendering the page faster, fetching other resources, etc.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>To accelerate connection ramp-up by increasing the initial <code class="md-code md-code-inline">cwnd</code> size, it usually suffices to ensure that we&#x2019;re running the latest version of our favorite Linux flavor. If that doesn&#x2019;t work, then you might want to read an article on <a href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/#change-initcwnd" target="_blank" aria-label="Tuning initcwnd for optimum performance">how to manually tune the <code class="md-code md-code-inline">initcwnd</code> value</a>, that also goes into <em>detail about the reasoning behind</em> doing so.</p> </blockquote> <h3 id="disabling-slow-start-restart-ssr">Disabling Slow-Start Restart <em>(SSR)</em></h3> <p>SSR is a mechanism built into TCP that really dampens HTTP. It has a noble purpose, though. The idea is that if a TCP connection goes idle for a while, then we should go back to safer levels of throughput, essentially cutting down on how much data can get through the wire. The problem is that this contradicts everything we&#x2019;re working towards in HTTP. Especially, if you&#x2019;ve enabled the HTTP <code class="md-code md-code-inline">keep-alive</code> mechanism <em>&#x2013; which you should have, as we&#x2019;ll see in a minute &#x2013;</em> SSR defeats the purpose. HTTP <code class="md-code md-code-inline">keep-alive</code> reuses a TCP connection across multiple HTTP requests, but if throughput goes down in between requests, then much of the value added by <code class="md-code md-code-inline">keep-alive</code> is lost.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>To disable slow-start restart, you can run the following command in your terminal:</p> <pre class="md-code-block"><code class="md-code md-lang-bash">sysctl -w net.ipv4.tcp_slow_start_after_idle = <span class="md-code-number">0</span>
</code></pre> </blockquote> <h2 id="web-performance-at-the-http-level">Web Performance at the HTTP level</h2> <p>There&#x2019;s quite a few tips I have for you regarding the Hyper-Text Transfer Protocol. I&#x2019;ll split each of the points regarding HTTP into their own sub-sections, so that readers who just skim the headlines also get some value out of the article.</p> <h3 id="making-less-requests">Making Less Requests</h3> <p>The fastest request is a request not made. Depending on how you interpret that phrase, it might sound obvious. <em>Who would make requests if they had no use for the response?</em> In the case of <strong>HTTP 1.1</strong>, that usually translates into bundling requests together, maybe by concatenating static resources or creating a spritesheet for the various icons in your site.</p> <p>In the context of <strong>HTTP 2.0</strong> this advice is transmogrified. <strong>HTTP 2.0</strong> utilizes a single TCP connection per origin, and all requests are multiplexed over that connection. In this scenario, concatenation and spriting might actually be perjudicial. Most of the time, the benefits in <strong>HTTP 2.0</strong> far outweight the <em>&#x201C;drawbacks&#x201D;</em> in concatenation, so that it&#x2019;s still useful to concatenate resources for those clients that are still making <strong>HTTP 1.1</strong> requests to your servers.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>This is a broad thing to ask of your applications, so here are <mark class="md-mark">some tips that may get you started</mark> making less requests.</p> <ul> <li>Tailor the application&#x2019;s web API to serve the needs of the client-side, and not the other way around</li> <li>Bundle images, scripts and styles into larger files for connections over <strong>HTTP 1.1</strong></li> <li>Only make requests that are absolutely necessary, when it is necessary to make them</li> <li>Cache their results as aggressively as you can get away with, saving time and improving UX</li> </ul> </blockquote> <h3 id="turning-on-keep-alive">Turning on <code class="md-code md-code-inline">keep-alive</code></h3> <p>As I&#x2019;ve mentioned earlier, <code class="md-code md-code-inline">keep-alive</code> is an HTTP mechanism that allows the same TCP connection to be kept open and reused across many HTTP requests. This innocent mechanism is one of the best optimizations you can indulge in, when it comes to HTTP.</p> <p>Enabling <code class="md-code md-code-inline">keep-alive</code> reduces the amount of hand-shaking, and thus latency, for every request that&#x2019;s kept alive by reusing one TCP connection. <strong>HTTP 2.0</strong> one-ups <code class="md-code md-code-inline">keep-alive</code>, by reusing the same TCP connection for every single request made against an origin.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>Luckily for us, <code class="md-code md-code-inline">keep-alive</code> is enabled by default in <code class="md-code md-code-inline">nginx</code> which you should be using! It&#x2019;s also enabled by default in Node.js, and fairly easy to turn on everywhere else, so there&#x2019;s no excuse not to turn <code class="md-code md-code-inline">keep-alive</code> on!</p> <p>In all other cases, you can add a <code class="md-code md-code-inline">Connection: keep-alive</code> header to your responses, and that&#x2019;ll suffice.</p> </blockquote> <h3 id="enabling-gzip-compression">Enabling GZip Compression</h3> <p>GZip is one of those magical algorithms that make your content download much faster virtually for free. It generally only takes a flip of a switch in web server software like Node.js or <code class="md-code md-code-inline">nginx</code>. The way it works is it&#x2019;ll identify repeating strings of text in the content and replace them with identifiers mapped to an index table. This makes text-based content way smaller. The only two cases where GZip performs below par is when content is so small that it&#x2019;d fit in a single roundtrip anyways, and when we&#x2019;re dealing with binary content. In the former case, <em>&#x2013; generally files that are 1kb in size or smaller &#x2013;</em> we&#x2019;re adding all of the GZip processing overhead for none of the benefits, since the file size might even end up increasing. In the latter, GZip doesn&#x2019;t really find much in the way of repeating strings, so it&#x2019;s usually avoided altogether.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>Easy to implement in <code class="md-code md-code-inline">nginx</code>, you can just throw in the <code class="md-code md-code-inline">gzip on</code> directive in your <code class="md-code md-code-inline">http</code> configuration section. Here are the settings I regularly use.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><mark class="md-mark md-code-mark">gzip on</mark>;
gzip_<span class="md-code-built_in">disable</span> <span class="md-code-string">&apos;msie6&apos;</span>;
gzip_comp_level <span class="md-code-number">6</span>;
gzip_vary on;
gzip_min_length  <span class="md-code-number">1000</span>;
gzip_proxied any;
gzip_types text/plain text/css application/json application/x-javascript text/javascript text/xml application/xml application/xml+rss image/x-icon;
gzip_buffers <span class="md-code-number">16</span> <span class="md-code-number">8</span>k;
</code></pre> <p>In Node.js you can turn on GZip with the <code class="md-code md-code-inline">compression</code> package for Express. They provide you with reasonable configuration defaults, but you could still tweak it.</p> </blockquote> <h3 id="caching-with-expires-and-etag-headers">Caching with Expires and ETag headers</h3> <p>Caching is one of those things everyone nods their heads in agreement and then we rarely actually get around to. Yet, it&#x2019;s probably one of the easiest ways to reduce load in your servers. Remember what we pointed out earlier about requests?</p> <blockquote> <p><strong><mark class="md-mark"><em>The fastest request is a request not made.</em></mark></strong></p> </blockquote> <p>The <code class="md-code md-code-inline">Expires</code> header is used by setting a date in the far future that determines when the content will go stale, meaning a new copy should be requested beyond that point. The header is usually paired with hashes in file names. For example, we generate an MD5 hash of the content of our JavaScript bundle, append it to its filename, throw in an <code class="md-code md-code-inline">Expires</code> header, and serve that. The client will only download that file once. Then, when we update the file, the MD5 hash will change, thus the filename will be different, meaning HTTP will treat it as a different resource altogether, and it&#x2019;ll be download once, again.</p> <p>Similarly, <code class="md-code md-code-inline">ETag</code> is a header that you&#x2019;re supposed to set to a hash of the content, and the browser will first ask the server if the <code class="md-code md-code-inline">ETag</code> changed, instead of downloading the entire resource every time.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>In <code class="md-code md-code-inline">nginx</code>, the <code class="md-code md-code-inline">expires</code> directive is good enough to deal with static assets. Here&#x2019;s an example <code class="md-code md-code-inline">location</code> section that serves static assets with high performance. Note how I&#x2019;m also turning off the <code class="md-code md-code-inline">access_log</code>, as it may not be as interesting as requests for other endpoints in your site.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">location ~ ^/(images/|js/|css/|fonts/|favicon.ico) {
  root {STATIC_ROOT};
  access_<span class="md-code-built_in">log</span> off;
  <mark class="md-mark md-code-mark">expires max</mark>;
}
</code></pre> <p>In Node.js you can turn caching on for static assets with the <code class="md-code md-code-inline">serve-static</code> package for Express. Keep in mind that this won&#x2019;t work for your views or API!</p> </blockquote> <h3 id="using-a-content-delivery-network-cdn">Using a Content Delivery Network <em>(CDN)</em></h3> <p>Using a CDN can come in handy if you need to maximize performance for static assets. The way they work is that clients are instructed to ask servers that are phisically near them for those assets, reducing latency. A lot of the time, using a CDN is overkill. For example, using a CDN for a blog like Pony Foo would be largely unnecessary.</p> <p>That being said there&#x2019;s a few free CDN providers <em>(<a href="https://www.cloudflare.com/" target="_blank" aria-label="CloudFlare CDN">CloudFlare</a> is one of the most prominent ones)</em> that you can easily set up for your projects at no cost to you.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p><a href="https://www.cloudflare.com/" target="_blank" aria-label="CloudFlare CDN">CloudFlare</a> is one of the easiest ones to use. It can act as a pass-through DNS for your application, and then you can have them point at your backend servers, that end up serving the responses. CloudFlare then ends up caching your content and intercepting requests for static assets, and serving them near the edge of the network, closer to the user.</p> </blockquote> <h3 id="what-about-spdy-and-http-20">What about <strong>SPDY</strong> and <strong>HTTP 2.0</strong>?</h3> <p>Look into enabling these protocols in your servers. Many times, they can yield as much as 60% gains <em>overall</em> and they&#x2019;re mostly a drop-in improvement. That&#x2019;s as good as it gets in the world of performance optimization. We&#x2019;ve <a href="https://ponyfoo.com/#making-less-requests" aria-label="Making Less Requests">already covered</a> the benefits of using a single TCP connection per origin and multiplexing all the requests <em>(and responses)</em> on that connection.</p> <p>What else does <strong>HTTP 2.0</strong> bring to the table? A couple of things.</p> <p>There&#x2019;s <strong>header compression</strong>, where a table of <em>&#x201C;seen&#x201D;</em> HTTP headers is constructed and used to indicate headers instead of transferring the entire record through the wire every single time. Headers sometimes make up for a large portion of the request response cycle, particularly when you take into account large analytics cookies and so on.</p> <p>Another improvement brought forth by <strong>HTTP 2.0</strong> is named <em>proactive server push</em>. This is a fancy way of saying that in <strong>HTTP 2.0</strong> the server can hint to the client that it should start downloading other resources alongside the HTML. That means you could ask the client to start downloading styles, fonts, and scripts while the HTML is still being loaded.</p> <p>Besides the four <em>&#x201C;hard improvements&#x201D;</em> outlined thus far, <em>&#x2013; one TCP connection, multiplexing, header compression, server push &#x2013;</em> there&#x2019;s also implicit improvements in <strong>HTTP 2.0</strong>, in that it naturally removes the need for hacks of the past such as image inlining, spriting, concatenation, and even minification to some degree.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>In <code class="md-code md-code-inline">nginx</code> you can use the experimental <a href="http://nginx.org/en/docs/http/ngx_http_spdy_module.html" target="_blank" aria-label="nginx module: ngx_http_spdy_module"><code class="md-code md-code-inline">ngx_http_spdy_module</code></a> module to turn on SPDY. You are required to also set up TLS, as that&#x2019;s regularly being shoved down our throats <em>(for good reason)</em> when it comes to implementing the latest and greatest features of the web.</p> <p>There isn&#x2019;t wide support for <strong>HTTP 2.0</strong> in <code class="md-code md-code-inline">nginx</code> and friends quite yet, but there&#x2019;s active effort to get it <a href="https://www.nginx.com/blog/how-nginx-plans-to-support-http2/" target="_blank" aria-label="How NGINX Plans to Support HTTP/2">out the door by the end of the year</a>, at least for <code class="md-code md-code-inline">nginx</code>.</p> </blockquote> <h2 id="how-about-some-html-tips">How about some HTML tips?</h2> <p>Sure thing. When it comes to HTML, the single best piece of advice I have for you is: <strong>leverage it</strong>. The best way to get content as fast as possible to the user is to actually serve that content to them &#x2013; no intermediaries. In other words, that means that <strong>you should be doing server-side rendering</strong> if you aren&#x2019;t yet.</p> <h3 id="server-side-render-all-the-things">Server-side Render all the Things</h3> <p>Instead of getting <em>&#x201C;creative&#x201D;</em> and having the human wait for your HTML to finish loading, your blocking styles and images to load, your scripts to load and get parsed and executed, and your client-side rendering to kick in, why not try and serve the content right away?</p> <p>You can always become a single page application later. I&#x2019;m not saying single page applications are bad, I&#x2019;m saying that <a href="https://ponyfoo.com/articles/server-first-apps" aria-label="Server-First Apps are a Good Idea">Server-First apps</a> are a great idea. The idea is that you render the HTML first, content and all, completely usable, links that humans can actually click on and go places. Then, once the content loads and the user starts making sense of your page, you can start loading JavaScript in the background. When that is executed, then you can start hijacking links, form submissions, and turning on the much appreciated realtime WebSocket communication machinery.</p> <p>But seriously, get the content out there right away. That&#x2019;s all that matters to the user after all, and if you make them wait six seconds for the client-side JavaScript to render the page while all they see is a loading indicator endlessly looping around, they&#x2019;ll grow sick and tired and leave long before your spinner finishes it&#x2019;s graceless dance.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>Server-side rendering is hard in the current state of the web. This is most unfortunate. <strong>Angular doesn&#x2019;t support server-side rendering</strong>. Ember doesn&#x2019;t either <em>(their &#x201C;support&#x201D; amounts to rendering a non-interactive HTML page for web crawlers)</em>. Meteor isn&#x2019;t for everyone, due to the high level of commitment one has to pour on their platform.</p> <p>You could cram shared rendering into a Backbone application if you were to use <a href="https://github.com/rendrjs/rendr" target="_blank" aria-label="rendrjs/rendr on GitHub"><code class="md-code md-code-inline">rendr</code></a>, but it&#x2019;s <em>a weak framework</em> that <mark class="md-mark"><strong>forces you to rewrite your application into a mess</strong></mark> that just happens to work on the server-side and supports Backbone. It&#x2019;s not <a href="https://github.com/rendrjs/rendr/graphs/contributors" target="_blank" aria-label="Activity graph for Rendr on GitHub">being actively developed</a> anymore either. Bottom line &#x2013; there&#x2019;s better alternatives today.</p> <p><a href="http://facebook.github.io/react/" target="_blank" aria-label="Facebook React">React</a> supports shared rendering natively &#x2013; and it might just be the best choice today when it comes to shared rendering. Granted, you&#x2019;ll need to have Node.js for the application backend to run the server-side rendering part, but that&#x2019;s increasingly the standard, and <strong>I foresee it becoming ubiquitous when it comes to application development</strong>, simply because of its effectiveness at shared rendering without code duplication in different languages.</p> <p>For the adventurous, an alternative might be <a href="https://github.com/taunus/taunus" target="_blank" aria-label="taunus/taunus on GitHub">Taunus</a>. Taunus runs on Node.js in the server-side, and it&#x2019;s a shared rendering library I built, that&#x2019;s enthusiastic about progressive enhancement and developing applications using <code class="md-code md-code-inline">&lt;form&gt;</code> elements. The goal is that Taunus applications work in a selection of devices and browsers as broad as possible.</p> </blockquote> <h3 id="defer-non-critical-asset-loading">Defer non-critical Asset Loading</h3> <p>This is mostly a remake of the previous point. Non-critical assets should be loaded asynchronously. This means everything from styles, fonts, and images to JavaScript, advertisement, and realtime features. I understand that your business may revolve around ads, but I&#x2019;m sure there&#x2019;s better ways of progressively interleaving content and ads than what most media sites are doing to the web.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>When it comes to <code class="md-code md-code-inline">&lt;script&gt;</code> tags, just add <code class="md-code md-code-inline">async</code> to them. Styles and fonts in <code class="md-code md-code-inline">&lt;link&gt;</code> tags are a bit harder, but the following snippet will get you there.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> elem = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">&apos;link&apos;</span>);
<span class="md-code-keyword">var</span> head = <span class="md-code-built_in">document</span>.getElementsByTagName(<span class="md-code-string">&apos;head&apos;</span>)[<span class="md-code-number">0</span>];
elem.rel = <span class="md-code-string">&apos;stylesheet&apos;</span>;
elem.href = <span class="md-code-string">&apos;/css/all.css&apos;</span>;
<mark class="md-mark md-code-mark">elem.media = <span class="md-code-string">&apos;only x&apos;</span></mark>;
head.appendChild(elem);
setTimeout(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  elem.media = <span class="md-code-string">&apos;all&apos;</span>;
});
</code></pre> <p>Of course, remember to keep the <code class="md-code md-code-inline">&lt;link&gt;</code> tag, but inside a <code class="md-code md-code-inline">&lt;noscript&gt;</code> element!</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">noscript</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">link</span> <span class="md-code-attribute">rel</span>=<span class="md-code-value">&apos;stylesheet&apos;</span> <span class="md-code-attribute">type</span>=<span class="md-code-value">&apos;text/css&apos;</span> <span class="md-code-attribute">href</span>=<span class="md-code-value">&apos;/css/all.css&apos;</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">noscript</span>&gt;</span>
</code></pre> <p>Images are easy to defer. Just use an attribute like <code class="md-code md-code-inline">src</code> instead of using <code class="md-code md-code-inline">src</code>, and then when the image becomes relevant <em>&#x2013; because we scroll near it, the rest of the page has finished loading, or any other reason &#x2013;</em> we set the value for <code class="md-code md-code-inline">src</code>, and the image gets loaded. Again, remember to add a <code class="md-code md-code-inline">&lt;noscript&gt;</code> tag with the image in it, using the actual <code class="md-code md-code-inline">src</code> attribute!</p> </blockquote> <h2 id="any-help-with-cascading-style-sheets">Any Help with Cascading Style Sheets?</h2> <p>Yes! Plenty. I&#x2019;ve already <a href="https://ponyfoo.com/articles/critical-path-performance-optimization" aria-label="Critical Path Performance Optimization at Pony Foo">written about CSS performance</a> back in the day, but I&#x2019;ll just write some more here &#x2013; just to keep up with the slides!</p> <h3 id="inlining-critical-css">Inlining Critical CSS</h3> <p>This tip is tightly tied into the last one. In order to be able to <a href="https://ponyfoo.com/#defer-non-critical-asset-loading" aria-label="Defer non-critical Asset Loading">defer non-critical</a> CSS, we need to identify critical CSS and inline it. Critical CSS is any CSS that&#x2019;s needed to render the content that&#x2019;s above the fold, the content that&#x2019;s first presented to the human when they load the page. There are tools that automate the identification process for you. Then all that&#x2019;s left to do is to inline that CSS inside a <code class="md-code md-code-inline">&lt;style&gt;</code> tag in your app, and defer the rest of the styles.</p> <p><a href="https://github.com/pocketjoso/penthouse" target="_blank" aria-label="pocketjoso/penthouse on GitHub"><img alt="Penthouse used in a variety of ways" class="" src="https://i.imgur.com/hrqmyge.png"></a></p> <p>The above is a screenshot of the documentation for <a href="https://github.com/pocketjoso/penthouse" target="_blank" aria-label="pocketjoso/penthouse on GitHub"><code class="md-code md-code-inline">penthouse</code></a>, a tool you can use to automate the critical CSS identification process.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>This one can be cumbersome to implement &#x2013; but it <em>really</em>, <mark class="md-mark">really,</mark> <em><strong>really</strong></em> pays off!</p> <p>The simplest way to go about doing this might be using <a href="https://github.com/addyosmani/critical" target="_blank" aria-label="addyosmani/critical on GitHub"><code class="md-code md-code-inline">critical</code></a>, which does the heavy lifting of extracting the CSS via <a href="https://github.com/pocketjoso/penthouse" target="_blank" aria-label="pocketjoso/penthouse on GitHub"><code class="md-code md-code-inline">penthouse</code></a>, inlining it in the page, and deferring the CSS from the <code class="md-code md-code-inline">&lt;link&gt;</code> tag using a technique like the one we outlined earlier in <a href="https://ponyfoo.com/#defer-non-critical-asset-loading" aria-label="Defer non-critical Asset Loading"><em>&#x201C;Defer non-critical Asset Loading&#x201D;</em></a>.</p> </blockquote> <p>You&#x2019;ll notice huge performance gains because of two reasons.</p> <ul> <li>CSS can be immediately applied to the above the fold content</li> <li>There are no longer <code class="md-code md-code-inline">&lt;link&gt;</code> tags blocking rendering while we wait on CSS to be downloaded</li> </ul> <h3 id="removing-unused-styles">Removing Unused Styles</h3> <p>Possibly one of the mildest techniques I&#x2019;ve described so far. Tools exist that let you identify CSS rules that don&#x2019;t impact the site and can be safely removed. The example I usually give is how you sometimes use libraries like Bootstrap that provide you a fast jumpstart into putting together an application with some CSS, and then you use pretty much three of the rules in the library. That way you end up with thousands of rules you don&#x2019;t actually use, and which only add bloat to your site.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>The <a href="https://github.com/giakki/uncss" target="_blank" aria-label="giakki/uncss on GitHub"><code class="md-code md-code-inline">uncss</code></a> package makes the process of removing unused CSS a breeze &#x2013; as long as you&#x2019;re serving individual stylesheets for each page on your site. You can use it directly as a command-line tool, through the <a href="https://github.com/addyosmani/grunt-uncss" target="_blank" aria-label="addyosmani/grunt-uncss on GitHub">Grunt</a> plugin, the <a href="https://github.com/ben-eb/gulp-uncss" target="_blank" aria-label="ben-eb/gulp-uncss on GitHub">Gulp</a> plugin, <a href="https://github.com/sindresorhus/broccoli-uncss" target="_blank" aria-label="sindresorhus/broccoli-uncss on GitHub">Broccoli</a>, or it&#x2019;s Node.js <a href="https://github.com/giakki/uncss#usage" target="_blank" aria-label="Uncss API usage documentation">API</a>.</p> </blockquote> <h3 id="avoiding-m-subdomains">Avoiding <code class="md-code md-code-inline">m.</code> subdomains</h3> <p>Not strictly performance related, but I see performance as something that&#x2019;s very closely related to UX, and having an <code class="md-code md-code-inline">m.</code> subdomain is not only futile but it also affects UX <em>(and maintainability)</em> very negatively. It is futile because it&#x2019;s impossible to categorize every device in existant as either mobile or not mobile.</p> <p>Instead of relying on an <code class="md-code md-code-inline">m.</code> subdomain, go the responsive route. Use mobile-first if possible, and try and design a consistently usable experience that&#x2019;s optimized for performance as well.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>Don&#x2019;t try to categorize every single device as either <em>&#x201C;mobile&#x201D;</em> or <em>&#x201C;desktop&#x201D;</em>. There&#x2019;s a lot of in between experiences, and just taking a mobile first responsive web design approach is light years ahead of using <code class="md-code md-code-inline">m.</code>-style viewport-specific experiences.</p> <p><mark class="md-mark"><em>Just be reasonable.</em></mark></p> </blockquote> <h3 id="follow-a-style-guide">Follow a Style Guide</h3> <p>Pick a style guide, any style guide. Not a magic trick. Picking a style guide <em>(and actually sticking to it)</em>, is one of the best things you can do for your project. I&#x2019;ve seen far too many projects where CSS is an afterthought, an <strong>impossibly disgusting <em>&quot;anything goes&quot;</em></strong> region of a site that nobody even dares to ask if there are any conventions to be followed or classes to be reused.</p> <p><a href="https://github.com/bevacqua/css" target="_blank" aria-label="bevacqua/css CSS Quality Guide on GitHub"><img alt="Here&#x2019;s a sample style guide" class="" src="https://i.imgur.com/cC0Lwi2.png"></a></p> <p>When you <a href="https://github.com/bevacqua/css" target="_blank" aria-label="bevacqua/css CSS Quality Guide on GitHub">follow a style guide</a>, at least there are some conventions to be respected, and everyone in the team will be less miserable about having to fix layout or design issues. You can buy me a beer at the next conference we run into each other.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>Just pick a style guide, any style guide. Maybe start out with <a href="https://github.com/bevacqua/css" target="_blank" aria-label="bevacqua/css CSS Quality Guide on GitHub">mine</a>, but that&#x2019;s biased. You could use something like <a href="http://primercss.io/scaffolding/" target="_blank" aria-label="CSS toolkit and guidelines that power GitHub">GitHub&#x2019;s style guide</a>. Or maybe you could pick <a href="http://cssguidelin.es/" target="_blank" aria-label="CSS Guidelines by Harry Roberts">Harry Robert&#x2019;s CSS Guidelines</a>. Or <a href="https://smacss.com/" target="_blank" aria-label="Scalable and Modular Architecture for CSS">SMACSS</a>. Just choose one and follow it. Enforce it, create a culture where <em>everyone</em> <strong>understands the importance of developing maintainable CSS</strong>.</p> <p><em>Collaborate to avoid pandemonium across your CSS files.</em></p> </blockquote> <h2 id="how-about-fonts-anything-there">How About Fonts? Anything There?</h2> <p>Absolutely. Fonts are hard. Fonts are slow. I have a few pointers about fonts for you. First, load them asynchronously. Secondly, <strong>use fewer fonts</strong> in your future projects. Third, cache the hell out of them!</p> <h3 id="using-fewer-fonts">Using Fewer Fonts</h3> <p>As I usually point out during the presentation, this is not something you can just head back to the office and strip away. The designer will not be amused. That being said, it&#x2019;s entirely possible to work with them to make sure you use, <em>for example</em>, two fonts at most. Constraints are actually great for design, so they won&#x2019;t be disappointed about the challenge.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>Naturally, you won&#x2019;t be able to remove fonts thoughtlessly from existing projects, as the design would probably suffer from it. The <mark class="md-mark">next time you&#x2019;re tackling a project</mark>, <em>however</em>, just make sure to work alongside the designers to come up with a design and a UX that makes sense from a performance standpoint.</p> <p>A lot of good can come from the intersection between design and performance. To this point, you might want to read <a href="https://github.com/jrcryer/grunt-pagespeed" target="_blank" aria-label="jrcryer/grunt-pagespeed on GitHub">Designing for Performance</a>, which was made <a href="http://designingforperformance.com/" target="_blank" aria-label="Designing for Performance Minisite">freely available online</a> just <em>a few days ago</em>.</p> </blockquote> <h3 id="loading-fonts-asynchronously">Loading Fonts Asynchronously</h3> <p>This is something we discussed earlier when we were talking about WPT and their filmstrip view. You can load a font asynchronously by deferring loading on the <code class="md-code md-code-inline">&lt;link&gt;</code> tag that loads the <code class="md-code md-code-inline">font-face</code>. Meanwhile, a fallback web-safe font could work just as well for the user, who only cares about content <em>(for the most part)</em>.</p> <p>When the custom font is eventually loaded, you can feel free to apply it to the entire document as needed, and be glad that you didn&#x2019;t force your customers to stare at blank chunks of a website for several seconds while fonts loaded synchronously!</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>You can use the <a href="https://github.com/zachleat/fontfaceonload" target="_blank" aria-label="zachleat/fontfaceonload on GitHub"><code class="md-code md-code-inline">fontfaceonload</code></a> package from npm to detect when the font is loaded and add a class name to your document, overriding the web safe font you&#x2019;re using by default. That&#x2019;ll be enough to ensure your fonts don&#x2019;t block rendering and to prevent FOIT in one fell swoop.</p> <p><a href="https://github.com/zachleat/fontfaceonload" target="_blank" aria-label="zachleat/fontfaceonload on GitHub"><img alt="Font face on load slide" class="" src="https://i.imgur.com/zq74te2.png"></a></p> <p>Note that you&#x2019;ll still have to load the font asynchronously on your own, using a technique such as <a href="https://ponyfoo.com/#making-less-requests" aria-label="Making Less Requests">the one described above</a>.</p> </blockquote> <h3 id="cache-fonts-aggressively">Cache Fonts Aggressively</h3> <p>This one should be obvious enough. Fonts are <strong>really expensive</strong> to load. Make sure you take the necessary precautions so that fonts are only loaded once.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>There&#x2019;s several techniques to caching fonts. You can use <code class="md-code md-code-inline">localStorage</code>, the HTTP cache, and many techniques in between. Do your homework and figure out what approach works best for your use case.</p> <p>On this front, you would do well to read <a href="http://www.smashingmagazine.com/2014/09/improving-smashing-magazine-performance-case-study/" target="_blank" aria-label="Improving Smashing Magazine&#x2019;s Performance: A Case Study">&#x201C;Improving Smashing Magazine&#x2019;s Performance&#x201D;</a>, and pretty much <a href="https://www.filamentgroup.com/lab/font-loading.html" target="_blank" aria-label="How we use web fonts responsibly, or, avoiding a @font-face-palm">any article about fonts</a> posted by the folks at Filament Group, such as <a href="https://www.filamentgroup.com/lab/font-events.html" target="_blank" aria-label="Font Loading Revisited with Font Events">this one right here</a>.</p> </blockquote> <h2 id="images">Images?</h2> <p><em>Yay.</em> Images are the often overlooked part of web optimization that we all know is the biggest pain point. Yet, we often end up obsessing about cutting bytes from our Browserify bundle using <a href="https://github.com/substack/bundle-collapser" target="_blank" aria-label="substack/bundle-collapser on GitHub"><code class="md-code md-code-inline">bundle-collapser</code></a> much more frequently that we obsess about making smarter use of images in our sites. Here&#x2019;s a few tips about images.</p> <h3 id="minify-and-shrink">Minify and Shrink</h3> <p>Minifying images is great. It&#x2019;s also a broadly understood concept, most of us already know that we should be minifying images, as we save bytes and most of the time you can&#x2019;t perceive any changes to the image, from a visual standpoint. A more interesting technique that I don&#x2019;t see discussed often enough is shrinking images. Particularly when it comes to user-uploaded content, images tend to be freaking huge. A screenshot on a typical Mac tends to be anywhere from <strong>700K</strong> to <strong>7MB</strong>, but they&#x2019;re also usually around <strong>3000px</strong> wide. A simila situation can be described about pictures taken with a phone.</p> <p><a href="https://github.com/imagemin/imagemin" target="_blank" aria-label="imagemin/imagemin on GitHub"><img alt="Image optimization tooling, including imagemin" class="" src="https://i.imgur.com/ldoRjyK.png"></a></p> <p>In most cases, you don&#x2019;t need high resolution fidelity in user uploaded content, and can get away with shrinking their images. If you reduce them to, say, at most <strong>700px</strong> in width, you&#x2019;ll save a considerable amount of bandwidth on every request being made for the images. If you have the infrastructure and can get away with saving different versions of the image <em>(original, small, medium, large)</em>, then all the better. Your mobile users will be eternally grateful!</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>When it comes to minification of images, <a href="https://github.com/imagemin/imagemin" target="_blank" aria-label="imagemin/imagemin on GitHub"><code class="md-code md-code-inline">imagemin</code></a> has your back. It has a plugin based architecture, and there&#x2019;s plugins for <a href="https://github.com/imagemin/imagemin-gifsicle" target="_blank" aria-label="imagemin/imagemin-gifsicle on GitHub"><code class="md-code md-code-inline">.gif</code></a>, <a href="https://github.com/imagemin/imagemin-jpegtran" target="_blank" aria-label="imagemin/imagemin-jpegtran on GitHub"><code class="md-code md-code-inline">.jpg</code></a>, <a href="https://github.com/imagemin/imagemin-optipng" target="_blank" aria-label="imagemin/imagemin-optipng on GitHub"><code class="md-code md-code-inline">.png</code></a>, <a href="https://github.com/imagemin/imagemin-svgo" target="_blank" aria-label="imagemin/imagemin-svgo on GitHub"><code class="md-code md-code-inline">.svg</code></a> and <strong><em>even <a href="https://github.com/imagemin/imagemin-webp" target="_blank" aria-label="imagemin/imagemin-webp on GitHub"><code class="md-code md-code-inline">.webp</code></a></em>!</strong> Each of the plugins wraps around robust tools that can be used to perform optimizations on the image binary as well as removing metadata artifacts, and it&#x2019;s all done on your behalf!</p> <p>Shrinking images isn&#x2019;t that hard, and we can use GraphicsMagick for that, or the <a href="https://github.com/aheckmann/gm" target="_blank" aria-label="aheckmann/gm on GitHub"><code class="md-code md-code-inline">gm</code></a> package in Node. Here&#x2019;s a programmatic one-liner to shrink images with a callback.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">shrink</span> <span class="md-code-params">(file, limits, done)</span> </span>{
  gm(file).autoOrient()<mark class="md-mark md-code-mark">.resize(limits.width, limits.height)</mark>.write(file, done);
}
</code></pre> </blockquote> <h3 id="defer-images-below-the-fold">Defer Images Below the Fold</h3> <p>Images below the fold are usually loaded alongside most of the document, unnecessarily eating up resources that could be better leveraged elsewhere while the images are not in the viewport. There&#x2019;s quite a few ways you could load them asynchronously. Maybe as the user scrolls, like some fancy sites do, or maybe just after the initial page load.</p> <p>Considering they&#x2019;re non-critical assets, since they&#x2019;re not even visible, the bandwidth would be better spent elsewhere!</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>We&#x2019;ve already covered this earlier! Head back to <a href="https://ponyfoo.com/#defer-non-critical-asset-loading" aria-label="Defer non-critical Asset Loading"><em>&#x201C;Defer non-critical Asset Loading&#x201D;</em></a>.</p> </blockquote> <h3 id="create-spritesheets-using-tools">Create Spritesheets using Tools</h3> <p>This one should be obvious to the modern developer, but I&#x2019;ll just add this here in case a designer is reading this and they&#x2019;re working alongside sadistic developers. Don&#x2019;t have your designers maintain spritesheets by hand anymore. It&#x2019;s 2015, try and have them keep icons in individual files, and use tools to create the spritesheets. It&#x2019;ll translate into much faster iteration cycles for you as well &#x2013; even if it costs you some satisfaction from being a sadistic bastard.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>You could use <a href="https://github.com/Ensighten/spritesmith" target="_blank" aria-label="Ensighten/spritesmith on GitHub"><code class="md-code md-code-inline">spritesmith</code></a> to generate your spritesheets and their accompanying CSS. The cool thing is that they&#x2019;re able to produce output for SASS, LESS, Stylus, plain CSS, and even JSON. You can use the output as variables in your pre-processors, and it&#x2019;s pretty easy to have it produce both <strong>@1x</strong> and <strong>@2x</strong> icons <em>(retina)</em> as well.</p> <p><a href="https://github.com/Ensighten/spritesmith" target="_blank" aria-label="Ensighten/spritesmith on GitHub"><img alt="" class="" src="https://i.imgur.com/JF118g3.png"></a></p> </blockquote> <h2 id="what-about-javascript">What about JavaScript?</h2> <p>You should be able to live without it. I always feel kind of weird when I say this out loud at JavaScript conferences. The point is about circling back to what we&#x2019;ve discussed about the server-side rendering earlier. Content shouldn&#x2019;t be dependant on JavaScript to be rendered, that&#x2019;s just way too slow on first load. On subsequent loads that&#x2019;s great. For the love of god though, embrace server-side rendering.</p> <h3 id="defer-all-of-it">Defer All of It</h3> <p>Again reinforcing the point. You should be able to defer all JavaScript. Ads, Twitter embeds, share buttons, client-side controllers, client-side rendering, you name it, you should defer it. Load it asynchronously and make your site gradually resilient to the harsh and brave new world of spotty mobile connectivity.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>Use a combination of server-side rendering, <em>to quickly get your content to human eyeballs</em>, and <code class="md-code md-code-inline">&lt;script async&gt;</code> to defer JavaScript without blocking execution. Architect your application in such a way that buttons and forms still work while JavaScript is being downloaded, so basic interaction with the site is still plausible in the slow-loading world of mobile networks.</p> <p>See <a href="https://github.com/taunus/taunus" target="_blank" aria-label="taunus/taunus on GitHub">Taunus</a> as a possible way in which you can boost progressive rendering in your future applications.</p> </blockquote> <h3 id="use-small-modules">Use Small Modules</h3> <p>Luckily I don&#x2019;t have to fight that hard to explain this one anymore. ES6 modules are on the rise and everyone else seems to be using Browserify. This is great stuff. Let&#x2019;s keep it up. If you&#x2019;re already on the modularity boat, I encourage you to introspect and see if you can build smaller modules than you currently are building. If you&#x2019;re not yet using ES6 modules or Browserify, try and make the switch soon. You&#x2019;re missing out, and the alternatives won&#x2019;t be around for long. Except maybe for Webpack, <em>meh</em>.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>Developing code in small modules is a matter of habit. If you haven&#x2019;t yet, consider <a href="https://ponyfoo.com/articles/food-for-thought-begins" aria-label="Blogging and OSS &#x2014; Food for Thought">becoming an open-source communist</a>, as that&#x2019;ll get you in the habit of writing small, focused modules that follow the unbreakable principle of <em>&#x201C;doing exactly one thing, and doing it well&#x201D;</em>.</p> <p>If open-source isn&#x2019;t your bread and butter you would still benefit from using either Browserify or ES6 modules exclusively for a few months. As long as you keep your modules short, even if you force yourself to do it, over time you&#x2019;ll see how you start putting together cleaner API touch points that foster reusability and code clarity.</p> </blockquote> <h3 id="vendor-scripts-sold-separately">Vendor Scripts Sold Separately</h3> <p>Cache vendor scripts on a bundle of their own. This is usually quite useful because vendor scripts tend to not change as often as user scripts, so you can have them cached for longer. If you serve different user scripts on each page, all the better, chances are you still need most of the vendor scripts across all pages anyways.</p> <blockquote> <h4 id="implementation">Implementation</h4> <p>Just split third party scripts from the ones you&#x2019;ve written, and serve them as different bundles.</p> </blockquote> <h1 id="phew-that-s-all-i-had">Phew, that&#x2019;s all I had!</h1> <p>Hope you&#x2019;ve found any of this useful and are able to put some of it to good use. In case you&#x2019;ve missed it, <a href="https://ponyfoo.com/articles/talk-about-web-performance" aria-label="Let&apos;s talk about Web Performance">the previous part</a> described how to identify issues during continuous integration, which might also come in handy.</p></div>
