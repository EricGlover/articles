<h1>Dream of Browser Test Automation?</h1>

<p><kbd>tape</kbd> <kbd>automation</kbd> <kbd>browser-testing</kbd> <kbd>build</kbd></p>

<blockquote><p>Browser testing has been a pain for a decade now. The landscape is showing a lot of promise nowadays, and I wanted to share the approach to client-side testing &#x2026;</p></blockquote>

<div><p>Browser testing has been a pain for a decade now. The landscape is showing a lot of promise nowadays, and I wanted to share the approach to client-side testing I&#x2019;ve taken with <a href="https://github.com/bevacqua/dragula" target="_blank"><code class="md-code md-code-inline">dragula</code></a>. In this article, you&#x2019;ll see <em>what&#x2019;s so wonderful about Tape</em>, why TAP is the future of browser testing, and how you can leverage it to the fullest in both development flows and continuous integration environments such as <a href="https://travis-ci.org/bevacqua/dragula" target="_blank">Travis CI</a>.</p></div>

<div></div>

<div><p>By now you must&#x2019;ve read <a href="https://ponyfoo.com/articles/testing-javascript-modules-with-tape">how I use <code class="md-code md-code-inline">tape</code> for all the things</a>, or how others <a href="https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4" target="_blank">do as well</a>. Am I the only one here amused that we wrote <em>almost identical articles</em> about Tape, and published them <strong>on the same day</strong>? We&#x2019;ve already covered why Tape is better than Mocha et al. It&#x2019;s modular, it&#x2019;s sensical, and it <a href="https://testanything.org/" target="_blank">produces TAP output</a>.</p> <p>When it comes to server-side code, consider a module like this:</p> <pre class="md-code-block"><code class="md-code">function greet (name) {
  return &apos;hi &apos; + name;
}
module.exports = greet;
</code></pre> <p>A test written in <code class="md-code md-code-inline">tape</code> might look like:</p> <pre class="md-code-block"><code class="md-code">var test = require(&apos;tape&apos;);
var greet = require(&apos;../greet&apos;);

test(&apos;greeting produces a salutation&apos;, function (t) {
  t.equal(greet(&apos;stranger&apos;), &apos;hi stranger&apos;, &apos;greeting is proper and amicable&apos;);
  t.end();
});
</code></pre> <p>Running the above test might involve adding a <code class="md-code md-code-inline">test</code> script to your <code class="md-code md-code-inline">scripts</code> in the <code class="md-code md-code-inline">package.json</code> manifest, like below.</p> <pre class="md-code-block"><code class="md-code">{
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;node test/*.js&quot;
  }
}
</code></pre> <p>I cheated, and that piece of code will run any test files inside the <code class="md-code md-code-inline">test</code> directory. To run that, simply use the <code class="md-code md-code-inline">npm run</code> alias for <code class="md-code md-code-inline">test</code>.</p> <pre class="md-code-block"><code class="md-code">npm test
</code></pre> <p>How do we deal with the DOM, continuous testing during development hours, and continuous integration on remote server? For the answers, we might want to go back to the seemingly innocuous <a href="https://testanything.org/" target="_blank">TAP output</a> from <code class="md-code md-code-inline">tape</code>.</p></div>

<div><h1 id="the-beauty-of-tap">The beauty of TAP</h1> <p>TAP being <mark class="md-mark">a precisely defined format</mark> means that any programs that can process or output TAP can be connected through UNIX pipes. Like most good things in programming, this is deceitfully simple. Consider, for example, the case of reporters. There are <a href="https://github.com/substack/tape#pretty-reporters" target="_blank" aria-label="Pretty TAP reporters">over a dozen TAP reporters</a> listed on the <code class="md-code md-code-inline">tape</code>. This is a familiar concept in test tooling. The tool generates output that can then be formatted, <em>in turn</em>, by a reporter that highlights the types of information we care about <em>(failing tests, diffs, nyan cats, etc)</em>. TAP can also be used for transformations, such as the hacks code coverage tools like <a href="https://github.com/substack/coverify" target="_blank" aria-label="substack/coverify on GitHub">coverify</a> do to figure out how good your code coverage is.</p> <p>Then there&#x2019;s continuous testing flows and continuous integration. Let&#x2019;s start with the former.</p> <h1 id="continuous-testing-with-hihat">Continuous Testing with <code class="md-code md-code-inline">hihat</code></h1> <p><a href="https://github.com/Jam3/hihat" target="_blank" aria-label="Jam3/hihat on GitHub"><code class="md-code md-code-inline">hihat</code></a> is a shiny new package created only two months ago, but it&#x2019;s potential and usability are both huge. Let me just demonstrate using a screenshot.</p> <p><a href="https://github.com/Jam3/hihat" target="_blank" aria-label="Jam3/hihat on GitHub"><img alt="A gif depicting hihat in action" class="" src="https://camo.githubusercontent.com/c6f8071b302eb0bfd62fe50d97599b4071e52ad5/687474703a2f2f692e696d6775722e636f6d2f537170626a7a6c2e676966"></a></p> <p>You may have noticed that in the demo they use <code class="md-code md-code-inline">tap-dev-tool</code>. This is a reporter that prettifies TAP for our particular use case &#x2013; rendering the tests on a DevTools instance. The way <code class="md-code md-code-inline">hihat</code> works is really cool. It uses <a href="https://github.com/atom/electron" target="_blank" aria-label="atom/electron on GitHub">Electron</a> behind the curtains, the runtime used under <a href="http://atom.io/" target="_blank" aria-label="Atom Editor">GitHub&#x2019;s Atom editor</a>. In case it&#x2019;s not obvious from the demo, <code class="md-code md-code-inline">hihat</code> reloads the DevTools whenever you make a change to your code.</p> <p>If you&#x2019;re anything like me, your first impression when you saw that screenshot was <strong>&#x201C;that&#x2019;s too good to be true&#x201D;</strong>, and your second impression probably was something along the lines of <em>&#x201C;there&#x2019;s no way that&#x2019;s easy to set up&#x201D;</em>.</p> <p>Turns out, it&#x2019;s freaking easy to set up. First, install things.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">npm i -D hihat tap-dev-tool
</code></pre> <p><sub><em>In case you were wondering, <code class="md-code md-code-inline">i</code> is one of plenty of shortcuts for install, and <code class="md-code md-code-inline">-D</code> aliases <code class="md-code md-code-inline">--save-dev</code>.</em></sub></p> <p>Then, make a slight change to your <code class="md-code md-code-inline">package.json</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">scripts</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">test</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;hihat test/*.js -p tap-dev-tool&quot;</span>
  </span>}
</span>}
</code></pre> <p>Now you can just run the tests that you used to run simply in Node, <strong>within a DevTools instance</strong> <em>(effectively, in Chromium)</em>, and it will watch for changes! Super amazeballs.</p> <h1 id="continuous-integration-with-testron">Continuous Integration with <code class="md-code md-code-inline">testron</code></h1> <p>A very similar and complementary tool to <code class="md-code md-code-inline">hihat</code> is <a href="https://github.com/shama/testron" target="_blank" aria-label="shama/testron on GitHub"><code class="md-code md-code-inline">testron</code></a>. Testron takes the output from your <code class="md-code md-code-inline">browserify</code> build and runs it through <a href="https://github.com/atom/electron" target="_blank" aria-label="atom/electron on GitHub"><code class="md-code md-code-inline">electron</code></a> as well. Testron is designed to run on the command-line, so you won&#x2019;t get any fancy DevTools. But, Testron does make it dead simple to run your browser tests on Chromium.</p> <p>Just like <code class="md-code md-code-inline">hihat</code>, <code class="md-code md-code-inline">testron</code> is dead simple to use.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">browserify <span class="md-code-built_in">test</span>/* | testron
</code></pre> <p>That&#x2019;s it!</p> <p><a href="https://travis-ci.org/bevacqua/dragula" target="_blank" aria-label="bevacqua/dragula on Travis"><img alt="Testron running our client-side tests on Travis" class="" src="https://i.imgur.com/1lhObnf.png"></a></p> <h1 id="bonus-errorify">Bonus: <code class="md-code md-code-inline">errorify</code></h1> <p>During development, you can save precious think-shark-tank seconds by using <a href="https://github.com/zertosh/errorify" target="_blank" aria-label="zertosh/errorify on GitHub"><code class="md-code md-code-inline">errorify</code></a>. It&#x2019;s meant to be used together with <a href="https://github.com/substack/watchify" target="_blank" aria-label="substack/watchify on GitHub"><code class="md-code md-code-inline">watchify</code></a>, and it&#x2019;ll <code class="md-code md-code-inline">tee</code> compile errors into the terminal and a bundle whose sole purpose is to tell you that the bundle failed to compile from within the HTML.</p> <p>This way, you can save some time figuring out <em>&#x201C;oh, it failed to compile, probably missed a semicolon&#x201D;</em>, or similar situations. Stop tabbing between your terminal and your browser today!</p></div>
