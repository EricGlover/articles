<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth"><div></div></a>

<h1><p>ES6 Arrow Functions in Depth</p></h1>

<p><kbd>es6</kbd> <kbd>arrow-functions</kbd> <kbd>es6-in-depth</kbd></p>

<blockquote><p>The daily saga of <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">es6-in-depth</a> articles continues. Today we&#x2019;ll be discussing Arrow Functions. In previous articles we&#x2019;ve covered <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a> and <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template &#x2026;</a></p></blockquote>

<div><p>The daily saga of <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">es6-in-depth</a> articles continues. Today we&#x2019;ll be discussing Arrow Functions. In previous articles we&#x2019;ve covered <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a> and <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>. I strive to cover <em>all the things</em> when it comes to the ES6 feature-set &#x2013; and eventually we&#x2019;ll move onto ES7. I find that writing about these features makes it way easier for them to become <strong>engraved in my skull</strong> as well.</p></div>

<div></div>

<div><p>Since you&#x2019;re reading these articles, I suggest you <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel and <code class="md-code md-code-inline">babel-node</code></a>, and follow along by copying the self-contained examples into a file. You can then run them using <code class="md-code md-code-inline">babel-node yourfile</code> in the terminal. Running these examples on your own and maybe tweaking them a little bit <strong>will help you better internalize these new features</strong> &#x2013; even if you&#x2019;re just adding <code class="md-code md-code-inline">console.log</code> statements to figure out what&#x2019;s going on.</p> <blockquote> <p>Now onto the topic of the day.</p> </blockquote> <p>We&#x2019;ve already kind of went over <em>arrow functions</em> in previous articles, using them in passing without a lot of explaining going on. This article will focus mainly in arrow functions and keep the rest of ES6 in the back burner. I think that&#x2019;s the best way to write about ES6 &#x2013; making a single feature &#x201C;stand out&#x201D; in each article, and gradually adding the others and interconnecting the different concepts so that we can understand <em>how they interact together</em>. I&#x2019;ve observed <strong>a lot of synergy</strong> in ES6 features, which is <em>awesome</em>. It&#x2019;s still important to make a gradual dive into ES6 syntax and features and not jump into the water as it&#x2019;s warming up, because otherwise you&#x2019;ll have a bad time adjusting to the new temperature &#x2013; that was probably a bad analogy, moving on.</p></div>

<div><h2 id="using-arrow-functions-in-javascript">Using Arrow Functions in JavaScript</h2> <p>Arrow functions are available to many other modern languages and was one of the features I sorely missed a few years ago when I moved from C# to JavaScript. Fortunately, they&#x2019;re now part of ES6 and thus available to us in JavaScript. The syntax is quite expressive. We already had anonymous functions, but sometimes it&#x2019;s nice to have a terse alternative.</p> <p>Here&#x2019;s how the syntax looks like if we have a single argument and just want to return the results for an expression.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(num =&gt; num * <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- [2, 4, 6]</span>
</code></pre> <p>The ES5 equivalent would be as below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(num)</span> </span>{ <span class="md-code-keyword">return</span> num * <span class="md-code-number">2</span> })
<span class="md-code-comment">// &lt;- [2, 4, 6]</span>
</code></pre> <p>If we need to declare more arguments <em>(or no arguments)</em>, we&#x2019;ll have to use parenthesis.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>].map((num, index) =&gt; num * <span class="md-code-number">2</span> + index)
<span class="md-code-comment">// &lt;- [2, 5, 8, 11]</span>
</code></pre> <p>You might want to have some other statements and not just an expression to return. In this case you&#x2019;ll have to use bracket notation.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>].map(num =&gt; {
  <span class="md-code-keyword">var</span> multiplier = <span class="md-code-number">2</span> + num
  <span class="md-code-keyword">return</span> num * multiplier
})
<span class="md-code-comment">// &lt;- [3, 8, 15, 24]</span>
</code></pre> <p>You could also add more arguments with the parenthesis syntax here.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>].map((num, index) =&gt; {
  <span class="md-code-keyword">var</span> multiplier = <span class="md-code-number">2</span> + index
  <span class="md-code-keyword">return</span> num * multiplier
})
<span class="md-code-comment">// &lt;- [2, 6, 12, 20]</span>
</code></pre> <p>At that point, however, chances are you&#x2019;d be better off using a named function declaration for a number of reasons.</p> <ul> <li><code class="md-code md-code-inline">(num, index) =&gt;</code> is only marginally shorter than <code class="md-code md-code-inline">function (num, index)</code></li> <li>The <code class="md-code md-code-inline">function</code> form allows you to name the method, improving code quality</li> <li>When a function has multiple arguments and multiple statements, I&#x2019;d say it&#x2019;s improbable that six extra characters will make a difference</li> <li>However, naming the method might add just enough context into the equation that those six extra characters (plus method name) become really worthwhile</li> </ul> <p>Moving on, if we need to return an object literal, we&#x2019;ll have to wrap the expression in parenthesis. That way the object literal won&#x2019;t be interpreted as a statement block (which would result in a silent error or worse, a <strong>syntax error</strong> because <code class="md-code md-code-inline">number: n</code> isn&#x2019;t a valid expression in the example below. The first example interprets <code class="md-code md-code-inline">number</code> as a label and then figures out we have an <code class="md-code md-code-inline">n</code> expression. Since we&#x2019;re in a block and not returning anything, the mapped values will be <code class="md-code md-code-inline">undefined</code>. In the second case, after the label and the <code class="md-code md-code-inline">n</code> expression, <code class="md-code md-code-inline">, something: &apos;else&apos;</code> makes no sense to the compiler, and a <code class="md-code md-code-inline">SyntaxError</code> is thrown.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; { number: n })
<span class="md-code-comment">// [undefined, undefined, undefined]</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; { number: n, something: <span class="md-code-string">&apos;else&apos;</span> })
<span class="md-code-comment">// &lt;- SyntaxError</span>
</code></pre> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; ({ number: n }))
<span class="md-code-comment">// &lt;- [{ number: 1 }, { number: 2 }, { number: 3 }]</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; ({ number: n, something: <span class="md-code-string">&apos;else&apos;</span> }))
<span class="md-code-comment">/* &lt;- [
  { number: 1, something: &apos;else&apos; },
  { number: 2, something: &apos;else&apos; },
  { number: 3, something: &apos;else&apos; }]
*/</span>
</code></pre> <p>A cool aspect of arrow functions in ES6 is that they&#x2019;re bound to their lexical scope. That means that you can say goodbye to <code class="md-code md-code-inline">var self = this</code> and similar hacks <em>&#x2013; such as using <code class="md-code md-code-inline">.bind(this)</code> &#x2013;</em> to preserve the context from within deeply nested methods.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Timer</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">this</span>.seconds = <span class="md-code-number">0</span>
  setInterval(() =&gt; <span class="md-code-keyword">this</span>.seconds++, <span class="md-code-number">1000</span>)
}
<span class="md-code-keyword">var</span> timer = <span class="md-code-keyword">new</span> Timer()
setTimeout(() =&gt; <span class="md-code-built_in">console</span>.log(timer.seconds), <span class="md-code-number">3100</span>)
<span class="md-code-comment">// &lt;- 3</span>
</code></pre> <p>Keep in mind that the lexical <code class="md-code md-code-inline">this</code> binding in ES6 arrow functions means that <code class="md-code md-code-inline">.call</code> and <code class="md-code md-code-inline">.apply</code> won&#x2019;t be able to change the context. Usually however, that&#x2019;s more of a feature than a bug.</p> <h2 id="conclusions">Conclusions</h2> <p>Arrow functions are neat when it comes to defining anonymous functions that should probably be <em>lexically bound anyways</em>, and they can definitely make your code more terse in some situations.</p> <p>There&#x2019;s no reason why you should be turning all of your function declarations into arrow functions unless their arguments and expression body are descriptive enough. I&#x2019;m a big proponent of named function declarations, because they improve readability of the codebase without the need for comments &#x2013; which means I&#x2019;ll have <em>&#x201C;a hard time&#x201D;</em> adopting arrow functions in most situations.</p> <p>That being said, I think arrow functions are particularly useful in most functional programming situations such as when using <code class="md-code md-code-inline">.map</code>, <code class="md-code md-code-inline">.filter</code>, or <code class="md-code md-code-inline">.reduce</code> on collections. Similarly, arrow functions will be really useful in asynchronous flows since those typically have a bunch of callbacks that just do argument balancing, a situation where arrow functions really shine.</p></div>
