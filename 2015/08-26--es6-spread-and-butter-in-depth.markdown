<h1>ES6 Spread and Butter in Depth</h1>

<blockquote><p>Welcome to yet another installment of <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> on Pony Foo. Previous ones covered <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, and most recently, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>. Today &#x2026;</p></blockquote>

<div><kbd>es6</kbd> <kbd>spread</kbd> <kbd>rest</kbd> <kbd>es6-in-depth</kbd></div>

<div><p>Welcome to yet another installment of <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> on Pony Foo. Previous ones covered <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, and most recently, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>. Today we&#x2019;ll cover a few more features coming in ES6. Those features are <em>rest parameters, the spread operator, and default parameters.</em></p></div>

<div></div>

<div><p>We&#x2019;ve already covered some of this when we talked <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">about destructuring</a>, which supports default values as a nod to the <strong>synergy in ES6 features</strong> I&#x2019;ve <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">mentioned yesterday</a>. This article might end up being a tad shorter than the rest because there&#x2019;s not so much to say about these rather simple features. However, and like I&#x2019;ve mentioned in the first article of the <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series, the simplest features are usually <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth#destructuring">the most useful</a> as well. Let&#x2019;s get on with it!</p></div>

<div><h2 id="rest-parameters">Rest parameters</h2> <p>You know how sometimes there&#x2019;s a ton of arguments and you end up having to use the <code class="md-code md-code-inline">arguments</code> magic variable to work with them? Consider the following method that joins any arguments passed to it as a string.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">concat</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Array</span>.prototype.slice.call(<span class="md-code-built_in">arguments</span>).join(<span class="md-code-string">&apos; &apos;</span>)
}
<span class="md-code-keyword">var</span> result = concat(<span class="md-code-string">&apos;this&apos;</span>, <span class="md-code-string">&apos;was&apos;</span>, <span class="md-code-string">&apos;no&apos;</span>, <span class="md-code-string">&apos;fun&apos;</span>)
<span class="md-code-built_in">console</span>.log(result)
<span class="md-code-comment">// &lt;- &apos;this was no fun&apos;</span>
</code></pre> <p>The rest parameters syntax enables you to pull a real <code class="md-code md-code-inline">Array</code> out of the <code class="md-code md-code-inline">function</code>&apos;s arguments by adding a parameter name prefixed by <code class="md-code md-code-inline">...</code>. Definitely simpler, the fact that it&#x2019;s a real <code class="md-code md-code-inline">Array</code> is also very convenient, and I for one am glad not to have to resort to <code class="md-code md-code-inline">arguments</code> anymore.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">concat</span> <span class="md-code-params">(...words)</span> </span>{
  <span class="md-code-keyword">return</span> words.join(<span class="md-code-string">&apos; &apos;</span>)
}
<span class="md-code-keyword">var</span> result = concat(<span class="md-code-string">&apos;this&apos;</span>, <span class="md-code-string">&apos;is&apos;</span>, <span class="md-code-string">&apos;okay&apos;</span>)
<span class="md-code-built_in">console</span>.log(result)
<span class="md-code-comment">// &lt;- &apos;this is okay&apos;</span>
</code></pre> <p>When you have more parameters in your <code class="md-code md-code-inline">function</code> it works slightly different. Whenever I declare a method that has a rest parameter, I like to think of its behavior as follows.</p> <ul> <li>Rest parameter gets all the <code class="md-code md-code-inline">arguments</code> passed to the function call</li> <li>Each time a parameter is added on the left, it&#x2019;s as if its value is assigned by calling <code class="md-code md-code-inline">rest.shift()</code></li> <li>Note that you can&#x2019;t actually place parameters to the right: rest parameters can only be the last argument</li> </ul> <p>It&#x2019;s easier to visualize how that would behave than try to put it into words, so let&#x2019;s do that. The method below computes the <code class="md-code md-code-inline">sum</code> for all <code class="md-code md-code-inline">arguments</code> except the first one, which is then used as a <code class="md-code md-code-inline">multiplier</code> for the <code class="md-code md-code-inline">sum</code>. In case you don&#x2019;t recall, <code class="md-code md-code-inline">.shift()</code> returns the first value in an array, and also removes it from the collection, which makes it a useful mnemonic device in my opinion.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">var</span> numbers = <span class="md-code-built_in">Array</span>.prototype.slice.call(<span class="md-code-built_in">arguments</span>) <span class="md-code-comment">// numbers gets all arguments</span>
  <mark class="md-mark md-code-mark">var multiplier = numbers.shift()</mark>
  <mark class="md-mark md-code-mark">var base = numbers.shift()</mark>
  <span class="md-code-keyword">var</span> sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base)
  <span class="md-code-keyword">return</span> multiplier * sum
}
<span class="md-code-keyword">var</span> total = sum(<span class="md-code-number">2</span>, <span class="md-code-number">6</span>, <span class="md-code-number">10</span>, <span class="md-code-number">8</span>, <span class="md-code-number">9</span>)
<span class="md-code-built_in">console</span>.log(total)
<span class="md-code-comment">// &lt;- 66</span>
</code></pre> <p>Here&#x2019;s how that method would look if we were to use the rest parameter to pluck the numbers. Note how we don&#x2019;t need to use <code class="md-code md-code-inline">arguments</code> nor do any shifting anymore. This is great because it vastly reduces the complexity in our method &#x2013; which now can focus on its functionality itself and not so much on rebalancing <code class="md-code md-code-inline">arguments</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span> <span class="md-code-params">(multiplier, base, <mark class="md-mark md-code-mark">...numbers</mark>)</span> </span>{
  <span class="md-code-keyword">var</span> sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base)
  <span class="md-code-keyword">return</span> multiplier * sum
}
<span class="md-code-keyword">var</span> total = sum(<span class="md-code-number">2</span>, <span class="md-code-number">6</span>, <span class="md-code-number">10</span>, <span class="md-code-number">8</span>, <span class="md-code-number">9</span>)
<span class="md-code-built_in">console</span>.log(total)
<span class="md-code-comment">// &lt;- 66</span>
</code></pre> <h2 id="spread-operator">Spread Operator</h2> <p>Typically you invoke a function by passing arguments into it.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- &apos;1 2 3&apos;</span>
</code></pre> <p>Sometimes however you have those arguments in a list and just don&#x2019;t want to access every index just for a method call <em>&#x2013; or you just can&#x2019;t because the array is formed dynamically &#x2013;</em> so you use <code class="md-code md-code-inline">.apply</code>. This feels kind of awkward because <code class="md-code md-code-inline">.apply</code> also takes a context for <code class="md-code md-code-inline">this</code>, which feels out of place when it&#x2019;s not relevant and you have to reiterate the host object <em>(or use <code class="md-code md-code-inline">null</code>)</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log.apply(<span class="md-code-built_in">console</span>, [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>])
<span class="md-code-comment">// &lt;- &apos;1 2 3&apos;</span>
</code></pre> <p>The spread operator can be used as <em>a butter knife</em> alternative over using <code class="md-code md-code-inline">.apply</code>. There is no need for a context either. You just append three dots <code class="md-code md-code-inline">...</code> to the array, just like with the rest parameter.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">...</mark>[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>])
<span class="md-code-comment">// &lt;- &apos;1 2 3&apos;</span>
</code></pre> <p>As we&#x2019;ll investigate more in-depth next monday, in the article about iterators in ES6, a nice perk of the spread operator is that it can be used on anything that&#x2019;s an <em>iterable</em>. This encompasses even things like the results of <code class="md-code md-code-inline">document.querySelectorAll(&apos;div&apos;)</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[...document.querySelectorAll(<span class="md-code-string">&apos;div&apos;</span>)]
<span class="md-code-comment">// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span>
</code></pre> <p>Another nice aspect of the <em>butter knife operator</em> is that you can <strong>mix and match</strong> regular arguments with it, and they&#x2019;ll be spread over the function call exactly how you&#x2019;d expect them to. This, too, can be <em>very very useful</em> when you have a lot of argument rebalancing going on in your ES5 code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-number">1</span>, ...[<span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>], <span class="md-code-number">5</span>) <span class="md-code-comment">// becomes `console.log(1, 2, 3, 4, 5)`</span>
<span class="md-code-comment">// &lt;- &apos;1 2 3 4 5&apos;</span>
</code></pre> <p>Time for a real-world example. I sometimes use the method below in Express applications to allow <a href="https://github.com/expressjs/morgan" target="_blank" aria-label="expressjs/morgan on GitHub"><code class="md-code md-code-inline">morgan</code></a> <em>(the request logger in Express)</em> stream its messages through <a href="https://github.com/winstonjs/winston" target="_blank" aria-label="winstonjs/winston on GitHub"><code class="md-code md-code-inline">winston</code></a>, a general purpose multi-transport logger. I remove the trailing line breaks from the <code class="md-code md-code-inline">message</code> because <code class="md-code md-code-inline">winston</code> already takes care of those. I also place some metadata about the currently executing process like the host and the process <code class="md-code md-code-inline">pid</code> into the arguments list, and then I <code class="md-code md-code-inline">.apply</code> everything on the <code class="md-code md-code-inline">winston</code> logging mechanism. If you take a close look at the code, the only line of code that&#x2019;s actually doing anything is the one I&#x2019;ve highlighted in yellow, the rest is just playing around with <code class="md-code md-code-inline">arguments</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
      <span class="md-code-keyword">var</span> bits = <span class="md-code-built_in">Array</span>.prototype.slice.call(<span class="md-code-built_in">arguments</span>)
      <span class="md-code-keyword">var</span> message = bits.shift().replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">&apos;&apos;</span>) <span class="md-code-comment">// remove trailing breaks</span>
      bits.unshift(message)
      bits.push({ hostname: os.hostname(), pid: process.pid })
      <mark class="md-mark md-code-mark">winston[level].apply(winston, bits)</mark>
    }
  }
}
app.use(morgan(<span class="md-code-string">&apos;:status :method :url&apos;</span>, {
  stream: createWriteStream(<span class="md-code-string">&apos;debug&apos;</span>)
}))
</code></pre> <p>We can thoroughly simplify the solution with ES6. First, we can use the rest parameter instead of relying on <code class="md-code md-code-inline">arguments</code>. The rest parameter already gives us a true array, so there&#x2019;s no casting involved either. We can grab the <code class="md-code md-code-inline">message</code> directly as the first parameter, and we can then apply everything on <code class="md-code md-code-inline">winston[level]</code> directly by combining normal arguments with the rest of the <code class="md-code md-code-inline">...bits</code> and pieces. The code below is <strong>in much better shape</strong>, as now every piece of it is actually relevant to what we&#x2019;re trying to accomplish, which is call <code class="md-code md-code-inline">winston[level]</code> with a few <em>modified arguments</em>. The piece of code we had earlier, in contrast, spent most time manipulating the arguments, and the focus quickly dissipated into <strong>a battle of wits against JavaScript itself</strong> &#x2013; <em>the method stopped being about the code we were trying to write.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(message, <mark class="md-mark md-code-mark">...bits</mark>)</span> </span>{
      winston[level](message.replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">&apos;&apos;</span>), <mark class="md-mark md-code-mark">...bits</mark>, {
        hostname: os.hostname(), pid: process.pid
      })
    }
  }
}
</code></pre> <p>We could further <em>simplify the method by pulling</em> the process metadata out, since that won&#x2019;t change for the lifespan of the process. We could&#x2019;ve done that in the ES5 code too, though.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> proc = { hostname: os.hostname(), pid: process.pid }
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(message, ...bits)</span> </span>{
      winston[level](message.replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">&apos;&apos;</span>), ...bits, proc)
    }
  }
}
</code></pre> <p>Another thing we could do to shorten that piece of code might be to use <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth" aria-label="ES6 Arrow Functions in Depth on Pony Foo">an arrow function</a>. In this case however, it <strong>would only complicate matters</strong>. You&#x2019;d have to shorten <code class="md-code md-code-inline">message</code> to <code class="md-code md-code-inline">msg</code> so that it fits in a single line, and the call to <code class="md-code md-code-inline">winston[level]</code> with the rest and spread operators in there makes it <strong>an incredibly complicated sight</strong> to anyone who <em>hasn&#x2019;t</em> spent the last 15 minutes thinking about the method <em>&#x2013; be it a team mate or yourself the week after you wrote this function.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> proc = { hostname: os.hostname(), pid: process.pid }
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: (msg, ...bits) =&gt; winston[level](msg.replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">&apos;&apos;</span>), ...bits, proc)
  }
}
</code></pre> <p>It would be wiser to just keep our earlier version. While it&#x2019;s <em>quite self-evident</em> in this case that an arrow function only <strong>piles onto the complexity</strong>, in other cases it might not be so. It&#x2019;s up to you to decide, and you need to be able to distinguish between using ES6 features because they genuinely improve your codebase and its maintainability, or <strong>whether you&#x2019;re actually decreasing maintainability</strong> by translating things into ES6 just for the sake of doing so.</p> <p>Some other useful uses are detailed below. You can obviously use the spread operator when creating a new array, but you can also use <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo">while destructuring</a>, in which case it works sort of like <code class="md-code md-code-inline">...rest</code> did, and a use case that&#x2019;s not going to come up often but is still worth mentioning is that you can use spread to pseudo-<code class="md-code md-code-inline">.apply</code> when using the <code class="md-code md-code-inline">new</code> operator as well.</p> <table> <thead> <tr> <th>Use Case</th> <th>ES5</th> <th>ES6</th> </tr> </thead> <tbody> <tr> <td>Concatenation</td> <td><code class="md-code md-code-inline">[1, 2].concat(more)</code></td> <td><code class="md-code md-code-inline">[1, 2, ...more]</code></td> </tr> <tr> <td>Push onto list</td> <td><code class="md-code md-code-inline">list.push.apply(list, [3, 4])</code></td> <td><code class="md-code md-code-inline">list.push(...[3, 4])</code></td> </tr> <tr> <td>Destructuring</td> <td><code class="md-code md-code-inline">a = list[0], rest = list.slice(1)</code></td> <td><code class="md-code md-code-inline">[a, ...rest] = list</code></td> </tr> <tr> <td><code class="md-code md-code-inline">new</code> + <code class="md-code md-code-inline">apply</code></td> <td><a href="http://stackoverflow.com/a/8843181/389745" target="_blank" aria-label="This is insanely unreadable. Avoid."><code class="md-code md-code-inline">new (Date.bind.apply(Date, [null,2015,31,8]))</code></a></td> <td><code class="md-code md-code-inline">new Date(...[2015,31,8])</code></td> </tr> </tbody> </table> <h2 id="default-operator">Default Operator</h2> <p>The default operator is something we&#x2019;ve covered in <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo">the destructuring article</a>, but only tangentially. Just like you can use default values during destructuring, you can define a default value for any parameter in a function, as shown below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span> <span class="md-code-params">(left=1, right=2)</span> </span>{
  <span class="md-code-keyword">return</span> left + right
}
<span class="md-code-built_in">console</span>.log(sum())
<span class="md-code-comment">// &lt;- 3</span>
<span class="md-code-built_in">console</span>.log(sum(<span class="md-code-number">2</span>))
<span class="md-code-comment">// &lt;- 4</span>
<span class="md-code-built_in">console</span>.log(sum(<span class="md-code-number">1</span>, <span class="md-code-number">0</span>))
<span class="md-code-comment">// &lt;- 1</span>
</code></pre> <p>Consider the code that initializes options in <a href="https://github.com/bevacqua/dragula/blob/f5f4c569780b0db160269e978eaf69dc36e421bb/dragula.js#L27-L37" target="_blank" aria-label="Option initialization in dragula on GitHub"><code class="md-code md-code-inline">dragula</code></a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">dragula</span> <span class="md-code-params">(options)</span> </span>{
  <span class="md-code-keyword">var</span> o = options || {};
  <span class="md-code-keyword">if</span> (o.moves === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.moves = always; }
  <span class="md-code-keyword">if</span> (o.accepts === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.accepts = always; }
  <span class="md-code-keyword">if</span> (o.invalid === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.invalid = invalidTarget; }
  <span class="md-code-keyword">if</span> (o.containers === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.containers = initialContainers || []; }
  <span class="md-code-keyword">if</span> (o.isContainer === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.isContainer = never; }
  <span class="md-code-keyword">if</span> (o.copy === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.copy = <span class="md-code-literal">false</span>; }
  <span class="md-code-keyword">if</span> (o.revertOnSpill === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.revertOnSpill = <span class="md-code-literal">false</span>; }
  <span class="md-code-keyword">if</span> (o.removeOnSpill === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.removeOnSpill = <span class="md-code-literal">false</span>; }
  <span class="md-code-keyword">if</span> (o.direction === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.direction = <span class="md-code-string">&apos;vertical&apos;</span>; }
  <span class="md-code-keyword">if</span> (o.mirrorContainer === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.mirrorContainer = body; }
}
</code></pre> <blockquote> <p>Do you think it would be useful to switch to default parameters under ES6 syntax? How would you do that?</p> </blockquote></div>
