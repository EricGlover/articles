<h1>ES6 Promises in Depth</h1>

<p><kbd>es6</kbd> <kbd>promise</kbd> <kbd>es6-in-depth</kbd></p>

<blockquote><p>Welcome back to <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Dude, we already had those!&#x201D;</em> &#x2013; in Depth</a> series. If you&#x2019;ve never been around here before, start with <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief &#x2026;</a></p></blockquote>

<div><p>Welcome back to <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Dude, we already had those!&#x201D;</em> &#x2013; in Depth</a> series. If you&#x2019;ve never been around here before, start with <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="https://ponyfoo.com/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>, <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a>, <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>, <a href="https://ponyfoo.com/articles/es6-symbols-in-depth">Symbols</a>, <a href="https://ponyfoo.com/articles/es6-maps-in-depth">Maps</a>, <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="https://ponyfoo.com/articles/es6-proxies-in-depth">proxies</a>, <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth">proxy traps</a>, <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="https://ponyfoo.com/articles/es6-reflection-in-depth">reflection</a>, <a href="https://ponyfoo.com/articles/es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>, <a href="https://ponyfoo.com/articles/es6-math-additions-in-depth"><code class="md-code md-code-inline">Math</code></a>, <a href="https://ponyfoo.com/articles/es6-array-extensions-in-depth"><code class="md-code md-code-inline">Array</code></a>, <a href="https://ponyfoo.com/articles/es6-object-changes-in-depth"><code class="md-code md-code-inline">Object</code></a>, <a href="https://ponyfoo.com/articles/es6-strings-and-unicode-in-depth"><code class="md-code md-code-inline">String</code></a>, and <a href="https://ponyfoo.com/articles/es6-modules-in-depth">the module system</a>. This morning is about the <code class="md-code md-code-inline">Promise</code> API in ES6.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for reading that, and let&#x2019;s go into <em>Promises</em> in ES6. Before reading this article you might want to read about <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, as they&#x2019;re heavily used throughout the article; and <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>, as they&#x2019;re somewhat related to the concepts discussed here.</p> <p>I also wanted to mention <em>Promisees</em> &#x2013; a <a href="http://buff.ly/1NyjC7k" target="_blank">promise visualization playground</a> I made last week. It offers in-browser visualizations of how promises unfold. You can run those visualizations step by step, displaying how promises in any piece of code work. You can also record a gif of those visualizations, a few of which I&#x2019;ll be displaying here in the article. Hope it helps!</p> <p><a href="http://buff.ly/1NyjC7k" target="_blank"><img src="https://i.imgur.com/XiRxWop.gif" alt="An animation showing a complicated promises visualization"></a></p> <p>If that animation looks insanely complicated to you, read on!</p></div>

<div><blockquote> <p>Promises are a very involved paradigm, so we&#x2019;ll take it slow.</p> </blockquote> <p>Here&#x2019;s a table of contents with the topics we&#x2019;ll cover in this article. Feel free to skip topics you&#x2019;re comfortable about.</p> <ul> <li><a href="https://ponyfoo.com/#what-is-a-promise">What is a Promise?</a> &#x2013; we define <code class="md-code md-code-inline">Promise</code> and look at a simple example in JavaScript <ul> <li><a href="https://ponyfoo.com/#callbacks-and-events">Callbacks and Events</a> &#x2013; alternative ways to handle asynchronous code flows</li> <li><a href="https://ponyfoo.com/#gist-of-a-promise">Gist of a <code class="md-code md-code-inline">Promise</code></a> &#x2013; a first glimpse at how promises work</li> </ul> </li> <li><a href="https://ponyfoo.com/#promises-in-time">Promises in Time</a> &#x2013; a brief history of promises</li> <li><a href="https://ponyfoo.com/#then-again">Then, Again</a> &#x2013; an analysis of <code class="md-code md-code-inline">.then</code> and <code class="md-code md-code-inline">.catch</code></li> <li><a href="https://ponyfoo.com/#creating-a-promise-from-scratch">Creating a Promise From Scratch</a></li> <li><a href="https://ponyfoo.com/#settling-a-promise">Settling a Promise</a> &#x2013; discusses states of a <code class="md-code md-code-inline">Promise</code></li> <li><a href="https://ponyfoo.com/#paying-a-promise-with-another-promise">Paying a Promise with another Promise</a> &#x2013; explains promise chaining</li> <li><a href="https://ponyfoo.com/#transforming-values-in-promises">Transforming Values in Promises</a> &#x2013; shows how to turn a result into something else in the context of promises</li> <li><a href="https://ponyfoo.com/#leveraging-promiseall-and-promiserace">Leveraging <code class="md-code md-code-inline">Promise.all</code> and <code class="md-code md-code-inline">Promise.race</code></a></li> </ul> <p>Shall we?</p> <h1 id="what-is-a-promise">What is a <code class="md-code md-code-inline">Promise</code>?</h1> <p>Promises are usually vaguely defined as <em>&#x201C;a proxy for a value that will eventually become available&#x201D;</em>. They can be used for both synchronous and asynchronous code flows, although they make asynchronous flows easier to reason about &#x2013; once you&#x2019;ve mastered promises, that is.</p> <p>Consider as an example the <em>upcoming</em> <a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch#Syntax" target="_blank" aria-label="fetch() API on MDN"><code class="md-code md-code-inline">fetch</code></a> API. This API is a simplification of <code class="md-code md-code-inline">XMLHttpRequest</code>. It aims to be super simple to use for the most basic use cases: making a <code class="md-code md-code-inline">GET</code> request against a resource relative to the current page over <code class="md-code md-code-inline">http(s)</code> &#x2013; it also provides a comprehensive API that caters to advanced use cases as well, but that&#x2019;s not our focus for now. In it&#x2019;s most basic incarnation, you can make a request for <code class="md-code md-code-inline">GET foo</code> like so.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>)
</code></pre> <p>The <code class="md-code md-code-inline">fetch(&apos;foo&apos;)</code> statement doesn&#x2019;t seem <a href="http://buff.ly/1NRZf70" target="_blank" aria-label="See it on Promisees">all that exciting</a>. It makes a <em>&#x201C;fire-and-forget&#x201D;</em> <code class="md-code md-code-inline">GET</code> request against <code class="md-code md-code-inline">foo</code> relative to the resource we&#x2019;re currently on. The <code class="md-code md-code-inline">fetch</code> method returns a <code class="md-code md-code-inline">Promise</code>. You can chain a <code class="md-code md-code-inline">.then</code> callback that will be executed once the <code class="md-code md-code-inline">foo</code> resource finishes loading.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>)<mark class="md-mark md-code-mark">.then</mark>(response =&gt; <span class="md-code-comment">/* do something */</span>)
</code></pre> <p>Promises offer an alternative to callbacks and events.</p> <h2 id="callbacks-and-events">Callbacks and Events</h2> <p>If the <code class="md-code md-code-inline">fetch</code> API used callbacks, you&#x2019;d get one last parameter that then gets executed whenever fetching ends. Typical asynchronous code flow conventions dictate that we allocate the first parameter for errors <em>(that may or may not occur)</em> during the <em>fetching process</em>. The rest of the parameters can be used to pass in resulting data. Often, a single parameter is used.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>, <mark class="md-mark md-code-mark">(err, res) =&gt; {</mark>
  <mark class="md-mark md-code-mark">if (err) {</mark>
    <span class="md-code-comment">// handle error</span>
  <mark class="md-mark md-code-mark">}</mark>
  <span class="md-code-comment">// handle response</span>
<mark class="md-mark md-code-mark">}</mark>)
</code></pre> <p>The callback wouldn&#x2019;t be invoked until the <code class="md-code md-code-inline">foo</code> resource has been fetched, so its execution remains asynchronous and non-blocking. Note that in this model you could only specify <strong>a single callback</strong>, and that callback would be responsible for <em>all functionality</em> derived from the response.</p> <p>Another option might have been to use an <em>event-driven</em> API model. In this model the object returned by <code class="md-code md-code-inline">fetch</code> would be able to listen <code class="md-code md-code-inline">.on</code> events, binding as many event handlers as needed for any events. Typically there&#x2019;s an <code class="md-code md-code-inline">error</code> event for when things go awry and a <code class="md-code md-code-inline">data</code> event that&#x2019;s called when the operation completes successfully.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>)
  <mark class="md-mark md-code-mark">.on</mark>(<span class="md-code-string">&apos;error&apos;</span>, <mark class="md-mark md-code-mark">err =&gt; {</mark>
    <span class="md-code-comment">// handle error</span>
  <mark class="md-mark md-code-mark">}</mark>)
  <mark class="md-mark md-code-mark">.on</mark>(<span class="md-code-string">&apos;data&apos;</span>, <mark class="md-mark md-code-mark">res =&gt; {</mark>
    <span class="md-code-comment">// handle response</span>
  <mark class="md-mark md-code-mark">}</mark>)
</code></pre> <p>In this case, errors usually end up in hard exceptions if no event listener is attached &#x2013; but that depends on what event emitter implementation is used. Promises are a bit different.</p> <h2 id="gist-of-a-promise">Gist of a <code class="md-code md-code-inline">Promise</code></h2> <p>Instead of binding event listeners through <code class="md-code md-code-inline">.on</code>, promises offer a slightly different API. The snippet of code shown below displays the actual API of the <code class="md-code md-code-inline">fetch</code> method, which returns a <code class="md-code md-code-inline">Promise</code> object. Much like with events, you can bind as many listeners as you&#x2019;d like with both <code class="md-code md-code-inline">.catch</code> and <code class="md-code md-code-inline">.then</code>. Note how there&#x2019;s no need for an event type anymore with the declarative methods used by promises.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> p = fetch(<span class="md-code-string">&apos;foo&apos;</span>)
<mark class="md-mark md-code-mark">p.then</mark>(<mark class="md-mark md-code-mark">res =&gt; {</mark>
  <span class="md-code-comment">// handle response</span>
<mark class="md-mark md-code-mark">}</mark>)
<mark class="md-mark md-code-mark">p.catch</mark>(<mark class="md-mark md-code-mark">error =&gt; {</mark>
  <span class="md-code-comment">// handle error</span>
<mark class="md-mark md-code-mark">}</mark>)
</code></pre> <p><sub>See [this example][(<a href="http://buff.ly/1KtWGUD" target="_blank">http://buff.ly/1KtWGUD</a>)] on Promisees</sub></p> <p>Also note that <code class="md-code md-code-inline">.then</code> is able to register a reaction to rejections as its second argument. The above could be expressed as the following piece of code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>)
  <mark class="md-mark md-code-mark">.then</mark>(
    <mark class="md-mark md-code-mark">res =&gt; {</mark>
      <span class="md-code-comment">// handle response</span>
    <mark class="md-mark md-code-mark">}</mark>,
    <mark class="md-mark md-code-mark">err =&gt; {</mark>
      <span class="md-code-comment">// handle error</span>
    <mark class="md-mark md-code-mark">}</mark>
  )
</code></pre> <p><sub>See [this example][(<a href="http://buff.ly/1V8xpHI" target="_blank">http://buff.ly/1V8xpHI</a>)] on Promisees</sub></p> <p>Just like you can omit the error reaction in <code class="md-code md-code-inline">.then(fulfillment)</code>, you can also omit the reaction to <em>fulfillment</em>. Using <code class="md-code md-code-inline">.then(null, rejection)</code> is equivalent to <code class="md-code md-code-inline">.catch(rejection)</code>. Note that <code class="md-code md-code-inline">.then</code> and <code class="md-code md-code-inline">.catch</code> return <strong>a new promise every time</strong>. That&#x2019;s important because chaining can have wildly different results depending on where you append a <code class="md-code md-code-inline">.then</code> or a <code class="md-code md-code-inline">.catch</code> call onto. See the <a href="http://buff.ly/1Pqh5ex" target="_blank">following example</a> to understand the difference.</p> <p><a href="http://buff.ly/1Pqh5ex" target="_blank"><img alt="Differences when chaining promises" class="" src="https://i.imgur.com/uwWnUq4.png"></a></p> <p>We&#x2019;ll get more in depth into these two methods in a bit. Let&#x2019;s look at a brief history of promises before doing that.</p> <h1 id="promises-in-time">Promises in Time</h1> <p>Promises aren&#x2019;t all that new. Like <em>most things in computer science</em>, the earliest mention of Promises can be traced all the way back to the <a href="https://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" aria-label="Futures and Promises on Wikipedia">late seventies</a>. According to the <em>Internet</em>, they made their first appearance in JavaScript in 2007 &#x2013; in a library called <code class="md-code md-code-inline">MochiKit</code>. Then <code class="md-code md-code-inline">Dojo</code> adopted it, and <code class="md-code md-code-inline">jQuery</code> followed shortly after that.</p> <p>Then the <a href="https://promisesaplus.com/" target="_blank" aria-label="An open standard for sound, interoperable JavaScript promises&#x2014;by implementers, for implementers.">Promises/A+</a> specification came out from the CommonJS group <em>(now famous for their CommonJS module specification)</em>. In its earliest incarnations, Node.js shipped with promises. Some time later, they were removed from core and everyone switched over to callbacks. Now, promises ship with the ES6 standard and V8 has already implemented them a while back.</p> <blockquote> <p>The ES6 standard implements <strong>Promises/A+</strong> natively. In the latest versions of Node.js you can use promises without any libraries. They&#x2019;re also available on Chrome 32+, Firefox 29+, and Safari 7.1+.</p> </blockquote> <p>Shall we go back to the <code class="md-code md-code-inline">Promise</code> API?</p> <h1 id="then-again">Then, Again</h1> <p>Going back to our example &#x2013; here&#x2019;s some of the code we had. In the simplest use case, this is all we wanted.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>)<mark class="md-mark md-code-mark">.then</mark>(<mark class="md-mark md-code-mark">res =&gt; {</mark>
  <span class="md-code-comment">// handle response</span>
<mark class="md-mark md-code-mark">}</mark>)
</code></pre> <p>What if an error happens in one of the reactions passed to <code class="md-code md-code-inline">.then</code>? You can catch those with <code class="md-code md-code-inline">.catch</code>. The example in the snippet below <a href="http://buff.ly/1Jo8NyJ" target="_blank">logs the error</a> caught when trying to access <code class="md-code md-code-inline">prop</code> from the <em>undefined <code class="md-code md-code-inline">a</code> property</em> in <code class="md-code md-code-inline">res</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>)
  .then(res =&gt; res.a.prop.that.does.not.exist)
  .catch(err =&gt; <mark class="md-mark md-code-mark">console.error(err.message)</mark>)
<span class="md-code-comment">// &lt;- &apos;Cannot read property &quot;prop&quot; of undefined&apos;</span>
</code></pre> <p>Note that <em>where</em> you tack your reactions onto matters. The following example <strong>won&#x2019;t</strong> print the <code class="md-code md-code-inline">err.message</code> twice &#x2013; only once. That&#x2019;s because no errors happened in the first <code class="md-code md-code-inline">.catch</code>, so the rejection branch for that promise wasn&#x2019;t executed. Check out <a href="http://buff.ly/1gLqKjU" target="_blank">the Promisee</a> for a visual explanation of the code below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>)
  .then(res =&gt; res.a.prop.that.does.not.exist)
  .catch(err =&gt; <span class="md-code-built_in">console</span>.error(err.message))
  .catch(err =&gt; <span class="md-code-built_in">console</span>.error(err.message))
<span class="md-code-comment">// &lt;- &apos;Cannot read property &quot;prop&quot; of undefined&apos;</span>
</code></pre> <p>In contrast, the snippet found below <em>will</em> <a href="http://buff.ly/1PqlHS2" target="_blank">print the <code class="md-code md-code-inline">err.message</code> twice</a>. It works by saving a reference to the promise returned by <code class="md-code md-code-inline">.then</code>, and then tacking two <code class="md-code md-code-inline">.catch</code> reactions onto it. The second <code class="md-code md-code-inline">.catch</code> in the previous example was capturing errors produced in the promise returned from the first <code class="md-code md-code-inline">.catch</code>, while in this case both <code class="md-code md-code-inline">.catch</code> branch off of <code class="md-code md-code-inline">p</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> p = fetch(<span class="md-code-string">&apos;foo&apos;</span>).then(res =&gt; res.a.prop.that.does.not.exist)
p.catch(err =&gt; <span class="md-code-built_in">console</span>.error(err.message))
p.catch(err =&gt; <span class="md-code-built_in">console</span>.error(err.message))
<span class="md-code-comment">// &lt;- &apos;Cannot read property &quot;prop&quot; of undefined&apos;</span>
<span class="md-code-comment">// &lt;- &apos;Cannot read property &quot;prop&quot; of undefined&apos;</span>
</code></pre> <p>Here&#x2019;s another example that puts that difference the spotlight. The second catch is triggered this time because it&#x2019;s <a href="http://buff.ly/1Jo9KHf" target="_blank">bound to the rejection branch</a> on the first <code class="md-code md-code-inline">.catch</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>)
  .then(res =&gt; res.a.prop.that.does.not.exist)
  .catch(err =&gt; { <mark class="md-mark md-code-mark">throw</mark> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(err.message) })
  .catch(err =&gt; <span class="md-code-built_in">console</span>.error(err.message))
<span class="md-code-comment">// &lt;- &apos;Cannot read property &quot;prop&quot; of undefined&apos;</span>
</code></pre> <p>If the first <code class="md-code md-code-inline">.catch</code> call didn&#x2019;t return anything, then <a href="http://buff.ly/1Jo9KHf" target="_blank">nothing would be printed</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>)
  .then(res =&gt; res.a.prop.that.does.not.exist)
  .catch(err =&gt; <mark class="md-mark md-code-mark">{}</mark>)
  .catch(err =&gt; <span class="md-code-built_in">console</span>.error(err.message))
<span class="md-code-comment">// nothing happens</span>
</code></pre> <p>We should observe, then, that promises can be chained &#x201C;arbitrarily&#x201D;, that is to say: as we just saw, you can save a reference to any point in the promise chain and then tack more promises on top of it. This is one of the fundamental points to understanding promises.</p> <blockquote> <p>You can save a reference to any point in the promise chain.</p> </blockquote> <p>In fact, the last example can be represented as shown below. This snippet makes it much easier to understand what we&#x2019;ve discussed so far. Glance over it and then I&#x2019;ll give you some bullet points.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> <mark class="md-mark md-code-mark">p1</mark> = fetch(<span class="md-code-string">&apos;foo&apos;</span>)
<span class="md-code-keyword">var</span> <mark class="md-mark md-code-mark">p2</mark> = p1.then(res =&gt; res.a.prop.that.does.not.exist)
<span class="md-code-keyword">var</span> <mark class="md-mark md-code-mark">p3</mark> = p2.catch(err =&gt; {})
<span class="md-code-keyword">var</span> <mark class="md-mark md-code-mark">p4</mark> = p3.catch(err =&gt; <span class="md-code-built_in">console</span>.error(err.message))
</code></pre> <p>Good boy! Have some bullet points. Or you could just look at the <a href="http://buff.ly/1NS1Uxl" target="_blank">Promisees visualization</a>.</p> <ol> <li><code class="md-code md-code-inline">fetch</code> returns a <strong>brand new</strong> <code class="md-code md-code-inline">p1</code> promise</li> <li><code class="md-code md-code-inline">p1.then</code> returns a <strong>brand new</strong> <code class="md-code md-code-inline">p2</code> promise</li> <li><code class="md-code md-code-inline">p2.catch</code> returns a <strong>brand new</strong> <code class="md-code md-code-inline">p3</code> promise</li> <li><code class="md-code md-code-inline">p3.catch</code> returns a <strong>brand new</strong> <code class="md-code md-code-inline">p4</code> promise</li> <li>When <code class="md-code md-code-inline">p1</code> is settled <em>(fulfilled)</em>, the <code class="md-code md-code-inline">p1.then</code> reaction is executed</li> <li>After that <code class="md-code md-code-inline">p2</code>, which is awaiting the pending result of <code class="md-code md-code-inline">p1.then</code> is settled</li> <li>Since <code class="md-code md-code-inline">p2</code> was <em>rejected</em>, <code class="md-code md-code-inline">p2.catch</code> reactions are executed <em>(instead of the <code class="md-code md-code-inline">p2.then</code> branch)</em></li> <li>The <code class="md-code md-code-inline">p3</code> promise from <code class="md-code md-code-inline">p2.catch</code> is <em>fulfilled</em>, even though it doesn&#x2019;t produce any value nor an error</li> <li>Because <code class="md-code md-code-inline">p3</code> succeeded, <code class="md-code md-code-inline">p3.catch</code> is never executed &#x2013; the <code class="md-code md-code-inline">p3.then</code> branch would&#x2019;ve been used instead</li> </ol> <p>You should think of promises as <strong>a tree structure</strong>. It all starts with a single promise, which we&#x2019;ll later see how to construct. You then add a branch with <code class="md-code md-code-inline">.then</code> or <code class="md-code md-code-inline">.catch</code>. You can tack as many <code class="md-code md-code-inline">.then</code> or <code class="md-code md-code-inline">.catch</code> calls as you want onto each branch, creating new branches, and so on.</p> <h1 id="creating-a-promise-from-scratch">Creating a Promise From Scratch</h1> <p>You should now understand how promises work like a tree where you can add branches where you need them, as you need them. But how do you create a promise from scratch? Writing these kinds of <code class="md-code md-code-inline">Promise</code> tutorials is hard because its a chicken and egg situation. People hardly have a need to create a promise from scratch, since libraries usually take care of that. In this article, for instance, I purposely started explaining things using <code class="md-code md-code-inline">fetch</code>, which internally creates a new promise object. Then, each call to <code class="md-code md-code-inline">.then</code> or <code class="md-code md-code-inline">.catch</code> on the promise created by fetch also creates a promise internally, and those promises depend on their parent when it comes to deciding whether the fulfillment branch or the rejection branch should be executed.</p> <p>Promises can be created from scratch by using <code class="md-code md-code-inline">new Promise(resolver)</code>. The <code class="md-code md-code-inline">resolver</code> parameter is a method that will be used to resolve the promise. It takes two arguments, a <code class="md-code md-code-inline">resolve</code> method and a <code class="md-code md-code-inline">reject</code> method. These promises are fulfilled and rejected, respectively, on the next tick &#x2013; as <a href="http://buff.ly/1LzF6k8" target="_blank">seen on Promisees</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">new</span> Promise(resolve =&gt; <mark class="md-mark md-code-mark">resolve()</mark>) <span class="md-code-comment">// promise is fulfilled</span>
<span class="md-code-keyword">new</span> Promise((resolve, reject) =&gt; <mark class="md-mark md-code-mark">reject()</mark>) <span class="md-code-comment">// promise is rejected</span>
</code></pre> <p>Resolving and rejecting promises without a value isn&#x2019;t that useful, though. Usually promises will resolve to some <code class="md-code md-code-inline">result</code>, like the response from an AJAX call as we saw with <code class="md-code md-code-inline">fetch</code>. Similarly, you&#x2019;ll probably want to state the <code class="md-code md-code-inline">reason</code> for your rejections &#x2013; typically using an <code class="md-code md-code-inline">Error</code> object. The code below codifies what you&#x2019;ve just read (see the <a href="http://buff.ly/1KxmM9p" target="_blank">visualization</a>, too).</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">new</span> Promise(resolve =&gt; resolve({ foo: <span class="md-code-string">&apos;bar&apos;</span> }))
  .then(result =&gt; <span class="md-code-built_in">console</span>.log(result))
  <span class="md-code-comment">// &lt;- { foo: &apos;bar&apos; }</span>

<span class="md-code-keyword">new</span> Promise((resolve, reject) =&gt;
  reject(<span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;failed to deliver on my promise to you&apos;</span>)))
  .catch(reason =&gt; <span class="md-code-built_in">console</span>.log(reason))
  <span class="md-code-comment">// &lt;- Error: failed to deliver on my promise to you</span>
</code></pre> <p>As you may have guessed, there&#x2019;s nothing inherently synchronous about promises. Fulfillment and rejection can both be completely asynchronous. That&#x2019;s the whole point of promises! The promise below is fulfilled <a href="http://buff.ly/1PxIwmX" target="_blank">after two seconds</a> elapse.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">new</span> Promise(resolve =&gt; setTimeout(resolve, <span class="md-code-number">2000</span>))
</code></pre> <p>It&#x2019;s important to note that only the first call made to either of these methods will have an impact &#x2013; once a promise is settled, it&#x2019;s result can&#x2019;t change. The example below creates a promise that&#x2019;s fulfilled in the alloted time or rejected after a generous timeout <a href="http://buff.ly/1Owr5po" target="_blank">(visualization)</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">resolveUnderThreeSeconds</span> <span class="md-code-params">(delay)</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-keyword">new</span> Promise(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(resolve, reject)</span> </span>{
    setTimeout(resolve, delay)
    setTimeout(reject, <span class="md-code-number">3000</span>)
  })
}
resolveUnderThreeSeconds(<span class="md-code-number">2000</span>) <span class="md-code-comment">// resolves!</span>
resolveUnderThreeSeconds(<span class="md-code-number">7000</span>) <span class="md-code-comment">// fulfillment took so long, it was rejected.</span>
</code></pre> <p><a href="http://buff.ly/1Owr5po" target="_blank"><img alt="See the promises unfold with this animation." class="" src="https://i.imgur.com/JiIrWWg.gif"></a></p> <p>Besides returning resolution values, you could also resolve with <em>another promise</em>. What happens in those cases? In the following snippet we create a promise <code class="md-code md-code-inline">p</code> that will be rejected in three seconds. We also create a promise <code class="md-code md-code-inline">p2</code> that will be resolved with <code class="md-code md-code-inline">p</code> in a second. Since <code class="md-code md-code-inline">p</code> is still two seconds out, resolving <code class="md-code md-code-inline">p2</code> won&#x2019;t have an immediate effect. Two seconds later, when <code class="md-code md-code-inline">p</code> is rejected, <code class="md-code md-code-inline">p2</code> will be rejected as well, with the same rejection reason that was provided to <code class="md-code md-code-inline">p</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> p = <span class="md-code-keyword">new</span> Promise(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(resolve, reject)</span> </span>{
  setTimeout(() =&gt; reject(<span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;fail&apos;</span>)), <span class="md-code-number">3000</span>)
})
<span class="md-code-keyword">var</span> p2 = <span class="md-code-keyword">new</span> Promise(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(resolve, reject)</span> </span>{
  setTimeout(() =&gt; resolve(p), <span class="md-code-number">1000</span>)
})
p2.then(result =&gt; <span class="md-code-built_in">console</span>.log(result))
p2.catch(error =&gt; <span class="md-code-built_in">console</span>.log(error))
<span class="md-code-comment">// &lt;- Error: fail</span>
</code></pre> <p>In the <a href="http://buff.ly/1KxtpIM" target="_blank">animation</a> shown below we can observe how <code class="md-code md-code-inline">p2</code> becomes blocked <em>&#x2013; marked in yellow &#x2013;</em> waiting for a settlement in <code class="md-code md-code-inline">p</code>.</p> <p><a href="http://buff.ly/1KxtpIM" target="_blank"><img alt="Animation of a promise blocking another one." class="" src="https://i.imgur.com/dIdrAcK.gif"></a></p> <p>Note that this behavior is only possible for fulfillment branches using <code class="md-code md-code-inline">resolve</code>. If you try to replicate the same behavior with <code class="md-code md-code-inline">reject</code> you&#x2019;ll find that the <code class="md-code md-code-inline">p2</code> promise is just rejected with the <code class="md-code md-code-inline">p</code> promise as the rejection <code class="md-code md-code-inline">reason</code>.</p> <h1 id="using-promiseresolve-and-promisereject">Using <code class="md-code md-code-inline">Promise.resolve</code> and <code class="md-code md-code-inline">Promise.reject</code></h1> <p>Sometimes you want to create a Promise but you don&#x2019;t want to go through the trouble of using the constructor. The following statement creates a promise that&#x2019;s fulfilled with a result of <code class="md-code md-code-inline">&apos;foo&apos;</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">new</span> Promise(resolve =&gt; resolve(<span class="md-code-string">&apos;foo&apos;</span>))
</code></pre> <p>If you already know the value a promise should be fulfilled with, you can use <code class="md-code md-code-inline">Promise.resolve</code> instead. The following statement is equivalent to the previous one.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">Promise.resolve(<span class="md-code-string">&apos;foo&apos;</span>)
</code></pre> <p>Similarly, if you already know the rejection reason, you can use <code class="md-code md-code-inline">Promise.reject</code>. The next statement creates a promise that&#x2019;s going to settle into a rejection, with <code class="md-code md-code-inline">reason</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">Promise.reject(reason)
</code></pre> <p>What else should we know about settling a promise?</p> <h1 id="settling-a-promise">Settling a Promise</h1> <p>Promises can exist in three states: pending, fulfilled, and rejected. Pending is the default state. From there, a promise can be <em>&#x201C;settled&#x201D;</em> into either fulfillment or rejection. Once a promise is settled, all reactions that are waiting on it are evaluated. Those on the correct branch <em>&#x2013; <code class="md-code md-code-inline">.then</code> for fulfillment and <code class="md-code md-code-inline">.catch</code> for rejections &#x2013;</em> are executed.</p> <p>From this point on, the promise is <em>settled</em>. If at a later point in time another reaction is chained onto the settled promise, the appropriate branch for that reaction is executed in the next tick of the program. In the example below, <code class="md-code md-code-inline">p</code> is resolved with a value of <code class="md-code md-code-inline">100</code> after two seconds. Then, <code class="md-code md-code-inline">100</code> is printed onto the screen. Two seconds later, another <code class="md-code md-code-inline">.then</code> branch is added onto <code class="md-code md-code-inline">p</code>, but since <code class="md-code md-code-inline">p</code> has already fulfilled, the new branch gets executed right away.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> p = <span class="md-code-keyword">new</span> Promise(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(resolve, reject)</span> </span>{
  setTimeout(() =&gt; resolve(<span class="md-code-number">100</span>), <span class="md-code-number">2000</span>)
})
p.then(result =&gt; <span class="md-code-built_in">console</span>.log(result))
<span class="md-code-comment">// &lt;- 100</span>

setTimeout(() =&gt; p.then(result =&gt; <span class="md-code-built_in">console</span>.log(result * <span class="md-code-number">20</span>)), <span class="md-code-number">4000</span>)
<span class="md-code-comment">// &lt;- 2000</span>
</code></pre> <p>A promise can return another promise &#x2013; this is what enables and powers most of their asynchronous behavior. In the <a href="https://ponyfoo.com/#creating-a-promise-from-scratch">previous section</a>, when creating a promise from scratch, we saw that we can <code class="md-code md-code-inline">resolve</code> with another promise. We can also return promises when calling <code class="md-code md-code-inline">.then</code>.</p> <h1 id="paying-a-promise-with-another-promise">Paying a Promise with another Promise</h1> <p>The example below shows how we use a promise and <code class="md-code md-code-inline">.then</code> another promise that will only be settled once the returned promise also settles. Once that happens, we get back the response from the wrapped promise, and we use the <code class="md-code md-code-inline">res.url</code> to figure out what random article we were graced with.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fetch(<span class="md-code-string">&apos;foo&apos;</span>)
  .then(response =&gt; fetch(<span class="md-code-string">&apos;/articles/random&apos;</span>))
  .then(response =&gt; <span class="md-code-built_in">console</span>.log(response.url))
<span class="md-code-comment">// &lt;- &apos;http://ponyfoo.com/articles/es6-symbols-in-depth&apos;</span>
</code></pre> <p>Obviously, in the real world, your second <code class="md-code md-code-inline">fetch</code> would probably depend on the response from the first one. Here&#x2019;s another example of returning a promise, where we <a href="http://buff.ly/1VbxElo" target="_blank">randomly <code class="md-code md-code-inline">fulfill</code> or <code class="md-code md-code-inline">reject</code></a> after a second.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> p = Promise.resolve()
  .then(data =&gt; <span class="md-code-keyword">new</span> Promise(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(resolve, reject)</span> </span>{
    setTimeout(<span class="md-code-built_in">Math</span>.random() &gt; <span class="md-code-number">0.5</span> ? resolve : reject, <span class="md-code-number">1000</span>)
  }))

p.then(data =&gt; <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;okay!&apos;</span>))
p.catch(data =&gt; <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;boo!&apos;</span>))
</code></pre> <p>The animation for this one is super fun!</p> <p><a href="http://buff.ly/1VbxElo" target="_blank"><img alt="Animation of the code shown right above" class="" src="https://i.imgur.com/3NNoO38.gif"></a></p> <p>Okay it&#x2019;s <strong>not</strong> <em>that fun</em>. I did have fun making the Promisees tool itself!</p> <h1 id="transforming-values-in-promises">Transforming Values in Promises</h1> <p>You&#x2019;re not just limited to returning other promises from your <code class="md-code md-code-inline">.then</code> and <code class="md-code md-code-inline">.catch</code> callbacks. You could also return values, transforming what you had. The example below first creates a promise fulfilled with <code class="md-code md-code-inline">[1, 2, 3]</code> and then has a fulfillment branch on top of that which maps thoes values into <code class="md-code md-code-inline">[2, 4, 6]</code>. Calling <code class="md-code md-code-inline">.then</code> on that branch of the promise will produce the doubled values.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">Promise.resolve([<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>])
  .then(values =&gt; values.map(value =&gt; value * <span class="md-code-number">2</span>))
  .then(values =&gt; <span class="md-code-built_in">console</span>.log(values))
  <span class="md-code-comment">// &lt;- [2, 4, 6]</span>
</code></pre> <p>Note that you can do the same thing in rejection branches. An interesting fact that may catch your eye is that if a <code class="md-code md-code-inline">.catch</code> branch goes smoothly without errors, then it will be fulfilled with the returned value. That means that if you still want to have an error for that branch, you should <code class="md-code md-code-inline">throw</code> again. The following piece of code takes an internal error and <strong>masks it</strong> behind a generic <em>&#x201C;Internal Server Error&#x201D;</em> message as to not leak off potentially dangerous information to its clients <a href="http://buff.ly/1LA2FcS" target="_blank">(visualization)</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">Promise.reject(<span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;Database ds.214.53.4.12 connection timeout!&apos;</span>))
  .catch(error =&gt; { <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;Internal Server Error&apos;</span>) })
  .catch(error =&gt; <span class="md-code-built_in">console</span>.info(error))
  <span class="md-code-comment">// &lt;- Error: Internal Server Error</span>
</code></pre> <p>Mapping promise results is particularly useful when dealing with multiple concurrent promises. Let&#x2019;s see how that looks like.</p> <h1 id="leveraging-promiseall-and-promiserace">Leveraging <code class="md-code md-code-inline">Promise.all</code> and <code class="md-code md-code-inline">Promise.race</code></h1> <p>A tremendously common scenario &#x2013; even more so for those used to Node.js &#x2013; is to have a dependency on things A and B before being able to do thing C. I&#x2019;ll proceed that lousy description of the scenario with multiple code snippets. Suppose you wanted to pull the homepage for both Google and Twitter, and then print out the length of each of their responses. Here&#x2019;s how that looks in the most n&#xE4;ive approach possible, with a hypothetical <code class="md-code md-code-inline">request(url, done)</code> method.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">request(<span class="md-code-string">&apos;https://google.com&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(err, goog)</span> </span>{
  request(<span class="md-code-string">&apos;https://twitter.com&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(err, twit)</span> </span>{
    <span class="md-code-built_in">console</span>.log(goog.length, twit.length)
  })
})
</code></pre> <p>Of course, that&#x2019;s going to run in series you say! Why would we wait on Google&#x2019;s response before pulling Twitter&#x2019;s? The following piece fixes the problem. It&#x2019;s also ridiculously long, though, right?</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> results = {}
request(<span class="md-code-string">&apos;https://google.com&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(err, goog)</span> </span>{
  results.goog = goog
  done()
})
request(<span class="md-code-string">&apos;https://twitter.com&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(err, twit)</span> </span>{
  results.twit = twit
  done()
})
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">done</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">if</span> (<span class="md-code-built_in">Object</span>.keys(results).length &lt; <span class="md-code-number">2</span>) {
    <span class="md-code-keyword">return</span>
  }
  <span class="md-code-built_in">console</span>.log(results.goog.length, results.twit.length)
}
</code></pre> <p>Since nobody wants to be writing code like that, utility libraries like <code class="md-code md-code-inline">async</code> and <code class="md-code md-code-inline">contra</code> make this much shorter for you. You can use <code class="md-code md-code-inline">contra.concurrent</code> to run these methods at the same time and execute a callback once they all ended. Here&#x2019;s how that&#x2019;d look like.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">contra.concurrent({
  goog: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(<mark class="md-mark md-code-mark">next</mark>)</span> </span>{
    request(<span class="md-code-string">&apos;https://google.com&apos;</span>, <mark class="md-mark md-code-mark">next</mark>)
  }
  twit: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(next)</span> </span>{
    request(<span class="md-code-string">&apos;https://twitter.com&apos;</span>, next)
  }
}, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(err, <mark class="md-mark md-code-mark">results</mark>)</span> </span>{
  <span class="md-code-built_in">console</span>.log(results.goog.length, results.twit.length)
})
</code></pre> <p>For the very common <em>&#x201C;I just want a method that appends that magical <code class="md-code md-code-inline">next</code> parameter at the end&#x201D;</em> use case, there&#x2019;s also <code class="md-code md-code-inline">contra.curry</code> <em>(equivalent of <code class="md-code md-code-inline">async.apply</code>)</em> to make the code even shorter.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">contra.concurrent({
  goog: <mark class="md-mark md-code-mark">contra.curry</mark>(request, <span class="md-code-string">&apos;https://google.com&apos;</span>),
  twit: <mark class="md-mark md-code-mark">contra.curry</mark>(request, <span class="md-code-string">&apos;https://twitter.com&apos;</span>)
}, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(err, results)</span> </span>{
  <span class="md-code-built_in">console</span>.log(results.goog.length, results.twit.length)
})
</code></pre> <p>Promises already make the &#x201C;run this after this other thing in series&#x201D; use case very easy, using <code class="md-code md-code-inline">.then</code> as we saw in several examples earlier. For the <em>&#x201C;run these things concurrently&#x201D;</em> use case, we can use <code class="md-code md-code-inline">Promise.all</code> <a href="http://buff.ly/1Pyen6L" target="_blank">(visualization here)</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">Promise.all([
  fetch(<span class="md-code-string">&apos;/&apos;</span>),
  fetch(<span class="md-code-string">&apos;foo&apos;</span>)
])
  .then(responses =&gt; responses.map(response =&gt; response.statusText))
  .then(status =&gt; <span class="md-code-built_in">console</span>.log(status.join(<span class="md-code-string">&apos;, &apos;</span>)))
  <span class="md-code-comment">// &lt;- &apos;OK, Not Found&apos;</span>
</code></pre> <p>Note that even if a single dependency is rejected, the <code class="md-code md-code-inline">Promise.all</code> method will be rejected entirely as well.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">Promise.all([
  <mark class="md-mark md-code-mark">Promise.reject()</mark>,
  fetch(<span class="md-code-string">&apos;/&apos;</span>),
  fetch(<span class="md-code-string">&apos;foo&apos;</span>)
])
  .then(responses =&gt; responses.map(response =&gt; response.statusText))
  .then(status =&gt; <span class="md-code-built_in">console</span>.log(status.join(<span class="md-code-string">&apos;, &apos;</span>)))
  <span class="md-code-comment">// nothing happens</span>
</code></pre> <p>In summary, <code class="md-code md-code-inline">Promise.all</code> has two possible outcomes.</p> <ul> <li>Settle with <em>a single</em> rejection <code class="md-code md-code-inline">reason</code> as soon as one of its dependencies is rejected</li> <li>Settle with <em>all</em> fulfillment <code class="md-code md-code-inline">results</code> as soon as all of its dependencies are fulfilled</li> </ul> <p>Then there&#x2019;s <code class="md-code md-code-inline">Promise.race</code>. This is a similar method to <code class="md-code md-code-inline">Promise.all</code>, except the first promise to settle will &#x201C;win&#x201D; the race, and its value will be passed along to branches of the race. If you run the <a href="http://buff.ly/1gRYr3p" target="_blank">visualization</a> for the following piece of code a few times, you&#x2019;ll notice that this race doesn&#x2019;t have a clear winner. It depends on the server and the network!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">Promise.race([
  fetch(<span class="md-code-string">&apos;/&apos;</span>),
  fetch(<span class="md-code-string">&apos;foo&apos;</span>)
])
  .then(response =&gt; <span class="md-code-built_in">console</span>.log(response.statusText))
  <span class="md-code-comment">// &lt;- &apos;OK&apos;, or maybe &apos;Not Found&apos;.</span>
</code></pre> <p>Rejections will also finish the race, and the race promise will be rejected. As a closing note we may indicate that this could be useful for scenarios where we want to time out a promise we otherwise have no control over. For instance, the following race does make sense.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> p = Promise.race([
  fetch(<span class="md-code-string">&apos;/resource-that-may-take-a-while&apos;</span>),
  <span class="md-code-keyword">new</span> Promise(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(resolve, reject)</span> </span>{
    setTimeout(() =&gt; reject(<span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;request timeout&apos;</span>)), <span class="md-code-number">5000</span>)
  })
])
p.then(response =&gt; <span class="md-code-built_in">console</span>.log(response))
p.catch(error =&gt; <span class="md-code-built_in">console</span>.log(error))
</code></pre> <p>To close this article, I&#x2019;ll leave you with <a href="http://buff.ly/1PyhnQC" target="_blank">a visualization</a>. It shows the race between a resource and a timeout as shown in the code above.</p> <p><a href="http://buff.ly/1PyhnQC" target="_blank"><img alt="Race between a resource and a timeout" class="" src="https://i.imgur.com/9OoMVfo.gif"></a></p> <p>Here&#x2019;s hoping I didn&#x2019;t make promises even harder to understand for you!</p></div>
