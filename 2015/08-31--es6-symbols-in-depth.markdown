<h1>ES6 Symbols in Depth</h1>

<div><kbd>es6</kbd> <kbd>symbols</kbd> <kbd>es6-in-depth</kbd></div>

<blockquote><p>Buon giorno! Willkommen to <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;I can&#x2019;t believe this is yet another installment&#x201D;</em> &#x2013; in Depth</a>. If you have no idea how you got here or &#x2026;</p></blockquote>

<div><p>Buon giorno! Willkommen to <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;I can&#x2019;t believe this is yet another installment&#x201D;</em> &#x2013; in Depth</a>. If you have no idea how you got here or what ES6 even is, I recommend reading <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="https://ponyfoo.com/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>, <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a>, and <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>. Today we&#x2019;ll be discussing <em>Symbols</em>.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for listening to that, and let&#x2019;s go into symbols now! For a bit of context, you may want to check out the last two articles, &#x2013; on <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a> and <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a> &#x2013; where we first talked about Symbols.</p></div>

<div><h2 id="what-are-symbols">What are Symbols?</h2> <p>Symbols are a new primitive type in ES6. If you ask me, they&#x2019;re <em>an awful lot like strings</em>. Just like with numbers and strings, symbols also come with their accompanying <code class="md-code md-code-inline">Symbol</code> wrapper object.</p> <p>We can create our own Symbols.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> mystery = Symbol()
</code></pre> <p>Note that there was no <code class="md-code md-code-inline">new</code>. The <code class="md-code md-code-inline">new</code> operator even throws a <code class="md-code md-code-inline">TypeError</code> when we try it on <code class="md-code md-code-inline">Symbol</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> oops = <span class="md-code-keyword">new</span> Symbol()
<span class="md-code-comment">// &lt;- TypeError</span>
</code></pre> <p>For debugging purposes, you can describe symbols.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> mystery = Symbol(<span class="md-code-string">&apos;this is a descriptive description&apos;</span>)
</code></pre> <p>Symbols are <em>immutable</em>. Just like numbers or strings. Note however that symbols are <em>unique</em>, unlike primitive numbers and strings.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(Symbol() === Symbol())
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">console</span>.log(Symbol(<span class="md-code-string">&apos;foo&apos;</span>) === Symbol(<span class="md-code-string">&apos;foo&apos;</span>))
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>Symbols are <em>symbols</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-keyword">typeof</span> Symbol())
<span class="md-code-comment">// &lt;- &apos;symbol&apos;</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-keyword">typeof</span> Symbol(<span class="md-code-string">&apos;foo&apos;</span>))
<span class="md-code-comment">// &lt;- &apos;symbol&apos;</span>
</code></pre> <p>There are three different flavors of symbols &#x2013; each flavor is accessed in a different way. We&#x2019;ll explore each of these and slowly figure out what all of this means.</p> <ul> <li>You can access local symbols by obtaining a reference to them <em>directly</em></li> <li>You can place symbols on the <em>global registry</em> and access them across <em>realms</em></li> <li>&#x201C;Well-known&#x201D; symbols exist across <em>realms</em> &#x2013; but you can&#x2019;t create them and they&#x2019;re not on the <em>global registry</em></li> </ul> <p>What the heck is a <em>realm</em>, you say? A <em>realm</em> is <strong>spec-speak</strong> for any execution context, such as the page your application is running in, or an <code class="md-code md-code-inline">&lt;iframe&gt;</code> within your page.</p> <h2 id="the-runtime-wide-symbol-registry">The &#x201C;Runtime-Wide&#x201D; Symbol Registry</h2> <p>There&#x2019;s two methods you can use to add symbols to the runtime-wide symbol registry: <code class="md-code md-code-inline">Symbol.for(key)</code> and <code class="md-code md-code-inline">Symbol.keyFor(symbol)</code>. What do these do?</p> <h3 id="symbolfor-key"><code class="md-code md-code-inline">Symbol.for(key)</code></h3> <p>This method looks up <code class="md-code md-code-inline">key</code> in the runtime-wide symbol registry. If a symbol with that <code class="md-code md-code-inline">key</code> exists in the global registry, that symbol is returned. If no symbol with that <code class="md-code md-code-inline">key</code> is found in the registry, one is created. That&#x2019;s to say, <code class="md-code md-code-inline">Symbol.for(key)</code> is <em>idempotent</em>. In the snippet below, the first call to <code class="md-code md-code-inline">Symbol.for(&apos;foo&apos;)</code> creates a symbol, adds it to the registry, and returns it. The second call returns that same symbol because the <code class="md-code md-code-inline">key</code> is already in the registry by then &#x2013; and associated to the symbol returned by the first call.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">Symbol.for(<span class="md-code-string">&apos;foo&apos;</span>) === Symbol.for(<span class="md-code-string">&apos;foo&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>That is in contrast to what we knew about symbols being unique. The global symbol registry however keeps track of symbols by a <code class="md-code md-code-inline">key</code>. Note that your <code class="md-code md-code-inline">key</code> will also be used as a <code class="md-code md-code-inline">description</code> when the symbols that go into the registry are created. Also note that these symbols are <strong>as global as globals get in JavaScript</strong>, so play nice and use a prefix and don&#x2019;t just name your symbols <code class="md-code md-code-inline">&apos;user&apos;</code> or some generic name like that.</p> <h3 id="symbolkeyfor-symbol"><code class="md-code md-code-inline">Symbol.keyFor(symbol)</code></h3> <p>Given a symbol <code class="md-code md-code-inline">symbol</code>, <code class="md-code md-code-inline">Symbol.keyFor(symbol)</code> returns the <code class="md-code md-code-inline">key</code> that was associated with <code class="md-code md-code-inline">symbol</code> when the symbol was added to the global registry.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> symbol = Symbol.for(<span class="md-code-string">&apos;foo&apos;</span>)
<span class="md-code-built_in">console</span>.log(Symbol.keyFor(symbol))
<span class="md-code-comment">// &lt;- &apos;foo&apos;</span>
</code></pre> <h3 id="how-wide-is-runtime-wide">How Wide is Runtime-Wide?</h3> <p>Runtime-wide means the symbols in the global registry are <em>accessible across code realms</em>. I&#x2019;ll probably have more success explaining this with a piece of code. It just means the registry is shared across realms.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> frame = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">&apos;iframe&apos;</span>)
<span class="md-code-built_in">document</span>.body.appendChild(frame)
<span class="md-code-built_in">console</span>.log(Symbol.for(<span class="md-code-string">&apos;foo&apos;</span>) === frame.contentWindow.Symbol.for(<span class="md-code-string">&apos;foo&apos;</span>))
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <h2 id="the-well-known-symbols">The &#x201C;Well-Known&#x201D; Symbols</h2> <p>Let me put you at ease: <strong>these aren&#x2019;t actually well-known at all.</strong> Far from it. I didn&#x2019;t have any idea these things existed until a few months ago. Why are they <em>&#x201C;well-known&#x201D;</em>, then? That&#x2019;s because they are JavaScript <em>built-ins</em>, and they are used to control parts of the language. They weren&#x2019;t exposed to user code before ES6, but now you can fiddle with them.</p> <p>A great example of a <em>&#x201C;well-known&#x201D;</em> symbol is something we&#x2019;ve already been playing with on Pony Foo: the <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">Symbol.iterator</code></a> well-known symbol. We used that symbol to define the <code class="md-code md-code-inline">@@iterator</code> method on objects that adhere to the <em>iterator</em> protocol. There&#x2019;s <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Well-known_symbols" target="_blank" aria-label="Well-known symbols on MDN">a list of well-known symbols</a> on MDN, but few of them are documented at the time of this writing.</p> <p>One of the well-known symbols that <em>is</em> documented at this time is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/match" target="_blank" aria-label="Symbol.match on MDN"><code class="md-code md-code-inline">Symbol.match</code></a>. According to MDN, you can set the <code class="md-code md-code-inline">Symbol.match</code> property on regular expressions to <code class="md-code md-code-inline">false</code> and have them behave as string literals when matching <em>(instead of regular expressions, which don&#x2019;t play nice with <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith" target="_blank" aria-label="String.prototype.startsWith() &#x2013; MDN"><code class="md-code md-code-inline">.startsWith</code></a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith" target="_blank" aria-label="String.prototype.endsWith() &#x2013; MDN"><code class="md-code md-code-inline">.endsWith</code></a>, or <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes" target="_blank" aria-label="String.prototype.includes() &#x2013; MDN"><code class="md-code md-code-inline">.includes</code></a>)</em>.</p> <p>This part of the spec hasn&#x2019;t been implemented in Babel yet, <em>&#x2013; I assume that&#x2019;s just because it&#x2019;s not worth the trouble &#x2013;</em> but supposedly it goes like this.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = <span class="md-code-string">&apos;/foo/&apos;</span>
<span class="md-code-keyword">var</span> literal = <span class="md-code-regexp">/foo/</span>
<mark class="md-mark md-code-mark">literal[Symbol.match] = false</mark>
<span class="md-code-built_in">console</span>.log(text.startsWith(literal))
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Why you&#x2019;d want to do that instead of just casting <code class="md-code md-code-inline">literal</code> to a string <em>is beyond me</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = <span class="md-code-string">&apos;/foo/&apos;</span>
<span class="md-code-keyword">var</span> casted = <span class="md-code-regexp">/foo/</span><mark class="md-mark md-code-mark">.toString()</mark>
<span class="md-code-built_in">console</span>.log(text.startsWith(casted))
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>I suspect the language has <strong>legitimate performance reasons</strong> that warrant the existence of this symbol, but I don&#x2019;t think it&#x2019;ll become a front-end development staple anytime soon.</p> <blockquote> <p>Regardless, <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">Symbol.iterator</code></a> is actually very useful, and I&#x2019;m sure other well-known symbols are useful as well.</p> </blockquote> <p>Note that well-known symbols are unique, but <strong>shared across realms</strong>, even when they&#x2019;re not accessible through the <em>global registry</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> frame = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">&apos;iframe&apos;</span>)
<span class="md-code-built_in">document</span>.body.appendChild(frame)
<span class="md-code-built_in">console</span>.log(Symbol.iterator === frame.contentWindow.Symbol.iterator)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Not accessible through the <em>global registry</em>? Nope!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(Symbol.keyFor(Symbol.iterator))
<span class="md-code-comment">// &lt;- undefined</span>
</code></pre> <p>Accessing them statically from anywhere should be more than enough, though.</p> <h2 id="symbols-and-iteration">Symbols and Iteration</h2> <p>Any consumer of the <em>iterable</em> protocol obviously ignores symbols other than the well-known <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">Symbol.iterator</code></a> that would define how to iterate and help identify the object as an <em>iterable</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = {
  [Symbol()]: <span class="md-code-string">&apos;foo&apos;</span>,
  [Symbol(<span class="md-code-string">&apos;foo&apos;</span>)]: <span class="md-code-string">&apos;bar&apos;</span>,
  [Symbol.for(<span class="md-code-string">&apos;bar&apos;</span>)]: <span class="md-code-string">&apos;baz&apos;</span>,
  what: <span class="md-code-string">&apos;ever&apos;</span>
}
<span class="md-code-built_in">console</span>.log([...foo])
<span class="md-code-comment">// &lt;- []</span>
</code></pre> <p>The ES5 <code class="md-code md-code-inline">Object.keys</code> method ignores symbols.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.keys(foo))
<span class="md-code-comment">// &lt;- [&apos;what&apos;]</span>
</code></pre> <p>Same goes for <code class="md-code md-code-inline">JSON.stringify</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">JSON</span>.stringify(foo))
<span class="md-code-comment">// &lt;- {&quot;what&quot;:&quot;ever&quot;}</span>
</code></pre> <p>So, <code class="md-code md-code-inline">for..in</code> then? Nope.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> key <span class="md-code-keyword">in</span> foo) {
  <span class="md-code-built_in">console</span>.log(key)
  <span class="md-code-comment">// &lt;- &apos;what&apos;</span>
}
</code></pre> <p>I know, <code class="md-code md-code-inline">Object.getOwnPropertyNames</code>. Nah! <em>&#x2013; but close.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.getOwnPropertyNames(foo))
<span class="md-code-comment">// &lt;- [&apos;what&apos;]</span>
</code></pre> <p>You need to be explicitly looking for symbols to stumble upon them. They&#x2019;re like JavaScript neutrinos. You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" aria-label="Object.getOwnPropertySymbols() &#x2013; MDN"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> to detect them.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.getOwnPropertySymbols(foo))
<span class="md-code-comment">// &lt;- [Symbol(), Symbol(&apos;foo&apos;), Symbol.for(&apos;bar&apos;)]</span>
</code></pre> <p>The magical drapes of symbols drop, and you can now iterate over the symbols with a <code class="md-code md-code-inline">for..of</code> loop to finally figure out the treasures they were guarding. Hopefully, they won&#x2019;t be as disappointing as the flukes in the snippet below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> symbol of <span class="md-code-built_in">Object</span>.getOwnPropertySymbols(foo)) {
  <span class="md-code-built_in">console</span>.log(foo[symbol])
  <span class="md-code-comment">// &lt;- &apos;foo&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;bar&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;baz&apos;</span>
}
</code></pre> <h2 id="why-would-i-want-symbols">Why Would I Want Symbols?</h2> <p>There&#x2019;s a few different uses for symbols.</p> <h3 id="name-clashes">Name Clashes</h3> <p>You can use symbols to <strong>avoid name clashes</strong> in property keys. This is important when following the <em>&#x201C;objects as hash maps&#x201D;</em> pattern, which regularly ends up failing miserably as native methods and properties are overridden unintentionally <em>(or maliciously)</em>.</p> <h3 id="privacy">&#x201C;Privacy&#x201D;?</h3> <p>Symbols are <em>invisible to all &#x201C;reflection&#x201D; methods before ES6</em>. This can be useful in some scenarios, but they&#x2019;re not private by any stretch of imagination, as we&#x2019;ve just demonstrated with the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" aria-label="Object.getOwnPropertySymbols() &#x2013; MDN"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> API.</p> <p>That being said, the fact that you have to actively look for symbols to find them means they&#x2019;re useful in situations where you want to define metadata that shouldn&#x2019;t be part of iterable sequences for arrays or any <em>iterable</em> objects.</p> <h3 id="defining-protocols">Defining Protocols</h3> <p>I think the <em>biggest use case for symbols</em> is exactly what the ES6 implementers use them for: <strong>defining protocols</strong> &#x2013; just like there&#x2019;s <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">Symbol.iterator</code></a> which allows you to define how an object can be iterated.</p> <p>Imagine for instance a library like <a href="https://github.com/bevacqua/dragula" target="_blank" aria-label="bevacqua/dragula on GitHub"><code class="md-code md-code-inline">dragula</code></a> defining a protocol through <code class="md-code md-code-inline">Symbol.for(&apos;dragula.moves&apos;)</code>, where you could add a method on that <code class="md-code md-code-inline">Symbol</code> to any DOM elements. If a DOM element follows the protocol, then <code class="md-code md-code-inline">dragula</code> could call the <code class="md-code md-code-inline">el[Symbol.for(&apos;dragula.moves&apos;)]()</code> user-defined method to assert whether the element can be moved.</p> <p>This way, the logic about elements being draggable by <code class="md-code md-code-inline">dragula</code> is shifted from a single place for the entire <code class="md-code md-code-inline">drake</code> <em>(the <code class="md-code md-code-inline">options</code> for an instance of <code class="md-code md-code-inline">dragula</code>)</em>, to each individual DOM element. That&#x2019;d make it easier to deal with complex interactions in larger implementations, as the logic would be delegated to individual DOM nodes instead of being centralized in a single <code class="md-code md-code-inline">options.moves</code> method.</p></div>
