<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/master/contributing.markdown"><code>contributing.markdown</code></a> for details.</sub>

<a href="https://ponyfoo.com/articles/es6-array-extensions-in-depth"><div></div></a>

<h1>ES6 Array Extensions in Depth</h1>

<p><kbd>es6</kbd> <kbd>array</kbd> <kbd>es6-in-depth</kbd></p>

<blockquote><p>Hello traveler! This is <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&quot;Oh cool, I like <code>Array</code>&quot;</em> &#x2013; in Depth</a> series. If you&#x2019;ve never been around here before, start with <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief &#x2026;</a></p></blockquote>

<div><p>Hello traveler! This is <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&quot;Oh cool, I like <code class="md-code md-code-inline">Array</code>&quot;</em> &#x2013; in Depth</a> series. If you&#x2019;ve never been around here before, start with <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="https://ponyfoo.com/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>, <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a>, <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>, <a href="https://ponyfoo.com/articles/es6-symbols-in-depth">Symbols</a>, <a href="https://ponyfoo.com/articles/es6-maps-in-depth">Maps</a>, <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="https://ponyfoo.com/articles/es6-proxies-in-depth">proxies</a>, <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth">proxy traps</a>, <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="https://ponyfoo.com/articles/es6-reflection-in-depth">reflection</a>, <a href="https://ponyfoo.com/articles/es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>, and <a href="https://ponyfoo.com/articles/es6-math-additions-in-depth"><code class="md-code md-code-inline">Math</code></a>. Today we&#x2019;ll learn about new <code class="md-code md-code-inline">Array</code> extensions.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for reading that, and let&#x2019;s go into <code class="md-code md-code-inline">Array</code> extensions. For a bit of context you may want to look at the articles on <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a>, <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a> and <a href="https://ponyfoo.com/articles/es6-maps-in-depth">collections</a>.</p></div>

<div><h1 id="upcoming-array-methods">Upcoming <code class="md-code md-code-inline">Array</code> Methods</h1> <p>There&#x2019;s plenty to choose from. Over the years, libraries like Underscore and Lodash spoke loudly about features we were missing in the language, and now we have a ton more tools in the <a href="https://ponyfoo.com/articles/fun-with-native-arrays" aria-label="Fun with Native Arrays on Pony Foo">functional array</a> arsenal at our disposal.</p> <p>First off, there&#x2019;s a couple of static methods being added.</p> <ul> <li><a href="https://ponyfoo.com/#arrayfrom"><code class="md-code md-code-inline">Array.from</code></a> &#x2013; create <code class="md-code md-code-inline">Array</code> instances from arraylike objects like <code class="md-code md-code-inline">arguments</code> or iterables</li> <li><a href="https://ponyfoo.com/#arrayof"><code class="md-code md-code-inline">Array.of</code></a></li> </ul> <p>Then there&#x2019;s a few methods that help you manipulate, fill, and filter arrays.</p> <ul> <li><a href="https://ponyfoo.com/#arrayprototypecopywithin"><code class="md-code md-code-inline">Array.prototype.copyWithin</code></a></li> <li><a href="https://ponyfoo.com/#arrayprototypefill"><code class="md-code md-code-inline">Array.prototype.fill</code></a></li> <li><a href="https://ponyfoo.com/#arrayprototypefind"><code class="md-code md-code-inline">Array.prototype.find</code></a></li> <li><a href="https://ponyfoo.com/#arrayprototypefindindex"><code class="md-code md-code-inline">Array.prototype.findIndex</code></a></li> </ul> <p>There&#x2019;s also the methods <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo">related to the iterator protocol</a>.</p> <ul> <li><a href="https://ponyfoo.com/#arrayprototypekeys"><code class="md-code md-code-inline">Array.prototype.keys</code></a></li> <li><a href="https://ponyfoo.com/#arrayprototypevalues"><code class="md-code md-code-inline">Array.prototype.values</code></a></li> <li><a href="https://ponyfoo.com/#arrayprototypeentries"><code class="md-code md-code-inline">Array.prototype.entries</code></a></li> <li><a href="https://ponyfoo.com/#arrayprototype-symboliterator"><code class="md-code md-code-inline">Array.prototype[Symbol.iterator]</code></a></li> </ul> <p>There&#x2019;s a few more methods coming in ES2016 <em>(ES7)</em> as well, but we won&#x2019;t be covering those today.</p> <ul> <li><code class="md-code md-code-inline">Array.prototype.includes</code></li> <li><code class="md-code md-code-inline">Array.observe</code></li> <li><code class="md-code md-code-inline">Array.unobserve</code></li> </ul> <p>Let&#x2019;s get to work!</p> <h1 id="arrayfrom"><code class="md-code md-code-inline">Array.from</code></h1> <p>This method has been long overdue. Remember the quintessential example of converting an arraylike into an actual array?</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">function cast ()
  return <mark class="md-mark md-code-mark">Array.prototype.slice.call</mark>(arguments)
}
cast(&apos;a&apos;, &apos;b&apos;)
// &lt;- [&apos;a&apos;, &apos;b&apos;]
</code></pre> <p>Or, a shorter form perhaps?</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">function cast ()
  return <mark class="md-mark md-code-mark">[].slice.call</mark>(arguments)
}
</code></pre> <p>To be fair, we&#x2019;ve already explored even more terse ways of doing this at some point during the <a href="https://ponyfoo.com/articles/tagged/es6-in-depth" aria-label="Articles tagged es6-in-depth on Pony Foo">ES6 in depth series</a>. For instance you could use the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread operator</a>. As you probably remember, the spread operator leverages the <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo">iterator protocol</a> to produce a sequence of values in arbitrary objects. The downside is that the objects we want to cast with spread <strong>must implement</strong> <code class="md-code md-code-inline">@@iterator</code> through <code class="md-code md-code-inline">Symbol.iterator</code>. Luckily for us, <code class="md-code md-code-inline">arguments</code> does implement the iterator protocol in ES6.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">function cast ()
  return [<mark class="md-mark md-code-mark">...</mark>arguments]
}
</code></pre> <p>Another thing you could be casting through the spread operator is DOM element collections like those returned from <code class="md-code md-code-inline">document.querySelectorAll</code>. Once again, this is made possible thanks to ES6 adding conformance to the iterator protocol to <code class="md-code md-code-inline">NodeList</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark">...</mark>document.querySelectorAll(<span class="md-code-string">&apos;div&apos;</span>)]
<span class="md-code-comment">// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;, ...]</span>
</code></pre> <p>What happens when we try to cast a jQuery collection through the spread operator? Actually, you&#x2019;ll <strong>get an exception</strong> because they haven&#x2019;t implemented <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">Symbol.iterator</code></a> quite yet. You can try this one on <a href="http://jquery.com/" target="_blank" aria-label="jQuery: Do less, bloat more">jquery.com</a> in Firefox.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[...$(<span class="md-code-string">&apos;div&apos;</span>)]
<mark class="md-mark md-code-mark">TypeError: $(...)[Symbol.iterator] is not a function</mark>
</code></pre> <p>The new <code class="md-code md-code-inline">Array.from</code> method is different, though. It doesn&#x2019;t <em>only</em> rely on iterator protocol to figure out how to pull values from an object. It also has support for arraylikes out the box.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Array</span>.from(<mark class="md-mark md-code-mark">$(<span class="md-code-string">&apos;div&apos;</span>)</mark>)
<span class="md-code-comment">// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;, ...]</span>
</code></pre> <p>The one thing you cannot do with either <code class="md-code md-code-inline">Array.from</code> nor the spread operator is to pick a start index. Suppose you wanted to pull every <code class="md-code md-code-inline">&lt;div&gt;</code> after the first one. With <code class="md-code md-code-inline">.slice.call</code>, you could do it like so:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[].slice.call(<span class="md-code-built_in">document</span>.querySelectorAll(<span class="md-code-string">&apos;div&apos;</span>)<mark class="md-mark md-code-mark">, <span class="md-code-number">1</span></mark>)
</code></pre> <p>Of course, there&#x2019;s nothing stopping you from using <code class="md-code md-code-inline">.slice</code> <em>after</em> casting. This is probably way easier to read, and looks more like functional programming, so there&#x2019;s that.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Array</span>.from(<span class="md-code-built_in">document</span>.querySelectorAll(<span class="md-code-string">&apos;div&apos;</span>))<mark class="md-mark md-code-mark">.slice(<span class="md-code-number">1</span>)</mark>
</code></pre> <p><code class="md-code md-code-inline">Array.from</code> actually has three arguments, <em>but only the <code class="md-code md-code-inline">input</code> is required</em>. To wit:</p> <ul> <li><code class="md-code md-code-inline">input</code> &#x2013; the arraylike or iterable object you want to cast</li> <li><code class="md-code md-code-inline">map</code> &#x2013; a mapping function that&#x2019;s executed on every item of <code class="md-code md-code-inline">input</code></li> <li><code class="md-code md-code-inline">context</code> &#x2013; the <code class="md-code md-code-inline">this</code> binding to use when calling <code class="md-code md-code-inline">map</code></li> </ul> <p>With <code class="md-code md-code-inline">Array.from</code> we cannot slice, but we can dice!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">typesOf</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Array</span>.from(<span class="md-code-built_in">arguments</span>, value =&gt; <span class="md-code-keyword">typeof</span> value)
}
typesOf(<span class="md-code-literal">null</span>, [], <span class="md-code-literal">NaN</span>)
<span class="md-code-comment">// &lt;- [&apos;object&apos;, &apos;object&apos;, &apos;number&apos;]</span>
</code></pre> <p>Do note that you could also just combine <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">rest parameters</a> and <code class="md-code md-code-inline">.map</code> if you were just dealing with <code class="md-code md-code-inline">arguments</code>. In this case in particular, we may be better off just doing something like the snippet of code found below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">typesOf</span> <span class="md-code-params">(<mark class="md-mark md-code-mark">...</mark>all)</span> </span>{
  <span class="md-code-keyword">return</span> all.map(value =&gt; <span class="md-code-keyword">typeof</span> value)
}
typesOf(<span class="md-code-literal">null</span>, [], <span class="md-code-literal">NaN</span>)
<span class="md-code-comment">// &lt;- [&apos;object&apos;, &apos;object&apos;, &apos;number&apos;]</span>
</code></pre> <p>In some cases, like the case of jQuery we saw earlier, it makes sense to use <code class="md-code md-code-inline">Array.from</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Array</span>.from($(<span class="md-code-string">&apos;div&apos;</span>))
<span class="md-code-comment">// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;, ...]</span>
<span class="md-code-built_in">Array</span>.from($(<span class="md-code-string">&apos;div&apos;</span>), el =&gt; el.id)
<span class="md-code-comment">// &lt;- [&apos;&apos;, &apos;container&apos;, &apos;logo-events&apos;, &apos;broadcast&apos;, ...]</span>
</code></pre> <p>I guess you get the idea.</p> <h1 id="arrayof"><code class="md-code md-code-inline">Array.of</code></h1> <p>This method is exactly like the first incarnation of <code class="md-code md-code-inline">cast</code> we played with in our analysis of <a href="https://ponyfoo.com/#arrayfrom"><code class="md-code md-code-inline">Array.from</code></a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Array</span>.of = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">of</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Array</span>.prototype.slice.call(<span class="md-code-built_in">arguments</span>)
}
</code></pre> <p>You can&#x2019;t just replace <code class="md-code md-code-inline">Array.prototype.slice.call</code> with <code class="md-code md-code-inline">Array.of</code>. They&#x2019;re different animals.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Array</span>.prototype.slice.call(<mark class="md-mark md-code-mark">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>]</mark>)
<span class="md-code-comment">// &lt;- [1, 2, 3]</span>
<span class="md-code-built_in">Array</span>.of(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3]</span>
</code></pre> <p>You can think of <code class="md-code md-code-inline">Array.of</code> as an alternative for <code class="md-code md-code-inline">new Array</code> that doesn&#x2019;t have the <code class="md-code md-code-inline">new Array(length)</code> overload. Below you&#x2019;ll find some of the strange ways in which <code class="md-code md-code-inline">new Array</code> behaves thanks to its single-argument <code class="md-code md-code-inline">length</code> overloaded constructor. If you&#x2019;re confused about the <code class="md-code md-code-inline">undefined x ${number}</code> notation in the browser console, that&#x2019;s indicating there are <a href="http://www.2ality.com/2013/07/array-iteration-holes.html" target="_blank" aria-label="Array iteration and holes in JavaScript on 2ality.com">array holes</a> in those positions.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>()
<span class="md-code-comment">// &lt;- []</span>
<span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>(<span class="md-code-literal">undefined</span>)
<span class="md-code-comment">// &lt;- [undefined]</span>
<span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>(<span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">[undefined x 1]</mark></span>
<span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>(<span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">[undefined x 3]</mark></span>
<span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- [1, 2]</span>
<span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>(-<span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">RangeError: Invalid array length</mark></span>
</code></pre> <p>In contrast, <code class="md-code md-code-inline">Array.of</code> has more consistent behavior because it doesn&#x2019;t have the special <code class="md-code md-code-inline">length</code> case.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Array</span>.of()
<span class="md-code-comment">// &lt;- []</span>
<span class="md-code-built_in">Array</span>.of(<span class="md-code-literal">undefined</span>)
<span class="md-code-comment">// &lt;- [undefined]</span>
<span class="md-code-built_in">Array</span>.of(<span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- [1]</span>
<span class="md-code-built_in">Array</span>.of(<span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- [3]</span>
<span class="md-code-built_in">Array</span>.of(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- [1, 2]</span>
<span class="md-code-built_in">Array</span>.of(-<span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- [-1]</span>
</code></pre> <p>There&#x2019;s not a lot to add here &#x2013; let&#x2019;s move on.</p> <h1 id="arrayprototypecopywithin"><code class="md-code md-code-inline">Array.prototype.copyWithin</code></h1> <p>This is the most obscure method that got added to <code class="md-code md-code-inline">Array.prototype</code>. I suspect use cases lie around <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Typed_arrays" target="_blank" aria-label="JavaScript typed arrays on MDN">buffers and typed arrays</a> <em>&#x2013; which we&#x2019;ll cover at some point, later in the series.</em> The method copies a sequence of array elements <em>within the array</em> to the <em>&#x201C;paste position&#x201D;</em> starting at <code class="md-code md-code-inline">target</code>. The elements that should be copied are taken from the <code class="md-code md-code-inline">[start, end)</code> range.</p> <p>Here&#x2019;s the signature of the <code class="md-code md-code-inline">copyWithin</code> method. The <code class="md-code md-code-inline">target</code> <em>&#x201C;paste position&#x201D;</em> <strong>is required</strong>. The <code class="md-code md-code-inline">start</code> index where to take elements from defaults to <code class="md-code md-code-inline">0</code>. The <code class="md-code md-code-inline">end</code> position defaults to the length of the array.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Array</span>.prototype.copyWithin(target, start = <span class="md-code-number">0</span>, end = <span class="md-code-keyword">this</span>.length)
</code></pre> <p>Let&#x2019;s start with a simple example. Consider the <code class="md-code md-code-inline">items</code> array in the snippet below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> items = [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,]
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 7]</span>
</code></pre> <p>The method below takes the <code class="md-code md-code-inline">items</code> array and determines that it&#x2019;ll start <em>&#x201C;pasting&#x201D;</em> items in the <strong>sixth position</strong>. It further determines that the items to be copied will be taken starting in the <strong>second position</strong> <em>(zero-based)</em>, until the <strong>third position</strong> <em>(also zero-based)</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">items.copyWithin(<span class="md-code-number">6</span>, <span class="md-code-number">1</span>, <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, <mark class="md-mark md-code-mark">undefined &#xD7; 3</mark>, 2, 3, <mark class="md-mark md-code-mark">undefined &#xD7; 2</mark>]</span>
</code></pre> <blockquote> <p>Reasoning about this method can be pretty hard. <em>Let&#x2019;s break it down.</em></p> </blockquote> <p>If we consider that the items to be copied were taken from the <code class="md-code md-code-inline">[start, end)</code> range, then we can express that using the <code class="md-code md-code-inline">.slice</code> operation. These are the items that were <em>&#x201C;pasted&#x201D;</em> at the <code class="md-code md-code-inline">target</code> position. We can use <code class="md-code md-code-inline">.slice</code> to <em>&#x201C;copy&#x201D;</em> them.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">items.slice(<span class="md-code-number">1</span>, <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- [<mark class="md-mark md-code-mark">2, 3</mark>]</span>
</code></pre> <p>We could then consider the &#x201C;pasting&#x201D; part of the operation as an advanced usage of <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" aria-label="Array.prototype.splice on MDN"><code class="md-code md-code-inline">.splice</code></a> &#x2013; one of those lovely methods that can do just about anything. The method below does just that, and then returns <code class="md-code md-code-inline">items</code>, because <code class="md-code md-code-inline">.splice</code> returns the items that were spliced from an Array, and in our case this is no good. Note that we also had to use the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread operator</a> so that elements are inserted individually through <code class="md-code md-code-inline">.splice</code>, and not as an array.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">copyWithin</span> <span class="md-code-params">(items, target, start = 0, end = items.length)</span> </span>{
  items.splice(target, end - start, <mark class="md-mark md-code-mark">...</mark>items.slice(start, end))
  <span class="md-code-keyword">return</span> items
}
</code></pre> <p>Our example would still work the same with this method.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">copyWithin([<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,], <span class="md-code-number">6</span>, <span class="md-code-number">1</span>, <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined &#xD7; 3, 2, 3, undefined &#xD7; 2]</span>
</code></pre> <p>The <code class="md-code md-code-inline">copyWithin</code> method accepts negative <code class="md-code md-code-inline">start</code> indices, negative <code class="md-code md-code-inline">end</code> indices, and negative <code class="md-code md-code-inline">target</code> indices. Let&#x2019;s try something using that.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,].copyWithin(-<span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 4, 1, 2, 3]</span>
copyWithin([<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,], -<span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 4, 1, 2, 3, <mark class="md-mark md-code-mark">undefined x 7</mark>]</span>
</code></pre> <p>Turns out, that thought exercise was useful for understanding <code class="md-code md-code-inline">Array.prototype.copyWithin</code>, but it wasn&#x2019;t actually correct. Why are we seeing <code class="md-code md-code-inline">undefined x 7</code> at the end? Why the discrepancy? The problem is that we are seeing the array holes at the end of <code class="md-code md-code-inline">items</code> when we do <code class="md-code md-code-inline">...items.slice(start, end)</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,]
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 7]</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,].slice(<span class="md-code-number">0</span>, <span class="md-code-number">10</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 7]</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">...[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,].slice(<span class="md-code-number">0</span>, <span class="md-code-number">10</span>)</mark>)
<span class="md-code-comment">// &lt;- 1, 2, 3, undefined, undefined, undefined, undefined, undefined, undefined, undefined</span>
</code></pre> <p>Thus, we <em>end up splicing the holes</em> onto <code class="md-code md-code-inline">items</code>, while the original solution is not. We could get rid of the holes using <code class="md-code md-code-inline">.filter</code>, which conveniently discards array holes.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,].slice(<span class="md-code-number">0</span>, <span class="md-code-number">10</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 7]</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,].slice(<span class="md-code-number">0</span>, <span class="md-code-number">10</span>)<mark class="md-mark md-code-mark">.filter(el =&gt; <span class="md-code-literal">true</span>)</mark>
<span class="md-code-comment">// &lt;- [1, 2, 3]</span>
</code></pre> <p>With that, we can update our <code class="md-code md-code-inline">copyWithin</code> method. We&#x2019;ll stop using <code class="md-code md-code-inline">end - start</code> as the splice position and instead use the amount of <code class="md-code md-code-inline">replacements</code> that we have, as those numbers may be different now that we&#x2019;re discarding array holes.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">copyWithin</span> <span class="md-code-params">(items, target, start = 0, end = items.length)</span> </span>{
  <span class="md-code-keyword">var</span> replacements = items.slice(start, end)<mark class="md-mark md-code-mark">.filter(el =&gt; <span class="md-code-literal">true</span>)</mark>
  items.splice(target, <mark class="md-mark md-code-mark">replacements.length</mark>, ...replacements)
  <span class="md-code-keyword">return</span> items
}
</code></pre> <p>The case were we previously added extra holes now works as expected. Woo!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,].copyWithin(-<span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 4, 1, 2, 3]</span>
copyWithin([<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,], -<span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 4, 1, 2, 3]</span>
</code></pre> <p>Furthermore, our polyfill seems to work correctly <em>across the board</em> now. I wouldn&#x2019;t rely on it for anything other than educational purposes, though.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,].copyWithin(-<span class="md-code-number">3</span>, <span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 4, 2, 3, undefined x 1]</span>
copyWithin([<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,], -<span class="md-code-number">3</span>, <span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 4, 2, 3, undefined x 1]</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,].copyWithin(-<span class="md-code-number">6</span>, -<span class="md-code-number">8</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 1, 3, undefined x 5]</span>
copyWithin([<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,], -<span class="md-code-number">6</span>, -<span class="md-code-number">8</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 1, 3, undefined x 5]</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,].copyWithin(-<span class="md-code-number">3</span>, <span class="md-code-number">1</span>, <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 4, 2, undefined x 2]</span>
copyWithin([<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, ,,,,,,,], -<span class="md-code-number">3</span>, <span class="md-code-number">1</span>, <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- [1, 2, 3, undefined x 4, 2, undefined x 2]</span>
</code></pre> <p>It&#x2019;s decidedly better to just use the actual implementation, but at least now we have <strong>a better idea of how the hell it works!</strong></p> <h1 id="arrayprototypefill"><code class="md-code md-code-inline">Array.prototype.fill</code></h1> <p>Convenient utility method to fill all places in an <code class="md-code md-code-inline">Array</code> with the provided <code class="md-code md-code-inline">value</code>. Note that array holes will be filled as well.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-string">&apos;a&apos;</span>, <span class="md-code-string">&apos;b&apos;</span>, <span class="md-code-string">&apos;c&apos;</span>].fill(<span class="md-code-number">0</span>)
<span class="md-code-comment">// &lt;- [0, 0, 0]</span>
<span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>(<span class="md-code-number">3</span>).fill(<span class="md-code-number">0</span>)
<span class="md-code-comment">// &lt;- [0, 0, 0]</span>
</code></pre> <p>You could also determine a start index and an end index in the second and third parameters respectively.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-string">&apos;a&apos;</span>, <span class="md-code-string">&apos;b&apos;</span>, <span class="md-code-string">&apos;c&apos;</span>,,,].fill(<span class="md-code-number">0</span>, <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- [&apos;a&apos;, &apos;b&apos;, 0, 0, 0]</span>
<span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>(<span class="md-code-number">5</span>).fill(<span class="md-code-number">0</span>, <span class="md-code-number">0</span>, <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- [0, 0, 0, <mark class="md-mark md-code-mark">undefined x 2</mark>]</span>
</code></pre> <p>The provided value can be arbitrary, and not necessarily a number or even a primitive type.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>(<span class="md-code-number">3</span>).fill({})
<span class="md-code-comment">// &lt;- [{}, {}, {}]</span>
</code></pre> <p>Unfortunately, you can&#x2019;t fill arrays using a mapping method that takes an <code class="md-code md-code-inline">index</code> parameter or anything like that.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>(<span class="md-code-number">3</span>).fill(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">foo</span> <span class="md-code-params">()</span> </span>{})
<span class="md-code-comment">// &lt;- [function foo () {}, function foo () {}, function foo () {}]</span>
</code></pre> <p><em>Moving along&#x2026;</em></p> <h1 id="arrayprototypefind"><code class="md-code md-code-inline">Array.prototype.find</code></h1> <p>Ah. One of those methods that JavaScript desperately wanted but didn&#x2019;t get in ES5. The <code class="md-code md-code-inline">.find</code> method returns the <em>first</em> <code class="md-code md-code-inline">item</code> that matches <code class="md-code md-code-inline">callback(item, i, array)</code> for an <code class="md-code md-code-inline">array</code> Array. You can also optionally pass in a <code class="md-code md-code-inline">context</code> binding for <code class="md-code md-code-inline">this</code>. You can think of it as an equivalent of <a href="http://ponyfoo.com/articles/fun-with-native-arrays#asserting-with-some-and-every" target="_blank" aria-label="Asserting with .some and .every on Pony Foo"><code class="md-code md-code-inline">.some</code></a> that returns the matching element <em>(or <code class="md-code md-code-inline">undefined</code>)</em> instead of merely <code class="md-code md-code-inline">true</code> or <code class="md-code md-code-inline">false</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>, <span class="md-code-number">5</span>].find(item =&gt; item &gt; <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- 3</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>, <span class="md-code-number">5</span>].find((item, i) =&gt; i === <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- 4</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>, <span class="md-code-number">5</span>].find(item =&gt; item === <span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- undefined</span>
</code></pre> <p>There&#x2019;s really not much else to say about this method. It&#x2019;s just that simple! We did want this method a lot, as evidenced in libraries like Lodash and Underscore. Speaking of those libraries&#x2026; &#x2013; <code class="md-code md-code-inline">.findIndex</code> was also born there.</p> <h1 id="arrayprototypefindindex"><code class="md-code md-code-inline">Array.prototype.findIndex</code></h1> <p>This method is also an equivalent of <a href="http://ponyfoo.com/articles/fun-with-native-arrays#asserting-with-some-and-every" target="_blank" aria-label="Asserting with .some and .every on Pony Foo"><code class="md-code md-code-inline">.some</code></a> and <a href="https://ponyfoo.com/#arrayprototypefind"><code class="md-code md-code-inline">.find</code></a>. Instead of returning <code class="md-code md-code-inline">true</code>, like <code class="md-code md-code-inline">.some</code>; or <code class="md-code md-code-inline">item</code>, like <code class="md-code md-code-inline">.find</code>; this method returns the <code class="md-code md-code-inline">index</code> position so that <code class="md-code md-code-inline">array[index] === item</code>. If none of the elements in the collection match the <code class="md-code md-code-inline">callback(item, i, array)</code> criteria, the return value is <code class="md-code md-code-inline">-1</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>, <span class="md-code-number">5</span>].find(item =&gt; item &gt; <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- 2</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>, <span class="md-code-number">5</span>].find((item, i) =&gt; i === <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- 3</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>, <span class="md-code-number">5</span>].find(item =&gt; item === <span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- -1</span>
</code></pre> <p>Again, quite straightforward.</p> <h1 id="arrayprototypekeys"><code class="md-code md-code-inline">Array.prototype.keys</code></h1> <p>Returns an iterator that yields a sequence holding the keys for the array. The returned value is an iterator, meaning you can use it with all of the usual suspects like <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">for..of</code></a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread operator</a>, or by hand by manually calling <code class="md-code md-code-inline">.next()</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].keys()
<span class="md-code-comment">// &lt;- ArrayIterator {}</span>
</code></pre> <p>Here&#x2019;s an example using <code class="md-code md-code-inline">for..of</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> key of [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].keys()) {
  <span class="md-code-built_in">console</span>.log(key)
  <span class="md-code-comment">// &lt;- 0</span>
  <span class="md-code-comment">// &lt;- 1</span>
  <span class="md-code-comment">// &lt;- 2</span>
}
</code></pre> <p>Unlike <code class="md-code md-code-inline">Object.keys</code> and most methods that iterate over arrays, this sequence doesn&#x2019;t ignore holes.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark">...</mark>new <span class="md-code-built_in">Array</span>(<span class="md-code-number">3</span>)<mark class="md-mark md-code-mark">.keys()</mark>]
<span class="md-code-comment">// &lt;- [0, 1, 2]</span>
<span class="md-code-built_in">Object</span>.keys(<span class="md-code-keyword">new</span> <span class="md-code-built_in">Array</span>(<span class="md-code-number">3</span>))
<span class="md-code-comment">// &lt;- []</span>
</code></pre> <p>Now onto values.</p> <h1 id="arrayprototypevalues"><code class="md-code md-code-inline">Array.prototype.values</code></h1> <p>Same thing as <code class="md-code md-code-inline">.keys()</code>, but the returned iterator is a sequence of values instead of indices. In practice, you&#x2019;ll probably just iterate over the array itself, but sometimes getting an iterator can come in handy.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].values()
<span class="md-code-comment">// &lt;- ArrayIterator {}</span>
</code></pre> <p>Then you can use <code class="md-code md-code-inline">for..of</code> or any other methods like a spread operator to pull out the sequence. The example below shows how using the spread operator on an array&#x2019;s <code class="md-code md-code-inline">.values()</code> doesn&#x2019;t really make a lot of sense <em>&#x2013; you already had that collection to begin with!</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark">...</mark>[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>]<mark class="md-mark md-code-mark">.values()</mark>]
<span class="md-code-comment">// &lt;- [1, 2, 3]</span>
</code></pre> <p>Do note that the returned array in the example above is <em>a different array</em> and not a reference to the original one.</p> <blockquote> <p>Time for <code class="md-code md-code-inline">.entries</code>.</p> </blockquote> <h1 id="arrayprototypeentries"><code class="md-code md-code-inline">Array.prototype.entries</code></h1> <p>Similar to both preceding methods, but this one returns an iterator with a sequence of key-value pairs.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-string">&apos;a&apos;</span>, <span class="md-code-string">&apos;b&apos;</span>, <span class="md-code-string">&apos;c&apos;</span>].entries()
<span class="md-code-comment">// &lt;- ArrayIterator {}</span>
</code></pre> <p>Each entry contains a two dimensional array element with the key and the value for an item in the array.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[...[<span class="md-code-string">&apos;a&apos;</span>, <span class="md-code-string">&apos;b&apos;</span>, <span class="md-code-string">&apos;c&apos;</span>].entries()]
<span class="md-code-comment">// &lt;- [[0, &apos;a&apos;], [1, &apos;b&apos;], [2, &apos;c&apos;]]</span>
</code></pre> <p>Great, last one to go!</p> <h1 id="arrayprototype-symboliterator"><code class="md-code md-code-inline">Array.prototype[Symbol.iterator]</code></h1> <p>This is <del>basically</del> <ins><strong>exactly</strong></ins> the same as the <a href="https://ponyfoo.com/#arrayprototypevalues"><code class="md-code md-code-inline">.values</code></a> method. The example below combines a spread operator, an array, and <code class="md-code md-code-inline">Symbol.iterator</code> to iterate over its values.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark">...</mark>[<span class="md-code-string">&apos;a&apos;</span>, <span class="md-code-string">&apos;b&apos;</span>, <span class="md-code-string">&apos;c&apos;</span>]<mark class="md-mark md-code-mark">[Symbol.iterator]()</mark>]
<span class="md-code-comment">// &lt;- [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span>
</code></pre> <p>Of course, you should probably just omit the spread operator and the <code class="md-code md-code-inline">[Symbol.iterator]</code> part in most use cases. Same time tomorrow? We&#x2019;ll cover changes to the <code class="md-code md-code-inline">Object</code> API.</p></div>
