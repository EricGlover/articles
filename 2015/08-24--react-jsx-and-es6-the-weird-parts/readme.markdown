<div></div>

<h1>React, JSX and ES6: The Weird Parts</h1>

<p><kbd>react</kbd> <kbd>jsx</kbd> <kbd>es6</kbd> <kbd>rant</kbd></p>

<blockquote><p>I&#x2019;ve spent a few days working with JSX and React and I have <strong>mixed feelings</strong> about them. React is pretty neat, but I find that they made some very unusual choices &#x2026;</p></blockquote>

<div><p>I&#x2019;ve spent a few days working with JSX and React and I have <strong>mixed feelings</strong> about them. React is pretty neat, but I find that they made some very unusual choices when it comes to their API design. Then there&#x2019;s JSX, definitely the weirdest aspect of React &#x2013; we&#x2019;ll look into it as well. I&#x2019;ve really enjoyed the ES6 and Babel experience, although I&#x2019;ve noticed that there&#x2019;s a learning curve where you start to decide whether using an ES6 feature is better than its ES5 equivalent or not, something we&#x2019;ll explore towards the end of the article.</p></div>

<div></div>

<div><p><img src="https://i.imgur.com/FKrDjJ1.jpg" alt="1961 Buick &amp;quot;Flamingo&amp;quot; with rotating front seat"></p></div>

<div><h1 id="jsx-is-the-new-xhtml">JSX is the new XHTML</h1> <p>Web-oriented template engines typically consist of an entirely new language <em>&#x2013; <a href="http://jade-lang.com/" target="_blank" aria-label="Jade Template Engine">Jade</a>, <a href="http://www.dustjs.com/" target="_blank" aria-label="Dust.js by LinkedIn">Dust.js</a>, etc &#x2013;</em> or a few extensions on top of HTML <em>&#x2013; <a href="https://mustache.github.io/" target="_blank" aria-label="{{ mustache }}">Mustache</a>, <a href="http://twitter.github.io/hogan.js/" target="_blank" aria-label="JavaScript Templating from Twitter">Hogan</a>, <a href="http://mozilla.github.io/nunjucks/" target="_blank" aria-label="Nunjucks from Mozilla">Nunjucks</a>, etc</em>. We rarely see hybrids like JSX, a language that&#x2019;s more or less aligned with XHTML but which also comes with some gross limitations in what you&#x2019;re able to do with it, alongside &#x201C;cool&#x201D; features like being able to mix it with JavaScript code. In that last aspect, it&#x2019;s sort of like <a href="http://jade-lang.com/" target="_blank" aria-label="Jade Template Engine">Jade</a>, which you can also mix with JavaScript, but I&#x2019;ll admit that mixing JavaScript and JSX is way cleaner than mixing JavaScript with Jade.</p> <p>React being one of the communities that push ES6 most aggressively, I would&#x2019;ve liked to see them implement views largely based around ES6 string interpolation. Of course, JSX was created so that you don&#x2019;t have to use React&#x2019;s virtual DOM API, which can get very verbose with <em>a method call for each DOM element.</em> But still, it would&#x2019;ve been nice if they took a more ES6<em>ish</em> approach. And boy is JSX weird. In fact, the point about DOM elements brings me to an unfortunate side effect of JSX.</p> <h2 id="unexpected-and-automatic-dom-element-insertion">Unexpected and automatic DOM element insertion</h2> <p>As a newcomer to React, the fact that this:</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">span</span>&gt;</span>foo {&apos;bar&apos;} {&apos;baz&apos;}<span class="md-code-tag">&lt;/<span class="md-code-title">span</span>&gt;</span>
</code></pre> <p>Is turned into that:</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">span</span> <span class="md-code-attribute">data-reactid</span>=<span class="md-code-value">&quot;.1gm29bnrabk.1.0&quot;</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">span</span> <span class="md-code-attribute">data-reactid</span>=<span class="md-code-value">&quot;.1gm29bnrabk.1.0.0&quot;</span>&gt;</span>foo <span class="md-code-tag">&lt;/<span class="md-code-title">span</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">span</span> <span class="md-code-attribute">data-reactid</span>=<span class="md-code-value">&quot;.1gm29bnrabk.1.0.1&quot;</span>&gt;</span>bar<span class="md-code-tag">&lt;/<span class="md-code-title">span</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">span</span> <span class="md-code-attribute">data-reactid</span>=<span class="md-code-value">&quot;.1gm29bnrabk.1.0.2&quot;</span>&gt;</span> <span class="md-code-tag">&lt;/<span class="md-code-title">span</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">span</span> <span class="md-code-attribute">data-reactid</span>=<span class="md-code-value">&quot;.1gm29bnrabk.1.0.3&quot;</span>&gt;</span>baz<span class="md-code-tag">&lt;/<span class="md-code-title">span</span>&gt;</span>
<span class="md-code-tag">&lt;/<span class="md-code-title">span</span>&gt;</span>
</code></pre> <p>Makes absolutely no sense to me. I&#x2019;ll just go ahead and assume that this makes the life of whoever maintains the virtual DOM implementation in React easier, but they should&#x2019;ve considered <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createTextNode" target="_blank" aria-label="Document.createTextNode() &#x2013; MDN">using text nodes</a>. You might think this is not a big deal, but it is if we&#x2019;re styling <code class="md-code md-code-inline">&lt;span&gt;</code> elements in a certain way. In particular if you just expected the span you actually wrote to be the only <code class="md-code md-code-inline">&lt;span&gt;</code>, and defined a style such as <code class="md-code md-code-inline">font-size: 1.1em</code>, or even <code class="md-code md-code-inline">padding: 5px</code>.</p> <blockquote> <p>Besides, isn&#x2019;t the whole point of React to avoid as many DOM operations as possible?</p> </blockquote> <h2 id="using-conditionals-in-your-view-components">Using conditionals in your view components</h2> <p>Whenever you&#x2019;re dealing with dynamic representations of data, particularly optional user-entered information such as the metadata about a product in an e-commerce application, you&#x2019;ll want some sort of way to conditionally render a component.</p> <p>For some reason, React&#x2019;s JSX make this <a href="https://facebook.github.io/react/tips/if-else-in-JSX.html" target="_blank" aria-label="If-Else in JSX">unnecessarily complicated</a> by not being able to use <code class="md-code md-code-inline">if</code> statements inside code blocks. The advertised solution is to place your conditionals outside of the template, in the component&#x2019;s <code class="md-code md-code-inline">render</code> method. Here&#x2019;s a piece of code showing the coding style they recommend.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> loginButton;
<span class="md-code-keyword">if</span> (loggedIn) {
  loginButton = <span><span class="md-code-tag">&lt;<span class="md-code-title">LogoutButton</span> /&gt;</span>;</span>
} <span class="md-code-keyword">else</span> {
  loginButton = <span><span class="md-code-tag">&lt;<span class="md-code-title">LoginButton</span> /&gt;</span>;</span>
}

<span class="md-code-keyword">return</span> (
  <span><span class="md-code-tag">&lt;<span class="md-code-title">nav</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">Home</span> /&gt;</span>
    {loginButton}
  <span class="md-code-tag">&lt;/<span class="md-code-title">nav</span>&gt;</span>
);
</span></code></pre> <p>Note that, in case you just wanted the <code class="md-code md-code-inline">if</code> leg <em>(no <code class="md-code md-code-inline">else</code>)</em>, you could leave <code class="md-code md-code-inline">loginButton</code> as <code class="md-code md-code-inline">undefined</code> and nothing would be rendered. The problem here is that you end up having to hoist parts of your component for no reason other than what is, plainly put, <strong>a limitation of the JSX language</strong>.</p> <p>A <em>(still terrible)</em> workaround that allows you to place conditional logic into the template is to use binary operators. For some other reason, those <em>are</em> supported by JSX. Of course, this is sad to look at, slightly confusing, and not as clear as plain <code class="md-code md-code-inline">if</code> / <code class="md-code md-code-inline">else</code> would have been.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">return</span> (
  <span><span class="md-code-tag">&lt;<span class="md-code-title">nav</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">Home</span> /&gt;</span>
    { loggedIn &amp;&amp; <span class="md-code-tag">&lt;<span class="md-code-title">LogoutButton</span> /&gt;</span> || <span class="md-code-tag">&lt;<span class="md-code-title">LoginButton</span> /&gt;</span> }
  <span class="md-code-tag">&lt;/<span class="md-code-title">nav</span>&gt;</span>
);
</span></code></pre> <h2 id="declaring-a-doctype">Declaring a doctype</h2> <p>Apparently declaring a <code class="md-code md-code-inline">&lt;doctype&gt;</code> <a href="https://github.com/facebook/react/issues/1035" target="_blank" aria-label="&apos;Allow html conditional comments and doctype&apos; on GitHub Issues">is impossible</a> when it comes to React. I ended up with an unimpressive <code class="md-code md-code-inline">&apos;&lt;!doctype html&gt;&apos; + layout</code> concatenation. This would be fine if we were just doing client-side rendering but we&#x2019;re trying to get to a shared rendering application here, kind of the whole point of using a library like React.</p> <p>Concatenating the <code class="md-code md-code-inline">&lt;doctype&gt;</code> on the server-side will have to do for now. Luckily, it doesn&#x2019;t break the diffing algorithm when the client-side code boots the application state.</p> <h2 id="declaring-html-comments">Declaring HTML comments</h2> <p>HTML comments are similarly hard to shove into a JSX template. Granted, this isn&#x2019;t something you want to add to a document very often, but it&#x2019;s still important to be able to declare some when you actually need to. If you want HTML comments in your JSX very badly, you can use the method below <em>(derived from <a href="https://nemisj.com/conditional-ie-comments-in-react-js/" target="_blank" aria-label="Conditional IE comments in React">this blog post</a>)</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> comments = `&lt;!--[<span class="md-code-keyword">if</span> lte IE <span class="md-code-number">8</span>]&gt;
  <span><span class="md-code-tag">&lt;<span class="md-code-title">script</span> <span class="md-code-attribute">src</span>=<span class="md-code-value">&quot;/js/html5shim.js&quot;</span>&gt;</span><span></span><span class="md-code-tag">&lt;/<span class="md-code-title">script</span>&gt;</span>
<span class="md-code-tag">&lt;<span class="md-code-title">![endif]--</span>&gt;</span>`
</span></code></pre> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">head</span> <span class="md-code-attribute">dangerouslySetInnerHTML</span>=<span class="md-code-value">{{__html:</span> <span class="md-code-attribute">comments</span>}} /&gt;</span>
</code></pre> <p>Which, <em>OBVIOUSLY</em> brings us to my next point.</p> <h2 id="react-s-smart-dangerouslysetinnerhtml-api">React&#x2019;s &#x201C;smart&#x201D; <code class="md-code md-code-inline">dangerouslySetInnerHTML</code> API</h2> <p>I definitely can relate to the notion of attempting to help your consumers not to make mistakes, but this API borders on <strong>pompous and presumptuous</strong>. The <a href="https://facebook.github.io/react/tips/dangerously-set-inner-html.html" target="_blank" aria-label="Dangerously Set innerHTML">documentation rightly asserts</a> that misuse of unescaped HTML might result in <strong>XSS vulnerabilities</strong> and that you should sanitize user input. A public API method&#x2019;s name is not the place where to tell people everything that could go wrong with it, though.</p> <p>Angular used to have a similar <code class="md-code md-code-inline">ng-bind-html-unsafe</code>, which at least wasn&#x2019;t as presumptuous. It has since been deprecated in favor of <a href="https://docs.angularjs.org/guide/migration#ngbindhtmlunsafe-has-been-removed-and-replaced-by-ngbindhtml" target="_blank" aria-label="ngBindHtmlUnsafe has been removed and replaced by ngBindHtml &#x2013; AngularJS Documentation"><code class="md-code md-code-inline">ng-bind-html</code></a>, which is a saner version of React&#x2019;s implementation. When passed a string, it&#x2019;ll become sanitized, and if you want it to be unescaped you just tell it through their <code class="md-code md-code-inline">$sce.trustAsHtml(string)</code> service. Of course, in that respect it might&#x2019;ve been better to just let the user pass in something like <code class="md-code md-code-inline">{ unescaped: &apos;some &lt;strong&gt;html&lt;/strong&apos; }</code> instead of having to go through a service, but it&#x2019;s good enough &#x2013; at least it&#x2019;s not as condescending, and I don&#x2019;t feel like throwing up whenever I&#x2019;m using the API.</p> <h2 id="components-coupled-to-client-side-code-and-es6">Components coupled to client-side code and ES6</h2> <p>Another big issue in my understanding of React is the way how components are loaded. Pretty much the entire React codebase is loaded on the server-side, and that means that a lot of libraries which are meant for the client-side of your application will be loaded on the server. This becomes an issue whenever you are loading a module that accesses the DOM before you even use it, &#x2013; usually happens when a library does feature testing to decide the API they&#x2019;ll export &#x2013; as that&#x2019;ll result in a thrown exception on the server-side <em>(as there is no DOM to be accessed)</em>.</p> <p>You could work around this by using <code class="md-code md-code-inline">require</code> statements instead of <code class="md-code md-code-inline">import</code>, and requiring those client-side-only modules on a method like <code class="md-code md-code-inline">componentDidMount</code>, which only get executed in the client-side. ES6 <code class="md-code md-code-inline">import</code> statements need to be defined at the top level of your module definition, though, which means you can&#x2019;t work around this one using plain ES6.</p> <p>This can be really problematic as even a test like <code class="md-code md-code-inline">modern = !!window.document.addEventListener</code> would break on the server-side, and there&#x2019;s plenty of client-side libraries that do this before you call any methods on them.</p> <h2 id="wrapping-up">Wrapping Up</h2> <p>I&#x2019;ve yet to play around with <code class="md-code md-code-inline">redux</code> and client-side routing &#x2013; two big things that I&#x2019;ll be playing with next and which might change my mind about a few of the points I&#x2019;ve made here. I&#x2019;ve only played around with React lightly, so take the article with a grain of <em>&#x201C;React onboarding experience areas of improvement&#x201D;</em> salt.</p> <p>The new site is now up at <a href="http://bevacqua.io/" target="_blank" aria-label="My consulting site">bevacqua.io</a>, and while I definitely didn&#x2019;t need to use React to put it together, it&#x2019;s always interesting to try out new pieces of front-end technology. I don&#x2019;t <em>only have</em> ranty things to say about JSX, and I&#x2019;m sure it&#x2019;ll grow on me as I use it for more stateful applications and combined with <code class="md-code md-code-inline">redux</code>.</p> <p>ES6 has been fun so far, and I find myself gradually adopting some of the language features, as well as writing less semicolons. What&#x2019;s hard sometimes is to decide when to use an ES6 feature such as arrow functions over a named function declaration. In general I&#x2019;ve been taking the approach of defaulting to the ES5 alternative, because I don&#x2019;t want to be littering my code with ES6 expressions just for the sake of it.</p> <p>As a fun fact, here&#x2019;s <a href="https://github.com/bevacqua/bevacqua.io/blob/a7b34539656a0d47f53971be38dcfff69ff690c9/components/opensource/project.js#L49-L52" target="_blank" aria-label="Source code for bevacqua.io site on GitHub">a snippet of code</a> I felt happy to write using lots of ES6 and the experimental <code class="md-code md-code-inline">::</code> ES7 <a href="http://babeljs.io/blog/2015/05/14/function-bind/" target="_blank" aria-label="Function Bind Syntax on Babel&apos;s Blog">function bind</a> syntax. Usually there&#x2019;s lots of named method involved in this sort of code, or <code class="md-code md-code-inline">async.apply</code> <em>(or <code class="md-code md-code-inline">contra.curry</code>)</em>, and ES6 definitely made my code cleaner on this one.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">concurrent({
  repo: next =&gt; query(<span class="md-code-string">&apos;/repos/&apos;</span> + repo, next),
  master: next =&gt; query(<span class="md-code-string">&apos;/repos/&apos;</span> + repo + <span class="md-code-string">&apos;/branches/master&apos;</span>, next)
}, ::<span class="md-code-keyword">this</span>.pulledRepo)
</code></pre> <p><sub><em>By the way concurrent is a method from <a href="https://github.com/bevacqua/contra" target="_blank" aria-label="bevacqua/contra on GitHub"><code class="md-code md-code-inline">contra</code></a>, equivalent to <a href="https://github.com/caolan/async" target="_blank" aria-label="caolan/async on GitHub"><code class="md-code md-code-inline">async.parallel</code></a>.</em></sub></p> <p>Yay!</p></div>
