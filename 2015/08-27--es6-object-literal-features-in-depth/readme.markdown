<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/master/contributing.markdown"><code>contributing.markdown</code></a> for details.</sub>

<a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth"><div></div></a>

<h1>ES6 Object Literal Features in Depth</h1>

<p><kbd>es6</kbd> <kbd>object-literals</kbd> <kbd>es6-in-depth</kbd></p>

<blockquote><p>Once again, this is <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a>. If you haven&#x2019;t set foot on this series before, you might want to learn about <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, &#x2026;</p></blockquote>

<div><p>Once again, this is <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a>. If you haven&#x2019;t set foot on this series before, you might want to learn about <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, or the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>. Today&#x2019;s special is <em>object literals in ES6.</em> <strong>&#x201C;Sure, I can use those today&#x201D;</strong>, you say &#x2013; object literals date all the way back to ES3. This article is about new features coming in ES6 for object literals.</p></div>

<div></div>

<div><p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to internalize the concepts discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em></p> <p>Onto the new stuff!</p></div>

<div><h2 id="property-value-shorthands">Property Value Shorthands</h2> <p>Whenever you find yourself assigning a property value that matches a property name, you can omit the property value, it&#x2019;s implicit in ES6.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = <span class="md-code-string">&apos;bar&apos;</span>
<span class="md-code-keyword">var</span> baz = { foo }
<span class="md-code-built_in">console</span>.log(baz.foo)
<span class="md-code-comment">// &lt;- &apos;bar&apos;</span>
</code></pre> <p>In the snippet shown below I re-implemented part of <code class="md-code md-code-inline">localStorage</code> in memory as a polyfill. It displays a pattern that I&#x2019;ve followed countless times <a href="https://github.com/bevacqua/local-storage/blob/b9725b0fc77faabc737ba7c6ee57d343afa95102/stub.js#L3-L32" target="_blank" aria-label="See bevacqua/local-storage on GitHub">in my code</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> ms = {}

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getItem</span> <span class="md-code-params">(key)</span> </span>{
  <span class="md-code-keyword">return</span> key <span class="md-code-keyword">in</span> ms ? ms[key] : <span class="md-code-literal">null</span>
}

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">setItem</span> <span class="md-code-params">(key, value)</span> </span>{
  ms[key] = value
}

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">clear</span> <span class="md-code-params">()</span> </span>{
  ms = {}
}

<mark class="md-mark md-code-mark">module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
}</mark>
</code></pre> <p>The reasons why <em>&#x2013; most often &#x2013;</em> I don&#x2019;t place functions directly on an object definition are <em>several.</em></p> <ul> <li>Less indentation needed</li> <li>Public API stands out</li> <li>Harder to tightly couple methods</li> <li>Easier to reason about</li> </ul> <p>With ES6, we can throw another bullet into that list, and that&#x2019;s that the export can be even easier using <em>property value shorthands</em>. You can omit the property value if it matches the property name. The <code class="md-code md-code-inline">module.exports</code> from the code above thus becomes:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">module</span>.exports = { getItem, setItem, clear }
</code></pre> <p>So good!</p> <h2 id="computed-property-names">Computed Property Names</h2> <p>We already covered computed property names briefly in the <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo">destructuring article</a>. This was a very common thing to do for me:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = <span class="md-code-string">&apos;bar&apos;</span>
<span class="md-code-keyword">var</span> baz = {}
baz[foo] = <span class="md-code-string">&apos;ponyfoo&apos;</span>
<span class="md-code-built_in">console</span>.log(baz)
<span class="md-code-comment">// &lt;- { bar: &apos;ponyfoo&apos; }</span>
</code></pre> <p>Computed property names allow you to write an <em>expression</em> wrapped in square brackets instead of the regular property name. Whatever the expression evaluates to will become the property name.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = <span class="md-code-string">&apos;bar&apos;</span>
<span class="md-code-keyword">var</span> baz = { [foo]: <span class="md-code-string">&apos;ponyfoo&apos;</span> }
<span class="md-code-built_in">console</span>.log(baz)
<span class="md-code-comment">// &lt;- { bar: &apos;ponyfoo&apos; }</span>
</code></pre> <p>One limitation of computed property names is that you won&#x2019;t be able to use the shorthand expression with it. I presume this is because shorthand expression is meant to be simple, compile-time sugar.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = <span class="md-code-string">&apos;bar&apos;</span>
<span class="md-code-keyword">var</span> bar = <span class="md-code-string">&apos;ponyfoo&apos;</span>
<span class="md-code-keyword">var</span> baz = { [foo] }
<span class="md-code-built_in">console</span>.log(baz)
<span class="md-code-comment">// &lt;- SyntaxError</span>
</code></pre> <p>That being said, I believe this to be the most common use case. Here our code is simpler because we don&#x2019;t have to spend three steps in allocating a <code class="md-code md-code-inline">foo</code> variable, assigning to <code class="md-code md-code-inline">foo[type]</code>, and returning <code class="md-code md-code-inline">foo</code>. Instead we can do all three in a single statement.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getModel</span> <span class="md-code-params">(type)</span> </span>{
  <span class="md-code-keyword">return</span> {
    [type]: {
      message: <span class="md-code-string">&apos;hello, this is doge&apos;</span>,
      date: <span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>()
    }
  }
}
</code></pre> <p>Neat. What else?</p> <h2 id="method-definitions">Method Definitions</h2> <p>Typically in ES5 you declare methods on an object like so:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = {
  bar: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(baz)</span> </span>{
  }
}
</code></pre> <p>While getters and setters have a syntax like this, where there&#x2019;s no need for the <code class="md-code md-code-inline">function</code> keyword. It&#x2019;s just inferred from context.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> cart = {
  _wheels: <span class="md-code-number">4</span>,
  get wheels () {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">this</span>._wheels
  },
  set wheels (value) {
    <span class="md-code-keyword">if</span> (value &lt; <span class="md-code-keyword">this</span>._wheels) {
      <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;hey, come back here!&apos;</span>)  
    }
    <span class="md-code-keyword">this</span>._wheels = value
  }
}
</code></pre> <p>Starting in ES6, you can declare regular methods with a similar syntax, only difference is it&#x2019;s not prefixed by <code class="md-code md-code-inline">get</code> or <code class="md-code md-code-inline">set</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">var cart = {
  _wheels: 4,
  get wheels () {
    return this._wheels
  },
  set wheels (value) {
    if (value &lt; this._wheels) {
      throw new Error(&apos;hey, come back here!&apos;)  
    }
    this._wheels = value
  },
  <mark class="md-mark md-code-mark">dismantle () {
    this._wheels = 0
    console.warn(`you&apos;re all going to pay for this!`)
  }</mark>
}
</code></pre> <p>I think it&#x2019;s nice that methods converged together with getters and setter. I for one don&#x2019;t use this syntax a lot because I like to name my functions and decouple them from their host objects as I explained in the <a href="https://ponyfoo.com/#property-value-shorthands">shorthand</a> section. However, it&#x2019;s still useful in some situations and definitely useful when declaring <em>&#x201C;classes&#x201D;</em> &#x2013; if you&#x2019;re into that sort of thing.</p></div>
