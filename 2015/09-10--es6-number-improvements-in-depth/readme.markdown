<div></div>

<h1>ES6 Number Improvements in Depth</h1>

<p><kbd>es6</kbd> <kbd>number</kbd> <kbd>es6-in-depth</kbd></p>

<blockquote><p>Hey there! Glad you&#x2019;re here in time for <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Back to School&#x201D;</em> &#x2013; in Depth</a>. Never heard of it? Refer to <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. &#x2026;</p></blockquote>

<div><p>Hey there! Glad you&#x2019;re here in time for <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Back to School&#x201D;</em> &#x2013; in Depth</a>. Never heard of it? Refer to <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="https://ponyfoo.com/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>, <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a>, <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>, <a href="https://ponyfoo.com/articles/es6-symbols-in-depth">Symbols</a>, <a href="https://ponyfoo.com/articles/es6-maps-in-depth">Maps</a>, <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="https://ponyfoo.com/articles/es6-proxies-in-depth">proxies</a>, <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth">proxy traps</a>, <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth">more proxy traps</a>, and <a href="https://ponyfoo.com/articles/es6-reflection-in-depth">reflection</a>. Today we&#x2019;ll learn about <code class="md-code md-code-inline">Number</code> improvements.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for reading that, and let&#x2019;s go into <code class="md-code md-code-inline">Number</code> improvements. These changes don&#x2019;t really depend on anything we&#x2019;ve covered so far <em>&#x2013; although I would strongly recommend you <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">skim over articles in the series</a> if you haven&#x2019;t done so yet.</em> Time to dig into <code class="md-code md-code-inline">Number</code>.</p></div>

<div><h1 id="number-improvements-in-es6"><code class="md-code md-code-inline">Number</code> Improvements in ES6</h1> <p>There&#x2019;s a number of changes coming to <code class="md-code md-code-inline">Number</code> in ES6 <em>&#x2013; see what I did there?</em> First off, let&#x2019;s raise the curtain with a summary of the features we&#x2019;ll be talking about. We&#x2019;ll go over all of the following changes to <code class="md-code md-code-inline">Number</code> today.</p> <ul> <li><a href="https://ponyfoo.com/#binary-and-octal-literals">Binary and Octal Literals</a> <em>&#x2013; using <code class="md-code md-code-inline">0b</code> and <code class="md-code md-code-inline">0o</code></em></li> <li><a href="https://ponyfoo.com/#numberisnan"><code class="md-code md-code-inline">Number.isNaN</code></a></li> <li><a href="https://ponyfoo.com/#numberisfinite"><code class="md-code md-code-inline">Number.isFinite</code></a></li> <li><a href="https://ponyfoo.com/#numberparseint"><code class="md-code md-code-inline">Number.parseInt</code></a></li> <li><a href="https://ponyfoo.com/#numberparsefloat"><code class="md-code md-code-inline">Number.parseFloat</code></a></li> <li><a href="https://ponyfoo.com/#numberisinteger"><code class="md-code md-code-inline">Number.isInteger</code></a></li> <li><a href="https://ponyfoo.com/#numberepsilon"><code class="md-code md-code-inline">Number.EPSILON</code></a></li> <li><a href="https://ponyfoo.com/#numbermax-safe-integer"><code class="md-code md-code-inline">Number.MAX_SAFE_INTEGER</code></a></li> <li><a href="https://ponyfoo.com/#numbermin-safe-integer"><code class="md-code md-code-inline">Number.MIN_SAFE_INTEGER</code></a></li> <li><a href="https://ponyfoo.com/#numberissafeinteger"><code class="md-code md-code-inline">Number.isSafeInteger</code></a></li> </ul> <p><img alt="The curtain is raising..." class="" src="https://i.imgur.com/GrB4w7R.jpg"></p> <h2 id="binary-and-octal-literals">Binary and Octal Literals</h2> <p>Before ES6, your best bet when it comes to binary representation of integers was to just pass them to <code class="md-code md-code-inline">parseInt</code> with a radix of <code class="md-code md-code-inline">2</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;101&apos;</span>, <mark class="md-mark md-code-mark">2</mark>)
<span class="md-code-comment">// &lt;- 5</span>
</code></pre> <p>In ES6 you could also use the <code class="md-code md-code-inline">0b</code> prefix to represent binary integer literals. You could also use <code class="md-code md-code-inline">0B</code> but I suggest you stick with the lower-case option.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">0b</mark>001)
<span class="md-code-comment">// &lt;- 1</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-number">0</span>b010)
<span class="md-code-comment">// &lt;- 2</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-number">0</span>b011)
<span class="md-code-comment">// &lt;- 3</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-number">0</span>b100)
<span class="md-code-comment">// &lt;- 4</span>
</code></pre> <p>Same goes for octal literals. In ES3, <code class="md-code md-code-inline">parseInt</code> interpreted strings of digits starting with a <code class="md-code md-code-inline">0</code> as an octal value. That meant things got weird quickly when you forgot to specify a radix of <code class="md-code md-code-inline">10</code> <em>&#x2013; and that soon became a best practice.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;01&apos;</span>)
<span class="md-code-comment">// &lt;- 1</span>
<span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;08&apos;</span>)
<span class="md-code-comment">// &lt;- 0</span>
<span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;8&apos;</span>)
<span class="md-code-comment">// &lt;- 8</span>
</code></pre> <p>When ES5 came around, it got rid of the octal interpretation in <code class="md-code md-code-inline">parseInt</code> &#x2013; although <strong>it&#x2019;s still recommended</strong> you specify a <code class="md-code md-code-inline">radix</code> for backwards compatibility purposes. If you actually wanted octal, you could get those using a radix of <code class="md-code md-code-inline">8</code>, anyways.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;100&apos;</span>, <span class="md-code-string">&apos;8&apos;</span>)
<span class="md-code-comment">// &lt;- 64</span>
</code></pre> <p>When it comes to ES6, you can now use the <code class="md-code md-code-inline">0o</code> prefix for octal literals. You could also use <code class="md-code md-code-inline">0O</code>, but that&#x2019;s going to look very confusing in some typefaces, so I suggest you stick with the <code class="md-code md-code-inline">0o</code> notation.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-number">0</span>o010)
<span class="md-code-comment">// &lt;- 8</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-number">0</span>o100)
<span class="md-code-comment">// &lt;- 64</span>
</code></pre> <p>Keep in mind that octal literals aren&#x2019;t actually going to crop up everywhere in your front-end applications anytime soon, so you shouldn&#x2019;t worry too much about the seemingly odd choice <em>(font clarity wise)</em> of a <code class="md-code md-code-inline">0o</code> prefix. Besides, most of us use editors that have no trouble at all differentiating between <code class="md-code md-code-inline">0o</code>, <code class="md-code md-code-inline">0O</code>, <code class="md-code md-code-inline">00</code>, <code class="md-code md-code-inline">OO</code>, and <code class="md-code md-code-inline">oo</code>.</p> <p><img alt="Those characters render just fine in Sublime Text 3" class="" src="https://i.imgur.com/buOiD1I.png"></p> <p>If you&#x2019;re now perplexed and left wondering <em>&#x201C;what about hexadecimal?&#x201D;</em>, don&#x2019;t you worry, those were already part of the language in ES5, and you can still use them. The prefix for literal <em>hexadecimal</em> notation is either <code class="md-code md-code-inline">0x</code>, or <code class="md-code md-code-inline">0X</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-number">0x0ff</span>)
<span class="md-code-comment">// &lt;- 255</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-number">0xf00</span>)
<span class="md-code-comment">// &lt;- 3840</span>
</code></pre> <p>Enough with number literals, let&#x2019;s talk about something else. The first four additions to <code class="md-code md-code-inline">Number</code> that we&#x2019;ll be discussing &#x2013; <code class="md-code md-code-inline">Number.isNaN</code>, <code class="md-code md-code-inline">Number.isFinite</code>, <code class="md-code md-code-inline">Number.parseInt</code>, and <code class="md-code md-code-inline">Number.parseFloat</code> &#x2013; already existed in ES5, but in the global namespace. In addition, the methods in <code class="md-code md-code-inline">Number</code> are slightly different in that they don&#x2019;t coerce non-numeric values into numbers before producing a result.</p> <h2 id="numberisnan"><code class="md-code md-code-inline">Number.isNaN</code></h2> <p>This method is almost identical to ES5 global <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/isNaN" target="_blank" aria-label="Global isNaN() on MDN"><code class="md-code md-code-inline">isNaN</code></a> method. <code class="md-code md-code-inline">Number.isNaN</code> returns whether the provided <code class="md-code md-code-inline">value</code> equals <code class="md-code md-code-inline">NaN</code>. This is a very different question from <em>&#x201C;is this not a number?&#x201D;</em>.</p> <p>The snippet shown below quickly shows that anything that&#x2019;s not <code class="md-code md-code-inline">NaN</code> when passed to <code class="md-code md-code-inline">Number.isNaN</code> will return <code class="md-code md-code-inline">false</code>, while passing <code class="md-code md-code-inline">NaN</code> into it will yield <code class="md-code md-code-inline">true</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.isNaN(<span class="md-code-number">123</span>)
<span class="md-code-comment">// &lt;- false, integers are not NaN</span>
<span class="md-code-built_in">Number</span>.isNaN(<span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- false, Infinity is not NaN</span>
<span class="md-code-built_in">Number</span>.isNaN(<mark class="md-mark md-code-mark"><span class="md-code-string">&apos;ponyfoo&apos;</span></mark>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark>, &apos;ponyfoo&apos; is not NaN</span>
<span class="md-code-built_in">Number</span>.isNaN(<mark class="md-mark md-code-mark">NaN</mark>)
<span class="md-code-comment">// &lt;- true, NaN is NaN</span>
<span class="md-code-built_in">Number</span>.isNaN(<mark class="md-mark md-code-mark"><span class="md-code-string">&apos;pony&apos;</span>/<span class="md-code-string">&apos;foo&apos;</span></mark>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">true</mark>, &apos;pony&apos;/&apos;foo&apos; is NaN, NaN is NaN</span>
</code></pre> <p>The ES5 <code class="md-code md-code-inline">global.isNaN</code> method, in contrast, casts non-numeric values passed to it <em>before evaluating them against <code class="md-code md-code-inline">NaN</code></em>. That produces significantly different results. The example below produces incosistent results because, unlike <code class="md-code md-code-inline">Number.isNaN</code>, <code class="md-code md-code-inline">isNaN</code> casts the <code class="md-code md-code-inline">value</code> passed to it through <code class="md-code md-code-inline">Number</code> first.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">isNaN</span>(<span class="md-code-string">&apos;ponyfoo&apos;</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">true</mark>, because Number(&apos;ponyfoo&apos;) is NaN</span>
<span class="md-code-built_in">isNaN</span>(<span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>())
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>While <code class="md-code md-code-inline">Number.isNaN</code> is more precise than its global <code class="md-code md-code-inline">isNaN</code> counterpart because it doesn&#x2019;t incur in casting, it&#x2019;s still going to confuse people <strong>because reasons.</strong></p> <ol> <li><code class="md-code md-code-inline">global.isNaN</code> casts input through <code class="md-code md-code-inline">Number(value)</code> before comparison</li> <li><code class="md-code md-code-inline">Number.isNaN</code> <em>doesn&#x2019;t</em></li> <li>Neither <code class="md-code md-code-inline">Number.isNaN</code> nor <code class="md-code md-code-inline">global.isNaN</code> answer the <em>&#x201C;is this not a number?&#x201D;</em> question</li> <li>They answer whether <code class="md-code md-code-inline">value</code> <em>&#x2013; or <code class="md-code md-code-inline">Number(value)</code> &#x2013;</em> is <code class="md-code md-code-inline">NaN</code></li> </ol> <p>In most cases, what you actually want is to know whether a value identifies as a number <em>&#x2013; <code class="md-code md-code-inline">typeof NaN === &apos;number&apos;</code> &#x2013;</em> and <em>is</em> a number. The method below does just that. Note that it&#x2019;d work with both <code class="md-code md-code-inline">global.isNaN</code> and <code class="md-code md-code-inline">Number.isNaN</code> due to type checking. Everything that reports a <code class="md-code md-code-inline">typeof</code> value of <code class="md-code md-code-inline">&apos;number&apos;</code> is a number, except <code class="md-code md-code-inline">NaN</code>, so we <em>weed those out</em> to avoid false positives!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">isNumber</span> <span class="md-code-params">(value)</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-keyword">typeof</span> value === <span class="md-code-string">&apos;number&apos;</span> &amp;&amp; !<span class="md-code-built_in">Number</span>.isNaN(value)
}
</code></pre> <p>You can use that method to figure out whether anything is <strong>an actual number</strong> or not. Here&#x2019;s some examples of what constitutes actual JavaScript numbers or not.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">isNumber(<span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- true</span>
isNumber(<span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- true</span>
isNumber(<span class="md-code-literal">NaN</span>)
<span class="md-code-comment">// &lt;- false</span>
isNumber(<span class="md-code-string">&apos;ponyfoo&apos;</span>)
<span class="md-code-comment">// &lt;- false</span>
isNumber(<span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>())
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>Speaking of <code class="md-code md-code-inline">isNumber</code>, isn&#x2019;t there something like that in the language already? <em>Sort of.</em></p> <h2 id="numberisfinite"><code class="md-code md-code-inline">Number.isFinite</code></h2> <p>The <em>rarely-advertised</em> <code class="md-code md-code-inline">isFinite</code> method has been available since ES3 and it returns whether the provided <code class="md-code md-code-inline">value</code> <strong>matches none of</strong>: <code class="md-code md-code-inline">Infinity</code>, <code class="md-code md-code-inline">-Infinity</code>, and <code class="md-code md-code-inline">NaN</code>.</p> <p>Want to take a guess about the difference between <code class="md-code md-code-inline">global.isFinite</code> and <code class="md-code md-code-inline">Number.isFinite</code>?</p> <blockquote> <p>Correct! the <code class="md-code md-code-inline">global.isFinite</code> method coerces values through <code class="md-code md-code-inline">Number(value)</code>, while <code class="md-code md-code-inline">Number.isFinite</code> doesn&#x2019;t. Here are a few examples using <code class="md-code md-code-inline">global.isFinite</code>. This means that values that can be coerced into <em>non-<code class="md-code md-code-inline">NaN</code></em> numbers will be considered finite numbers by <code class="md-code md-code-inline">global.isNumber</code> <em>&#x2013; even though they&#x2019;re aren&#x2019;t actually numbers!</em></p> </blockquote> <p>In most cases <code class="md-code md-code-inline">isFinite</code> will be good enough, just like <code class="md-code md-code-inline">isNaN</code>, but when it comes to non-numeric values it&#x2019;ll start acting up and producing unexpected results due to its <code class="md-code md-code-inline">value</code> coercion into numbers.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">isFinite</span>(<span class="md-code-literal">NaN</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">isFinite</span>(<span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">isFinite</span>(-<span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">isFinite</span>(<mark class="md-mark md-code-mark">null</mark>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">true</mark>, because Number(null) is 0</span>
<span class="md-code-built_in">isFinite</span>(<span class="md-code-string">&apos;10&apos;</span>)
<span class="md-code-comment">// &lt;- true, because Number(&apos;10&apos;) is 10</span>
</code></pre> <p>Using <code class="md-code md-code-inline">Number.isFinite</code> is just an all-around safer bet as it doesn&#x2019;t incur in unwanted casting. You could always do <code class="md-code md-code-inline">Number.isFinite(Number(value))</code> if you did want the <code class="md-code md-code-inline">value</code> to be casted into its numeric representation.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.isFinite(<span class="md-code-literal">NaN</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isFinite(<span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isFinite(-<span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isFinite(<mark class="md-mark md-code-mark">null</mark>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
<span class="md-code-built_in">Number</span>.isFinite(<span class="md-code-number">0</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Once again, the discrepancy doesn&#x2019;t do any good to the language, but <code class="md-code md-code-inline">Number.isFinite</code> is consistently more useful than <code class="md-code md-code-inline">isFinite</code>. Creating a polyfill for the <code class="md-code md-code-inline">Number.isFinite</code> version is mostly a matter of type-checking.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.isFinite = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(value)</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-keyword">typeof</span> value === <span class="md-code-string">&apos;number&apos;</span> &amp;&amp; <span class="md-code-built_in">isFinite</span>(value)
}
</code></pre> <h2 id="numberparseint"><code class="md-code md-code-inline">Number.parseInt</code></h2> <p>This method works the same as <code class="md-code md-code-inline">parseInt</code>. In fact, it is the same.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Number</span>.parseInt === <span class="md-code-built_in">parseInt</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>The <code class="md-code md-code-inline">parseInt</code> method keeps producing inconsistencies, though &#x2013; even if it didn&#x2019;t even change, <strong>that&#x2019;s the problem</strong>. Before ES6, <code class="md-code md-code-inline">parseInt</code> had support for hexadecimal literal notation in strings. Specifying the <code class="md-code md-code-inline">radix</code> is not even necessary, <code class="md-code md-code-inline">parseInt</code> infers that based on the <code class="md-code md-code-inline">0x</code> prefix.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;0xf00&apos;</span>)
<span class="md-code-comment">// &lt;- 3840</span>
<span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;0xf00&apos;</span>, <mark class="md-mark md-code-mark">16</mark>)
<span class="md-code-comment">// &lt;- 3840</span>
</code></pre> <p>If you hardcoded another <code class="md-code md-code-inline">radix</code>, <em>&#x2013; and this is <strong>yet another reason</strong> for doing so &#x2013;</em> <code class="md-code md-code-inline">parseInt</code> would bail after the first non-digit character.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;0xf00&apos;</span>, <mark class="md-mark md-code-mark">10</mark>)
<span class="md-code-comment">// &lt;- 0</span>
<span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;5xf00&apos;</span>, <span class="md-code-number">10</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">5</mark>, illustrating there&apos;s no special treatment here</span>
</code></pre> <p>So far, it&#x2019;s all good. Why wouldn&#x2019;t I want <code class="md-code md-code-inline">parseInt</code> to drop <code class="md-code md-code-inline">0x</code> from hexadecimal strings? It sounds good, although you may argue that <strong>that&#x2019;s doing too much</strong>, and you&#x2019;d be <em>probably right</em>.</p> <p>The aggravating issue, however, is that <code class="md-code md-code-inline">parseInt</code> hasn&#x2019;t changed at all. Therefore, binary and octal literal notation in strings won&#x2019;t work.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;0b011&apos;</span>)
<span class="md-code-comment">// &lt;- 0</span>
<span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;0b011&apos;</span>, <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- 0</span>
<span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;0o800&apos;</span>)
<span class="md-code-comment">// &lt;- 0</span>
<span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;0o800&apos;</span>, <span class="md-code-number">8</span>)
<span class="md-code-comment">// &lt;- 0</span>
</code></pre> <p>It&#x2019;ll be up to you to get rid of the prefix before <code class="md-code md-code-inline">parseInt</code>. Remember to <em>hard-code</em> the <code class="md-code md-code-inline">radix</code>, though!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;0b011&apos;</span><mark class="md-mark md-code-mark">.slice(<span class="md-code-number">2</span>)</mark>, <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- 3</span>
<span class="md-code-built_in">parseInt</span>(<span class="md-code-string">&apos;0o110&apos;</span><mark class="md-mark md-code-mark">.slice(<span class="md-code-number">2</span>)</mark>, <span class="md-code-number">8</span>)
<span class="md-code-comment">// &lt;- 72</span>
</code></pre> <p>What&#x2019;s <em>even weirder</em> is that the <code class="md-code md-code-inline">Number</code> method is <strong>perfectly able to cast</strong> these strings into the correct numbers.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>(<span class="md-code-string">&apos;0b011&apos;</span>)
<span class="md-code-comment">// &lt;- 3</span>
<span class="md-code-built_in">Number</span>(<span class="md-code-string">&apos;0o110&apos;</span>)
<span class="md-code-comment">// &lt;- 72</span>
</code></pre> <p>I&#x2019;m not sure what drove them to keep <code class="md-code md-code-inline">Number.parseInt</code> identical to <code class="md-code md-code-inline">parseInt</code>. If it were up to me, I would&#x2019;ve made it different so that it worked just like <code class="md-code md-code-inline">Number</code> &#x2013; which <em>is</em> able to <strong>coerce octal and binary</strong> number literal strings into the appropriate <em>base ten</em> numbers.</p> <p>It might be that this was a more involved <em>&#x201C;fork&#x201D;</em> of <code class="md-code md-code-inline">parseInt</code> than just <em>&#x201C;not coercing <code class="md-code md-code-inline">input</code> into a numeric representation&#x201D;</em> as we observed in <code class="md-code md-code-inline">Number.isNaN</code> and <code class="md-code md-code-inline">Number.isFinite</code>, but I&#x2019;m just guessing here.</p> <h2 id="numberparsefloat"><code class="md-code md-code-inline">Number.parseFloat</code></h2> <p>Just like <code class="md-code md-code-inline">parseInt</code>, <code class="md-code md-code-inline">parseFloat</code> was just added to <code class="md-code md-code-inline">Number</code> without any modifications whatsoever.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.parseFloat === <span class="md-code-built_in">parseFloat</span>
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>In this case, however, <code class="md-code md-code-inline">parseFloat</code> already didn&#x2019;t have any special behavior with regard to hexadecimal literal strings, meaning that this is in fact the only method that won&#x2019;t introduce any confusion, other than it being ported over to <code class="md-code md-code-inline">Number</code> for <em>completeness&#x2019; sake</em>.</p> <h2 id="numberisinteger"><code class="md-code md-code-inline">Number.isInteger</code></h2> <p>This is a new method coming in ES6. It returns <code class="md-code md-code-inline">true</code> if the provided <code class="md-code md-code-inline">value</code> is <strong>a finite number</strong> that <em>doesn&#x2019;t have a decimal part</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Number</span>.isInteger(<span class="md-code-literal">Infinity</span>))
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Number</span>.isInteger(-<span class="md-code-literal">Infinity</span>))
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Number</span>.isInteger(<span class="md-code-literal">NaN</span>))
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Number</span>.isInteger(<span class="md-code-literal">null</span>))
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Number</span>.isInteger(<span class="md-code-number">0</span>))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Number</span>.isInteger(-<span class="md-code-number">10</span>))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Number</span>.isInteger(<span class="md-code-number">10.3</span>))
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>If you want to look at a a polyfill for <code class="md-code md-code-inline">isInteger</code>, you might want to consider the following code snippet. The modulus operator returns the remainder of dividing the same operands <em>&#x2013; effectively: the decimal part.</em> If that&#x2019;s <code class="md-code md-code-inline">0</code>, that means the number is an integer.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.isInteger = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(value)</span> </span>{
  <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">Number.isFinite(value)</mark> &amp;&amp; <mark class="md-mark md-code-mark">value % <span class="md-code-number">1</span></mark> === <span class="md-code-number">0</span>
}
</code></pre> <p>Floating point arithmetic is well-documented as being kind of ridiculous. What is this <code class="md-code md-code-inline">Number.EPSILON</code> thing?</p> <h2 id="numberepsilon"><code class="md-code md-code-inline">Number.EPSILON</code></h2> <p>Let me answer that question with a piece of code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.EPSILON
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">2.220446049250313e-16</mark>, wait what?</span>
<span class="md-code-built_in">Number</span>.EPSILON.toFixed(<span class="md-code-number">20</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">&apos;0.00000000000000022204&apos;</mark>, got it</span>
</code></pre> <p>Ok, so <code class="md-code md-code-inline">Number.EPSILON</code> is <strong>a terribly small number</strong>. What good is it for? Remember that thing about how floating point sum makes no sense? Here&#x2019;s the canonical example, I&#x2019;m sure you remember it &#x2013; <em>Yeah, I know.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-number">0.1</span> + <span class="md-code-number">0.2</span>
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">0.30000000000000004</mark></span>
<span class="md-code-number">0.1</span> + <span class="md-code-number">0.2</span> === <span class="md-code-number">0.3</span>
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
</code></pre> <p>Let&#x2019;s try that one more time.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-number">0.1</span> + <span class="md-code-number">0.2</span> - <span class="md-code-number">0.3</span>
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">5.551115123125783e-17</mark>, what the hell?</span>
<span class="md-code-number">5.551115123125783e-17</span>.toFixed(<span class="md-code-number">20</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">&apos;0.00000000000000005551&apos;</mark>, got it</span>
</code></pre> <p><em>So what?</em> You can use <code class="md-code md-code-inline">Number.EPSILON</code> to figure out whether the difference is small enough to fall under the <em>&#x201C;floating point arithmetic is ridiculous and the difference is negligible&#x201D;</em> category.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-number">5.551115123125783e-17</span> &lt; <span class="md-code-built_in">Number</span>.EPSILON
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
</code></pre> <p>Can we trust that? Well, <code class="md-code md-code-inline">0.00000000000000005551</code> is indeed smaller than <code class="md-code md-code-inline">0.00000000000000022204</code>. What do you mean you don&#x2019;t trust me? Here they are side by side.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-number">0.00000000000000005551</span>
<span class="md-code-number">0.00000000000000022204</span>
</code></pre> <p>See? <code class="md-code md-code-inline">Number.EPSILON</code> is <em>larger</em> than the difference. We can use <code class="md-code md-code-inline">Number.EPSILON</code> as an acceptable margin of error due to floating point arithmetic rounding operations.</p> <p>Thus, the following piece of code figures out whether the result of a floating point operation is within the expected margin of error. We use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs" target="_blank" aria-label="Math.abs() on MDN"><code class="md-code md-code-inline">Math.abs</code></a> because that way the order of <code class="md-code md-code-inline">left</code> and <code class="md-code md-code-inline">right</code> won&#x2019;t matter. In other words, <code class="md-code md-code-inline">withinErrorMargin(left, right)</code> will produce the same result as <code class="md-code md-code-inline">withinErrorMargin(right, left)</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">withinErrorMargin</span> <span class="md-code-params">(left, right)</span> </span>{
  <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">Math.abs(left - right)</mark> &lt; <span class="md-code-built_in">Number</span>.EPSILON
}
withinErrorMargin(<span class="md-code-number">0.1</span> + <span class="md-code-number">0.2</span>, <span class="md-code-number">0.3</span>)
<span class="md-code-comment">// &lt;- true</span>
withinErrorMargin(<span class="md-code-number">0.2</span> + <span class="md-code-number">0.2</span>, <span class="md-code-number">0.3</span>)
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <blockquote> <p>While, yes, you <strong>could</strong> do this, it&#x2019;s probably unnecessarily complicated unless you have to deal with very low-level mathematics. You&#x2019;ll be better of pulling a library like <a href="https://github.com/josdejong/mathjs" target="_blank" aria-label="josdejong/mathjs on GitHub"><code class="md-code md-code-inline">mathjs</code></a> into your project.</p> </blockquote> <p>Last but not least, there&#x2019;s the other weird aspect of number representation in JavaScript. <strong>Not every integer</strong> can be represented <em>precisely</em>, either.</p> <h2 id="numbermax-safe-integer"><code class="md-code md-code-inline">Number.MAX_SAFE_INTEGER</code></h2> <p>This is the largest integer that can be safely and precisely represented in JavaScript, or any language that represents integers using <em>floating point</em> as specified by <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" aria-label="IEEE Floating Point Standard on Wikipedia">IEEE-754</a> for that matter. The code below show just how large that number is. If we need to be able to deal with numbers larger than that, then I would once again point you to <a href="https://github.com/josdejong/mathjs" target="_blank" aria-label="josdejong/mathjs on GitHub"><code class="md-code md-code-inline">mathjs</code></a>, or maybe <strong>try another language</strong> for your computationally intensive services.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.MAX_SAFE_INTEGER === <span class="md-code-built_in">Math</span>.pow(<span class="md-code-number">2</span>, <span class="md-code-number">53</span>) - <span class="md-code-number">1</span>
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">Number</span>.MAX_SAFE_INTEGER === <span class="md-code-number">9007199254740991</span>
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>And you know what they say &#x2013; <em>If there&#x2019;s a maximum&#x2026;</em></p> <h2 id="numbermin-safe-integer"><code class="md-code md-code-inline">Number.MIN_SAFE_INTEGER</code></h2> <p>Right, nobody says that. However, there&#x2019;s a <code class="md-code md-code-inline">Number.MIN_SAFE_INTEGER</code> regardless, and it&#x2019;s the negative value of <code class="md-code md-code-inline">Number.MAX_SAFE_INTEGER</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="md-code-built_in">Number</span>.MAX_SAFE_INTEGER
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="md-code-number">9007199254740991</span>
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>How exactly can you leverage these two constants, I hear you say? In the case of the overflow problem, you don&#x2019;t have to implement your own <code class="md-code md-code-inline">withinErrorMargin</code> method like you had to do for floating point precision. Instead, a <code class="md-code md-code-inline">Number.isSafeInteger</code> is provided to you.</p> <h2 id="numberissafeinteger"><code class="md-code md-code-inline">Number.isSafeInteger</code></h2> <p>This method returns <code class="md-code md-code-inline">true</code> for any integer in the <code class="md-code md-code-inline">[MIN_SAFE_INTEGER, MAX_SAFE_INTEGER]</code> range. There&#x2019;s no type coercion here either. The input must be numeric, an integer, and within the aforementioned bounds in order for the method to return <code class="md-code md-code-inline">true</code>. Here&#x2019;s a quite comprehensive set of examples for you to stare at.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-string">&apos;a&apos;</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-literal">null</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-literal">NaN</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(-<span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-built_in">Number</span>.MIN_SAFE_INTEGER - <span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-built_in">Number</span>.MIN_SAFE_INTEGER)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">1.2</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-built_in">Number</span>.MAX_SAFE_INTEGER)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-built_in">Number</span>.MAX_SAFE_INTEGER + <span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
</code></pre> <p>As <a href="http://www.2ality.com/2015/04/numbers-math-es6.html" target="_blank" aria-label="New number and Math features in ES6 &#x2013; 2ality.com">Dr. Axel Rauschmayer points out</a> in his article about ES6 numbers, when we want to verify if the result of an operation is within bounds, we must verify not only the result but also both operands. The reason for that is one <em>(or both)</em> of the operands may be out of bounds, while the result is <em>&#x201C;safe&#x201D;</em> <strong>(but incorrect)</strong>. Similarly, the result may be out of bounds itself, so checking all of <code class="md-code md-code-inline">left</code>, <code class="md-code md-code-inline">right</code>, and the result of <code class="md-code md-code-inline">left op right</code> is necessary to verify that we can indeed trust the result.</p> <p>In all of the examples below, <strong>the result is incorrect</strong>. Here&#x2019;s the first example, where both operands are safe even though the result is not.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">9007199254740000</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">993</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">9007199254740000</span> + <span class="md-code-number">993</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-number">9007199254740000</span> + <span class="md-code-number">993</span>
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">9007199254740992</mark>, should be 9007199254740993</span>
</code></pre> <p>In this example one of the operands wasn&#x2019;t within range, so we can&#x2019;t trust the result to be accurate.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">9007199254740993</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">990</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">9007199254740993</span> + <span class="md-code-number">990</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-number">9007199254740993</span> + <span class="md-code-number">990</span>
<span class="md-code-comment">// &lt;-  <mark class="md-mark md-code-mark">9007199254741982</mark>, should be 9007199254741983</span>
</code></pre> <p>Note that in the example above, a subtraction would produce a result within bounds, and that result would <em>also</em> be inaccurate.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">9007199254740993</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">990</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">9007199254740993</span> - <span class="md-code-number">990</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-number">9007199254740993</span> - <span class="md-code-number">990</span>
<span class="md-code-comment">// &lt;-  <mark class="md-mark md-code-mark">9007199254740002</mark>, should be 9007199254740003</span>
</code></pre> <p>It doesn&#x2019;t take a genius to figure out the case where both operands are out of bounds but the result is <em>deemed &#x201C;safe&#x201D;</em>, even though the result is incorrect.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">9007199254740993</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">9007199254740995</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Number</span>.isSafeInteger(<span class="md-code-number">9007199254740993</span> - <span class="md-code-number">9007199254740995</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-number">9007199254740993</span> - <span class="md-code-number">9007199254740995</span>
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">-4</mark>, should be -2</span>
</code></pre> <p>Thus, as you can see, we can conclude that the only safe way to assert whether an operation is correct is with a method like the one below. If we can&#x2019;t ascertain that the operation and both its operands are within bounds, then the result may be inaccurate, and that&#x2019;s a problem. It&#x2019;s best to <code class="md-code md-code-inline">throw</code> in those situations and have a way to error-correct, but that&#x2019;s specific to your programs. The important part is to actually catch these kinds of difficult bugs to deal with.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">trusty</span> <span class="md-code-params">(left, right, result)</span> </span>{
  <span class="md-code-keyword">if</span> (
    <span class="md-code-built_in">Number</span>.isSafeInteger(left) &amp;&amp;
    <span class="md-code-built_in">Number</span>.isSafeInteger(right) &amp;&amp;
    <span class="md-code-built_in">Number</span>.isSafeInteger(result)
  ) {
    <span class="md-code-keyword">return</span> result
  }
  <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">RangeError</span>(<span class="md-code-string">&apos;Operation cannot be trusted!&apos;</span>)
}
</code></pre> <p>You could then use that every step of the way to ensure all operands remain safely within bounds. I&#x2019;ve highlighted the unsafe values in the examples below. Note that even though none of the operations in my examples return accurate results, certain operations and numbers <em>may do so</em> even when operands are out of bounds. The problem is that that <strong>can&#x2019;t be guaranteed</strong> <em>&#x2013; therefore the operation can&#x2019;t be trusted.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript">trusty(<span class="md-code-number">9007199254740000</span>, <span class="md-code-number">993</span>, <mark class="md-mark md-code-mark">9007199254740000 + <span class="md-code-number">993</span></mark>)
<span class="md-code-comment">// &lt;- RangeError: Operation cannot be trusted!</span>
trusty(<mark class="md-mark md-code-mark">9007199254740993</mark>, <span class="md-code-number">990</span>, <mark class="md-mark md-code-mark">9007199254740993 + <span class="md-code-number">990</span></mark>)
<span class="md-code-comment">// &lt;- RangeError: Operation cannot be trusted!</span>
trusty(<mark class="md-mark md-code-mark">9007199254740993</mark>, <span class="md-code-number">990</span>, <span class="md-code-number">9007199254740993</span> - <span class="md-code-number">990</span>)
<span class="md-code-comment">// &lt;- RangeError: Operation cannot be trusted!</span>
trusty(<mark class="md-mark md-code-mark">9007199254740993</mark>, <mark class="md-mark md-code-mark">9007199254740995</mark>, <span class="md-code-number">9007199254740993</span> - <span class="md-code-number">9007199254740995</span>)
<span class="md-code-comment">// &lt;- RangeError: Operation cannot be trusted!</span>
trusty(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- 3</span>
</code></pre> <p>I don&#x2019;t think I want to write about floating point again for a while. <em>Time to scrub myself up.</em></p> <h1 id="conclusions">Conclusions</h1> <p>While some of the hacks to guard against rounding errors and overflow safety are <em>nice to have</em>, they don&#x2019;t attack the heart of the problem: <em>math with the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" aria-label="IEEE Floating Point Standard on Wikipedia">IEEE-754</a> standard is hard.</em></p> <p>These days JavaScript runs on all the things, so it&#x2019;d be nice if a better standard were to be <em>implemented alongside <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" aria-label="IEEE Floating Point Standard on Wikipedia">IEEE-754</a></em>. Roughly a year ago, <em>Douglas Crockford</em> came up with <a href="http://dec64.com/" target="_blank" aria-label="DEC64 number type">DEC64</a>, but opinions on its merits range from <em>&#x201C;this is genius!&#x201D;</em> to <em>&#x201C;this is the work of a madman&#x201D;</em> &#x2013; I guess that&#x2019;s the norm when it comes to most of the stuff Crockford publishes, though.</p> <p>It&#x2019;d be nice, to eventually see the day where JavaScript is able to <em>precisely</em> compute decimal arithmetic as well as able to represent large integers safely. That day we&#x2019;ll probably have something <strong>alongside</strong> <em>floating point</em>.</p></div>
