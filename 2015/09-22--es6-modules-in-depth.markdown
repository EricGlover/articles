<h1>ES6 Modules in Depth</h1>

<div><kbd>es6</kbd> <kbd>modules</kbd> <kbd>commonjs</kbd> <kbd>es6-in-depth</kbd></div>

<blockquote><p>Welcome back to <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Oh, good. It&#x2019;s not another article about Unicode&#x201D;</em> &#x2013; in Depth</a> series. If you&#x2019;ve never been around here &#x2026;</p></blockquote>

<div><p>Welcome back to <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Oh, good. It&#x2019;s not another article about Unicode&#x201D;</em> &#x2013; in Depth</a> series. If you&#x2019;ve never been around here before, start with <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="https://ponyfoo.com/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>, <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a>, <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>, <a href="https://ponyfoo.com/articles/es6-symbols-in-depth">Symbols</a>, <a href="https://ponyfoo.com/articles/es6-maps-in-depth">Maps</a>, <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="https://ponyfoo.com/articles/es6-proxies-in-depth">proxies</a>, <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth">proxy traps</a>, <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="https://ponyfoo.com/articles/es6-reflection-in-depth">reflection</a>, <a href="https://ponyfoo.com/articles/es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>, <a href="https://ponyfoo.com/articles/es6-math-additions-in-depth"><code class="md-code md-code-inline">Math</code></a>, <a href="https://ponyfoo.com/articles/es6-array-extensions-in-depth"><code class="md-code md-code-inline">Array</code></a>, <a href="https://ponyfoo.com/articles/es6-object-changes-in-depth"><code class="md-code md-code-inline">Object</code></a>, and <a href="https://ponyfoo.com/articles/es6-strings-and-unicode-in-depth"><code class="md-code md-code-inline">String</code></a>. This morning is about the module system in ES6.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for reading that, and let&#x2019;s dive deep into the ES6 module system.</p></div>

<div><h1 id="the-es6-module-system">The ES6 Module System</h1> <p>Before ES6 we really went out of our ways to obtain modules in JavaScript. Systems like RequireJS, Angular&#x2019;s dependency injection mechanism, and CommonJS have been catering to our modular needs for a long time now <em>&#x2013; alongside with helpful tools such as Browserify and Webpack</em>. Still, the year is 2015 and a standard module system was long overdue. As we&#x2019;ll see in a minute, you&#x2019;ll quickly notice that ES6 modules have been heavily influenced by CommonJS. We&#x2019;ll look at <a href="https://ponyfoo.com/#export"><code class="md-code md-code-inline">export</code></a> and <a href="https://ponyfoo.com/#import"><code class="md-code md-code-inline">import</code></a> statements, and see how ES6 modules are compatible with CommonJS, as we&#x2019;ll go over throughout this article.</p> <p>Today we are going to cover a few areas of the ES6 module system.</p> <ul> <li><a href="https://ponyfoo.com/#strict-mode">Strict Mode</a></li> <li><a href="https://ponyfoo.com/#export"><code class="md-code md-code-inline">export</code></a> <ul> <li><a href="https://ponyfoo.com/#exporting-a-default-binding">Exporting a Default Binding</a></li> <li><a href="https://ponyfoo.com/#named-exports">Named Exports</a></li> <li><a href="https://ponyfoo.com/#bindings-not-values">Bindings, Not Values</a></li> <li><a href="https://ponyfoo.com/#exporting-lists">Exporting Lists</a></li> </ul> </li> <li><a href="https://ponyfoo.com/#best-practices-and-export">Best Practices and <code class="md-code md-code-inline">export</code></a></li> <li><a href="https://ponyfoo.com/#import"><code class="md-code md-code-inline">import</code></a> <ul> <li><a href="https://ponyfoo.com/#importing-default-exports">Importing Default Exports</a></li> <li><a href="https://ponyfoo.com/#importing-named-exports">Importing Named Exports</a></li> <li><a href="https://ponyfoo.com/#import-all-the-things"><code class="md-code md-code-inline">import</code> All The Things</a></li> </ul> </li> </ul> <h1 id="strict-mode">Strict Mode</h1> <p>In the ES6 module system, strict mode is turned on by default. In case you don&#x2019;t know what strict mode is, it&#x2019;s just a stricter version of the language that disallows lots of bad parts of the language. It enables compilers to perform better by disallowing non-sensical behavior in user code, too. The following is a summary extracted from changes documented in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" aria-label="Strict Mode on MDN">strict mode article</a> on MDN.</p> <ul> <li>Variables can&#x2019;t be left undeclared</li> <li>Function parameters must have unique names <em>(or are considered syntax errors)</em></li> <li><code class="md-code md-code-inline">with</code> is forbidden</li> <li>Errors are thrown on assignment to <em>read-only</em> properties</li> <li>Octal numbers like <code class="md-code md-code-inline">00840</code> are syntax errors</li> <li>Attempts to <code class="md-code md-code-inline">delete</code> undeletable properties <code class="md-code md-code-inline">throw</code> an error</li> <li><code class="md-code md-code-inline">delete prop</code> is a syntax error, instead of assuming <code class="md-code md-code-inline">delete global[prop]</code></li> <li><code class="md-code md-code-inline">eval</code> doesn&#x2019;t introduce <em>new</em> variables into its surrounding scope</li> <li><code class="md-code md-code-inline">eval</code> and <code class="md-code md-code-inline">arguments</code> can&#x2019;t be bound or assigned to</li> <li><code class="md-code md-code-inline">arguments</code> doesn&#x2019;t magically track changes to method parameters</li> <li><code class="md-code md-code-inline">arguments.callee</code> throws a <code class="md-code md-code-inline">TypeError</code>, no longer supported</li> <li><code class="md-code md-code-inline">arguments.caller</code> throws a <code class="md-code md-code-inline">TypeError</code>, no longer supported</li> <li>Context passed as <code class="md-code md-code-inline">this</code> in method invocations is not <em>&#x201C;boxed&#x201D; (forced)</em> into becoming an <code class="md-code md-code-inline">Object</code></li> <li>No longer able to use <code class="md-code md-code-inline">fn.caller</code> and <code class="md-code md-code-inline">fn.arguments</code> to access the JavaScript stack</li> <li>Reserved words <em>(e.g <code class="md-code md-code-inline">protected</code>, <code class="md-code md-code-inline">static</code>, <code class="md-code md-code-inline">interface</code>, etc)</em> cannot be bound</li> </ul> <p>In case it isn&#x2019;t immediately obvious &#x2013; you should <code class="md-code md-code-inline">&apos;use strict&apos;</code> in all the places. Even though it&#x2019;s becoming de-facto in ES6, it&#x2019;s still a good practice to use <code class="md-code md-code-inline">&apos;use strict&apos;</code> everywhere in ES6. I&#x2019;ve been doing it for a long time and never looked back!</p> <p>Let&#x2019;s now get into <code class="md-code md-code-inline">export</code>, our first ES6 modules keyword of the day!</p> <h1 id="export"><code class="md-code md-code-inline">export</code></h1> <p>In CommonJS, you export values by exposing them on <code class="md-code md-code-inline">module.exports</code>. As seen in the snippet below, you could expose anything from a value type to an object, an array, or a function.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark">module.exports =</mark> <span class="md-code-number">1</span>
<span class="md-code-built_in">module</span>.exports = <span class="md-code-literal">NaN</span>
<span class="md-code-built_in">module</span>.exports = <span class="md-code-string">&apos;foo&apos;</span>
<span class="md-code-built_in">module</span>.exports = { foo: <span class="md-code-string">&apos;bar&apos;</span> }
<span class="md-code-built_in">module</span>.exports = [<span class="md-code-string">&apos;foo&apos;</span>, <span class="md-code-string">&apos;bar&apos;</span>]
<span class="md-code-built_in">module</span>.exports = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">foo</span> <span class="md-code-params">()</span> </span>{}
</code></pre> <p>ES6 modules are files that <code class="md-code md-code-inline">export</code> an API &#x2013; just like CommonJS modules. Declarations in ES6 modules are scoped to that module, just like with CommonJS. That means that any variables declared inside a module aren&#x2019;t available to other modules unless they&#x2019;re <em>explicitly exported</em> as part of the module&#x2019;s API <em>(and then imported in the module that wants to access them)</em>.</p> <h2 id="exporting-a-default-binding">Exporting a Default Binding</h2> <p>You can mimic the CommonJS code we just saw by changing <code class="md-code md-code-inline">module.exports =</code> into <code class="md-code md-code-inline">export default</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark">export default</mark> <span class="md-code-number">1</span>
export <span class="md-code-keyword">default</span> <span class="md-code-literal">NaN</span>
export <span class="md-code-keyword">default</span> <span class="md-code-string">&apos;foo&apos;</span>
export <span class="md-code-keyword">default</span> { foo: <span class="md-code-string">&apos;bar&apos;</span> }
export <span class="md-code-keyword">default</span> [<span class="md-code-string">&apos;foo&apos;</span>, <span class="md-code-string">&apos;bar&apos;</span>]
export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">foo</span> <span class="md-code-params">()</span> </span>{}
</code></pre> <p>Contrary to CommonJS, <code class="md-code md-code-inline">export</code> statements can only be placed at the top level in ES6 modules &#x2013; even if the method they&#x2019;re in would be immediately invoked when loading the module. Presumably, this limitation exists to make it easier for compilers to interpret ES6 modules, but it&#x2019;s also a good limitation to have as there aren&#x2019;t that many good reasons to dynamically define and expose an API based on method calls.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">foo</span> <span class="md-code-params">()</span> </span>{
  export <span class="md-code-keyword">default</span> <span class="md-code-string">&apos;bar&apos;</span> <span class="md-code-comment">// SyntaxError</span>
}
foo()
</code></pre> <p>There isn&#x2019;t just <code class="md-code md-code-inline">export default</code>, you can also use <em>named exports</em>.</p> <h2 id="named-exports">Named Exports</h2> <p>In CommonJS you don&#x2019;t even have to assign an object to <code class="md-code md-code-inline">module.exports</code> first. You could just tack properties onto it. It&#x2019;s still a single binding being exported <em>&#x2013; whatever properties the <code class="md-code md-code-inline">module.exports</code> object ends up holding.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">module</span>.exports.foo = <span class="md-code-string">&apos;bar&apos;</span>
<span class="md-code-built_in">module</span>.exports.baz = <span class="md-code-string">&apos;ponyfoo&apos;</span>
</code></pre> <p>We can replicate the above in ES6 modules by using the named exports syntax. Instead of assigning to <code class="md-code md-code-inline">module.exports</code> like with CommonJS, in ES6 you can declare bindings you want to <code class="md-code md-code-inline">export</code>. Note that the code below cannot be refactored to extract the variable declarations into standalone statements and then just <code class="md-code md-code-inline">export foo</code>, as that&#x2019;d be a syntax error. Here again, we see how ES6 modules favor static analysis by being rigid in how the declarative module system API works.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export <span class="md-code-keyword">var</span> foo = <span class="md-code-string">&apos;bar&apos;</span>
export <span class="md-code-keyword">var</span> baz = <span class="md-code-string">&apos;ponyfoo&apos;</span>
</code></pre> <p>It&#x2019;s important to keep in mind that we are exporting <em>bindings</em>.</p> <h2 id="bindings-not-values">Bindings, Not Values</h2> <p>An important point to make is that ES6 modules export bindings, not values or references. That means that a <code class="md-code md-code-inline">foo</code> variable you export would be bound into the <code class="md-code md-code-inline">foo</code> variable on the module, and its value would be subject to changes made to <code class="md-code md-code-inline">foo</code>. I&#x2019;d advise against changing the public interface of a module after it has initially loaded, though.</p> <p>If you had an <code class="md-code md-code-inline">./a</code> module like the one found below, the <code class="md-code md-code-inline">foo</code> export would be bound to <code class="md-code md-code-inline">&apos;bar&apos;</code> for 500ms and then change into <code class="md-code md-code-inline">&apos;baz&apos;</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export <span class="md-code-keyword">var</span> foo = <span class="md-code-string">&apos;bar&apos;</span>
setTimeout(() =&gt; foo = <span class="md-code-string">&apos;baz&apos;</span>, <span class="md-code-number">500</span>)
</code></pre> <p>Besides a &#x201C;default&#x201D; binding and individual bindings, you could also export lists of bindings.</p> <h2 id="exporting-lists">Exporting Lists</h2> <p>As seen in the snippet below, ES6 modules let you <code class="md-code md-code-inline">export</code> <em>lists</em> of named top-level members.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = <span class="md-code-string">&apos;ponyfoo&apos;</span>
<span class="md-code-keyword">var</span> bar = <span class="md-code-string">&apos;baz&apos;</span>
export <mark class="md-mark md-code-mark">{ foo, bar }</mark>
</code></pre> <p>If you&#x2019;d like to export something with a different name, you can use the <code class="md-code md-code-inline">export { foo as bar }</code> syntax, as shown below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export { foo <mark class="md-mark md-code-mark">as ponyfoo</mark> }
</code></pre> <p>You could also specify <code class="md-code md-code-inline">as default</code> when using the named member list <code class="md-code md-code-inline">export</code> declaration flavor. The code below is the same as doing <code class="md-code md-code-inline">export default foo</code> and <code class="md-code md-code-inline">export bar</code> afterwards &#x2013; but in a single statement.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export { foo <mark class="md-mark md-code-mark">as default</mark>, bar }
</code></pre> <p>There&#x2019;s many benefits to using only <code class="md-code md-code-inline">export default</code>, and only at the bottom of your module files.</p> <h1 id="best-practices-and-export">Best Practices and <code class="md-code md-code-inline">export</code></h1> <p>Having the ability to define named exports, exporting a list with aliases and whatnot, and also exposing a a <em>&#x201C;default&#x201D;</em> <code class="md-code md-code-inline">export</code> will mostly introduce confusion, and <em>for the most part</em> I&#x2019;d encourage you to use <code class="md-code md-code-inline">export default</code> &#x2013; and to do that at the end of your module files. You could just call your API object <code class="md-code md-code-inline">api</code> or name it after the module itself.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> <mark class="md-mark md-code-mark">api</mark> = {
  foo: <span class="md-code-string">&apos;bar&apos;</span>,
  baz: <span class="md-code-string">&apos;ponyfoo&apos;</span>
}
export <span class="md-code-keyword">default</span> <mark class="md-mark md-code-mark">api</mark>
</code></pre> <p><mark class="md-mark">One</mark>, the exported interface of a module becomes immediately obvious. Instead of having to crawl around the module and put the pieces together to figure out the API, you just scroll to the end. Having a clearly defined place where your API is exported also makes it easier to reason about the methods and properties your modules export.</p> <p><mark class="md-mark">Two</mark>, you don&#x2019;t introduce confusion as to whether <code class="md-code md-code-inline">export default</code> or a named export &#x2013; or a list of named exports <em>(or a list of named exports with aliases&#x2026;)</em> &#x2013; should be used in any given module. There&#x2019;s a guideline now &#x2013; just use <code class="md-code md-code-inline">export default</code> everywhere and be done with it.</p> <p><mark class="md-mark">Three</mark>, consistency. In the CommonJS world <em>it is usual</em> for us to export a single method from a module, and that&#x2019;s it. Doing so with named exports is impossible as you&#x2019;d effectively be exposing an object with the method in it, unless you were using the <code class="md-code md-code-inline">as default</code> decorator in the <code class="md-code md-code-inline">export</code> list flavor. The <code class="md-code md-code-inline">export default</code> approach is more versatile because it allows you to <code class="md-code md-code-inline">export</code> just one thing.</p> <p><mark class="md-mark">Four</mark>, &#x2013; and this is really a reduction of points made earlier &#x2013; the <code class="md-code md-code-inline">export default</code> statement at the bottom of a module makes it immediately obvious what the exported API is, what its methods are, and generally easy for the module&#x2019;s consumer to <code class="md-code md-code-inline">import</code> its API. When paired with the convention of <em>always using <code class="md-code md-code-inline">export default</code> and always doing it at the end of your modules</em>, you&#x2019;ll note using the ES6 module system to be painless.</p> <p>Now that we&#x2019;ve covered the <code class="md-code md-code-inline">export</code> API and its caveats, let&#x2019;s jump over to <code class="md-code md-code-inline">import</code> statements.</p> <h1 id="import"><code class="md-code md-code-inline">import</code></h1> <p>These statements are the counterpart of <code class="md-code md-code-inline">export</code>, and they can be used to load a module from another one &#x2013; first and foremost. The way modules are loaded is <em>implementation-specific</em>, and at the moment no browsers implement module loading. This way you can write spec-compliant ES6 code today while smart people figure out how to deal with module loading in browsers. Transpilers like Babel are able to concatenate modules with the aid of a module system like CommonJS. That means <code class="md-code md-code-inline">import</code> statements in Babel follow <em>mostly</em> the same semantics as <code class="md-code md-code-inline">require</code> statements in CommonJS.</p> <p>Let&#x2019;s take <a href="http://lodash.com/docs" target="_blank" aria-label="Lodash is a JavaScript &apos;utility belt&apos; library"><code class="md-code md-code-inline">lodash</code></a> as an example for a minute. The following statement simply loads the Lodash module from our module. It doesn&#x2019;t create any variables, though. It <strong>will execute</strong> any code in the top level of the <code class="md-code md-code-inline">lodash</code> module, though.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark">import</mark> <span class="md-code-string">&apos;lodash&apos;</span>
</code></pre> <p>Before going into importing bindings, let&#x2019;s also make a note of the fact that <code class="md-code md-code-inline">import</code> statements, &#x2013; much like with <code class="md-code md-code-inline">export</code> &#x2013; are only allowed in the top level of your module definitions. This can help transpilers implement their module loading capabilities, as well as help other static analysis tools parse your codebase.</p> <h2 id="importing-default-exports">Importing Default Exports</h2> <p>In CommonJS you&#x2019;d <code class="md-code md-code-inline">import</code> something using a <code class="md-code md-code-inline">require</code> statement, like so.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> _ = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;lodash&apos;</span>)
</code></pre> <p>To import the default exported binding from an ES6 module, you just have to pick a name for it. The syntax is a bit different than declaring a variable because you&#x2019;re importing a <em>binding</em>, and also to make it easier on static analysis tools.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import <mark class="md-mark md-code-mark">_</mark> from <span class="md-code-string">&apos;lodash&apos;</span>
</code></pre> <p>You could also import named exports and alias them.</p> <h2 id="importing-named-exports">Importing Named Exports</h2> <p>The syntax here is very similar to the one we just used for default exports, you just add some braces and pick any named exports you want. Note that this syntax is similar to the <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo">destructuring assignment syntax</a>, but also bit different.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import <mark class="md-mark md-code-mark">{map, reduce}</mark> from <span class="md-code-string">&apos;lodash&apos;</span>
</code></pre> <p>Another way in which it differs from destructuring is that you could use aliases to rename imported bindings. You can mix and match aliased and non-aliased named exports as you see fit.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import {cloneDeep <mark class="md-mark md-code-mark">as clone</mark>, map} from <span class="md-code-string">&apos;lodash&apos;</span>
</code></pre> <p>You can also mix and match named exports and the default export. If you want it inside the brackets you&#x2019;ll have to use the <code class="md-code md-code-inline">default</code> name, which you can alias; or you could also just mix the default import side-by-side with the named imports list.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import {<mark class="md-mark md-code-mark">default</mark>, map} from <span class="md-code-string">&apos;lodash&apos;</span>
import {<span class="md-code-keyword">default</span> <mark class="md-mark md-code-mark">as _</mark>, map} from <span class="md-code-string">&apos;lodash&apos;</span>
import <mark class="md-mark md-code-mark">_</mark>, {map} from <span class="md-code-string">&apos;lodash&apos;</span>
</code></pre> <p>Lastly, there&#x2019;s the <code class="md-code md-code-inline">import *</code> flavor.</p> <h2 id="import-all-the-things"><code class="md-code md-code-inline">import</code> All The Things</h2> <p>You could also import the namespace object for a module. Instead of importing the named exports or the default value, it imports all the things. Note that the <code class="md-code md-code-inline">import *</code> syntax must be followed by an alias where all the bindings will be placed. If there was a default export, it&#x2019;ll be placed in <code class="md-code md-code-inline">alias.default</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import * as _ from <span class="md-code-string">&apos;lodash&apos;</span>
</code></pre> <p>That&#x2019;s about it!</p> <h1 id="conclusions">Conclusions</h1> <p>Note that you can use ES6 modules today through the Babel compiler while leveraging CommonJS modules. What&#x2019;s great about that is that you can actually interoperate between CommonJS and ES6 modules. That means that even if you <code class="md-code md-code-inline">import</code> a module that&#x2019;s written in CommonJS it&#x2019;ll actually work.</p> <p>The ES6 module system looks great, and it&#x2019;s one of the most important things that had been missing from JavaScript. I&#x2019;m hoping they come up with a finalized module loading API and browser implementations soon. The many ways you can <code class="md-code md-code-inline">export</code> or <code class="md-code md-code-inline">import</code> bindings from a module don&#x2019;t introduce as much versatility as they do added complexity for little gain, but time will tell whether all the extra API surface is as convenient as it is large.</p></div>
