<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/master/contributing.markdown"><code>contributing.markdown</code></a> for details.</sub>

<a href="https://ponyfoo.com/articles/es6-reflection-in-depth"><div></div></a>

<h1>ES6 Reflection in Depth</h1>

<p><kbd>es6</kbd> <kbd>reflect</kbd> <kbd>es6-in-depth</kbd></p>

<blockquote><p>Oh hey &#x2013; I was just casually getting ready, didn&#x2019;t see you there! Welcome to another edition of <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Oh. Good. We survived traps&#x201D;</em> &#x2026;</a></p></blockquote>

<div><p>Oh hey &#x2013; I was just casually getting ready, didn&#x2019;t see you there! Welcome to another edition of <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;Oh. Good. We survived traps&#x201D;</em> &#x2013; in Depth</a>. Never heard of it? Refer to <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="https://ponyfoo.com/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>, <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a>, <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>, <a href="https://ponyfoo.com/articles/es6-symbols-in-depth">Symbols</a>, <a href="https://ponyfoo.com/articles/es6-maps-in-depth">Maps</a>, <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="https://ponyfoo.com/articles/es6-proxies-in-depth">proxies</a>, <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth">proxy traps</a>, and <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth">more proxy traps</a>. We&#x2019;ll be touching on the <code class="md-code md-code-inline">Reflect</code> API today.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for reading that, and let&#x2019;s go into <code class="md-code md-code-inline">Reflect</code>. I suggest you read the articles on proxies: <a href="https://ponyfoo.com/articles/es6-proxies-in-depth"><code class="md-code md-code-inline">Proxy</code> built-in</a>, <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth">traps</a>, and <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth">more traps</a>. These will help you wrap your head around some of the content we&#x2019;ll go over today.</p></div>

<div><h1 id="why-reflection">Why Reflection?</h1> <p>Many statically typed languages have long offered a reflection API <em>(such as <a href="http://www.diveintopython.net/power_of_introspection/" target="_blank" aria-label="The Power of Introspection -- Dive Into Python">Python</a> or <a href="http://www.codeproject.com/Articles/17269/Reflection-in-C-Tutorial" target="_blank" aria-label="Reflection in C# Tutorial">C#</a>)</em>, whereas JavaScript hardly has a need for a reflection API &#x2013; it <em>already being</em> a dynamic language. The introduction of ES6 features a few <strong>new extensibility points</strong> where the developer gets access to <em>previously internal aspects</em> of the language &#x2013; yes, I&#x2019;m talking about <a href="https://ponyfoo.com/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo"><code class="md-code md-code-inline">Proxy</code></a>.</p> <p>You could argue that <strong>JavaScript already has reflection features in ES5</strong>, even though they weren&#x2019;t ever called that by either the specification or the community. Methods like <code class="md-code md-code-inline">Array.isArray</code>, <code class="md-code md-code-inline">Object.getOwnPropertyDescriptor</code>, and even <code class="md-code md-code-inline">Object.keys</code> are classical examples of what you&#x2019;d find <strong>categorized as reflection</strong> in other languages. The <code class="md-code md-code-inline">Reflect</code> built-in is, going forward, is going to house future methods in the category. That makes a lot of sense, right? Why would you have <strong>super reflection<em>y</em> static methods</strong> like <code class="md-code md-code-inline">getOwnPropertyDescriptor</code> <em>(or even <code class="md-code md-code-inline">create</code>)</em> in <code class="md-code md-code-inline">Object</code>? After all, <code class="md-code md-code-inline">Object</code> is meant to be a base prototype, and not so much a repository of reflection methods. Having a dedicated interface that exposes most reflection methods makes more sense.</p> <h1 id="reflect"><code class="md-code md-code-inline">Reflect</code></h1> <p>We&#x2019;ve mentioned the <code class="md-code md-code-inline">Reflect</code> object in passing the past few days. Much like <code class="md-code md-code-inline">Math</code>, <code class="md-code md-code-inline">Reflect</code> is a static object you can&#x2019;t <code class="md-code md-code-inline">new</code> up nor <em>call</em>, and all of its methods are static. The _traps in <a href="https://ponyfoo.com/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo">ES6 proxies</a> <em>(covered <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth" aria-label="ES6 Proxy Traps in Depth on Pony Foo">here</a> and <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth" aria-label="More ES6 Proxy Traps in Depth on Pony Foo">here</a>)</em> are <strong>mapped one-to-one</strong> to the <code class="md-code md-code-inline">Reflect</code> API. For every <em>trap</em>, there&#x2019;s a matching reflection method in <code class="md-code md-code-inline">Reflect</code>.</p> <p>The reflection API in JavaScript has <em>a number of benefits</em> that are worth examining.</p> <h2 id="return-values-in-reflect-vs-reflection-through-object">Return Values in <code class="md-code md-code-inline">Reflect</code> vs Reflection Through <code class="md-code md-code-inline">Object</code></h2> <p>The <code class="md-code md-code-inline">Reflect</code> equivalents to reflection methods on <code class="md-code md-code-inline">Object</code> also provide more <strong>meaningful</strong> <em>return values</em>. For instance, the <code class="md-code md-code-inline">Reflect.defineProperty</code> method returns a boolean value indicating whether the property was successfully defined. Meanwhile, its <code class="md-code md-code-inline">Object.defineProperty</code> counterpart returns the object it got as its first argument <em>&#x2013; not very <strong>useful</strong>.</em></p> <p>To illustrate, below is a code snippet showing how to verify <code class="md-code md-code-inline">Object.defineProperty</code> worked.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">try</span> {
  <span class="md-code-built_in">Object</span>.defineProperty(target, <span class="md-code-string">&apos;foo&apos;</span>, { value: <span class="md-code-string">&apos;bar&apos;</span> })
  <span class="md-code-comment">// yay!</span>
} <span class="md-code-keyword">catch</span> (e) {
  <span class="md-code-comment">// oops.</span>
}
</code></pre> <p>As opposed to a <em>much more natural</em> <code class="md-code md-code-inline">Reflect.defineProperty</code> experience.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> yay = Reflect.defineProperty(target, <span class="md-code-string">&apos;foo&apos;</span>, { value: <span class="md-code-string">&apos;bar&apos;</span> })
<span class="md-code-keyword">if</span> (yay) {
  <span class="md-code-comment">// yay!</span>
} <span class="md-code-keyword">else</span> {
  <span class="md-code-comment">// oops.</span>
}
</code></pre> <p>This way we avoided a <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> block and made our code a little more maintainable in the process.</p> <h2 id="keyword-operators-as-first-class-citizens">Keyword Operators as First Class Citizens</h2> <p>Some of these reflection methods provide programmatic alternatives of doing things that were previously only possible through keywords. For example, <code class="md-code md-code-inline">Reflect.deleteProperty(target, key)</code> is equivalent to the <code class="md-code md-code-inline">delete target[key]</code> expression. Before ES6, if you wanted a method call to result in a <code class="md-code md-code-inline">delete</code> call, you&#x2019;d have to create a dedicated utility method that wrapped <code class="md-code md-code-inline">delete</code> on your behalf.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = { foo: <span class="md-code-string">&apos;bar&apos;</span>, baz: <span class="md-code-string">&apos;wat&apos;</span> }
<span class="md-code-keyword">delete</span> target.foo
<span class="md-code-built_in">console</span>.log(target)
<span class="md-code-comment">// &lt;- { baz: &apos;wat&apos; }</span>
</code></pre> <p>Today, with ES6, you already have such a method in <code class="md-code md-code-inline">Reflect.deleteProperty</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = { foo: <span class="md-code-string">&apos;bar&apos;</span>, baz: <span class="md-code-string">&apos;wat&apos;</span> }
Reflect.deleteProperty(target, <span class="md-code-string">&apos;foo&apos;</span>)
<span class="md-code-built_in">console</span>.log(target)
<span class="md-code-comment">// &lt;- { baz: &apos;wat&apos; }</span>
</code></pre> <p>Just like <code class="md-code md-code-inline">deleteProperty</code>, there&#x2019;s a few other methods that make it easy to do other things too.</p> <h2 id="easier-to-mix-new-with-arbitrary-argument-lists">Easier to mix <code class="md-code md-code-inline">new</code> with Arbitrary Argument Lists</h2> <p>In ES5, this is a hard problem: How do you create a <code class="md-code md-code-inline">new Foo</code> passing an arbitrary number of arguments? You can&#x2019;t do it directly, and it&#x2019;s <a href="https://github.com/bevacqua/dominus/blob/master/src/apply.js#L4-L14" target="_blank" aria-label="Dominus on GitHub has an example where this was necessary">super verbose</a> if you need to do it anyways. You have to create an intermediary object that gets passed the arguments as an <code class="md-code md-code-inline">Array</code>. Then you have <em>that</em> object&#x2019;s constructor return the result of applying the constructor of the object you originally intended to <code class="md-code md-code-inline">.apply</code>. Straightforward, right? <em>&#x2013; What do you mean <strong>no</strong>?</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> proto = Dominus.prototype
<mark class="md-mark md-code-mark">Applied.prototype = proto</mark>
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Applied</span> <span class="md-code-params">(args)</span> </span>{
  <span class="md-code-keyword">return</span> Dominus<mark class="md-mark md-code-mark">.apply(<span class="md-code-keyword">this</span>, args)</mark>
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">apply</span> <span class="md-code-params">(a)</span> </span>{
  <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">new</mark> Applied(a)
}
</code></pre> <p>Using <code class="md-code md-code-inline">apply</code> is actually easy, thankfully.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">apply([<span class="md-code-string">&apos;.foo&apos;</span>, <span class="md-code-string">&apos;.bar&apos;</span>])
apply.call(<span class="md-code-literal">null</span>, <span class="md-code-string">&apos;.foo&apos;</span>, <span class="md-code-string">&apos;.bar&apos;</span>)
</code></pre> <p>But that was <em>insane</em>, right? <strong>Who does that?</strong> Well, in ES5, everyone who has a valid reason to do it! Luckily ES6 has less insane approaches to this problem. One of them is simply to use the <a href="http://www.diveintopython.net/power_of_introspection/" target="_blank" aria-label="The Power of Introspection -- Dive Into Python">spread operator</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">new</span> Dominus(<mark class="md-mark md-code-mark">...args</mark>)
</code></pre> <p>Another alternative is to go the <code class="md-code md-code-inline">Reflect</code> route.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark">Reflect.construct</mark>(Dominus, args)
</code></pre> <p>Both of these are tremendously simpler than what I had to do in the <a href="https://github.com/bevacqua/dominus/blob/master/src/apply.js#L4-L14" target="_blank" aria-label="Dominus on GitHub has an example where this was necessary"><code class="md-code md-code-inline">dominus</code></a> codebase.</p> <h2 id="function-application-the-right-way">Function Application, The Right Way</h2> <p>In ES5 if we want to call a method with an arbitrary number of arguments, we can use <code class="md-code md-code-inline">.apply</code> passing a <code class="md-code md-code-inline">this</code> context and our arguments.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fn.apply(ctx, [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>])
</code></pre> <p>If we fear <code class="md-code md-code-inline">fn</code> might shadow <code class="md-code md-code-inline">apply</code> with a property of their own, we can rely on a safer but way more verbose alternative.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Function</span>.prototype.apply.call(fn, ctx, [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>])
</code></pre> <p>In ES6, you can use <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread</a> as an alternative to <code class="md-code md-code-inline">.apply</code> for an arbitrary number of arguments.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">fn(<mark class="md-mark md-code-mark">...[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>]</mark>)
</code></pre> <p>That doesn&#x2019;t solve your problems when you need to define a <code class="md-code md-code-inline">this</code> context, though. You could go back to the <code class="md-code md-code-inline">Function.prototype</code> way but that&#x2019;s <em>way</em> too verbose. Here&#x2019;s how <code class="md-code md-code-inline">Reflect</code> can help.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">Reflect.apply(fn, ctx, args)
</code></pre> <p>Naturally, one of the most fitting use cases for <code class="md-code md-code-inline">Reflect</code> API methods is default behavior in <a href="https://ponyfoo.com/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo"><code class="md-code md-code-inline">Proxy</code></a> <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth" aria-label="ES6 Proxy Traps in Depth on Pony Foo">traps</a>.</p> <h2 id="default-behavior-in-proxy-traps">Default Behavior in <code class="md-code md-code-inline">Proxy</code> Traps</h2> <p>We&#x2019;ve already talked about how <em>traps</em> are mapped one-to-one to <code class="md-code md-code-inline">Reflect</code> methods. We haven&#x2019;t yet touched on the fact that their interfaces match as well. That is to say, <em>both their arguments and their return values match</em>. In code, this means you could do something like this to get the default <code class="md-code md-code-inline">get</code> <em>trap</em> behavior in your <a href="https://ponyfoo.com/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo">proxy handlers</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  get () {
    <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">Reflect.get(...arguments)</mark>
  }
}
<span class="md-code-keyword">var</span> target = { a: <span class="md-code-string">&apos;b&apos;</span> }
<span class="md-code-keyword">var</span> proxy = <span class="md-code-keyword">new</span> Proxy(target, handler)
<span class="md-code-built_in">console</span>.log(proxy.a)
<span class="md-code-comment">// &lt;- &apos;b&apos;</span>
</code></pre> <p>There is, in fact, nothing stopping you from making that <code class="md-code md-code-inline">handler</code> even simpler. Of course, at this point you&#x2019;d be better off leaving the <em>trap</em> out entirely.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> handler = {
  get: Reflect.get
}
</code></pre> <p>The important take-away here is that you could set up a trap in your proxy handlers, wire up some custom functionality that ends up throwing or logging a console statement, and then in the default case you could just use the one-liner recipe found below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">return</span> Reflect[trapName](...arguments)
</code></pre> <p>Certainly puts me at ease when it comes to demystifying <a href="https://ponyfoo.com/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo"><code class="md-code md-code-inline">Proxy</code></a>.</p> <h2 id="lastly-there-s-proto">Lastly, There&#x2019;s <code class="md-code md-code-inline">__proto__</code></h2> <p>Yesterday we talked about how the <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth" aria-label="More ES6 Proxy Traps in Depth on Pony Foo">legacy <code class="md-code md-code-inline">__proto__</code> is part of the ES6 specification</a> but still strongly advised against and how you should use <code class="md-code md-code-inline">Object.setPrototypeOf</code> and <code class="md-code md-code-inline">Object.getPrototypeOf</code> instead. Turns out, there&#x2019;s also <code class="md-code md-code-inline">Reflect</code> counterparts to those methods you could use. Think of these methods as <em>getter and setters</em> for <code class="md-code md-code-inline">__proto__</code> but without the cross-browser discrepancies.</p> <blockquote> <p>I wouldn&#x2019;t just hop onto the &quot;<code class="md-code md-code-inline">setPrototypeOf</code> all the things&quot; bandwagon just yet. In fact, I hope there never is a train pulling that wagon to begin with.</p> </blockquote></div>
