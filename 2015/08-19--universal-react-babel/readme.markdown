<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/master/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/universal-react-babel">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/universal-react-babel"><div></div></a>

<h1>Universal React with Babel, Browserify</h1>

<p><kbd>universal</kbd> <kbd>react</kbd> <kbd>babel</kbd> <kbd>es6</kbd> <kbd>browserify</kbd> <kbd>jsx</kbd></p>

<blockquote><p>I finally got around to trying out React, and this blog post will detail my initial impressions as well as a tutorial on how to make your React apps universal from the &#x2026;</p></blockquote>

<div><p>I finally got around to trying out React, and this blog post will detail my initial impressions as well as a tutorial on how to make your React apps universal from the get-go. As usual, I have a long-standing need to refactor <a href="http://bevacqua.io/" target="_blank">bevacqua.io</a>, as well as a long-standing desire to finally try out ES6 through <a href="https://babeljs.io/" target="_blank">Babel</a>, React, and JSX. I&#x2019;ve passively read a lot on the subject but hadn&#x2019;t actually dipped my toes on any of it, so I figured I&#x2019;d put my fingertips where my eyeballs were at &#x2013; hoping not to poke myself. I came across a bit of free time and decided this was the perfect moment to put Babel and ES6 in practice.</p></div>

<div></div>

<div><p>My website is static enough that it doesn&#x2019;t actually need any of this, but it&#x2019;s nevertheless a great excuse to get started with React and Babel. After all, this blog is the excuse that got me into Node.js, client-side MVC, <code class="md-code md-code-inline">browserify</code>, and so on. You get the idea &#x2013; learning through experimentation works really well for me, and I guess it&#x2019;s like that for most people.</p> <p>Here&#x2019;s what this article will cover.</p> <ul> <li>Using universal ES6 (server-side and client-side) through <a href="https://babeljs.io/" target="_blank">Babel</a> and Browserify</li> <li>Using <code class="md-code md-code-inline">npm run</code> for the whole build process</li> <li>Building an Express server-side application that serves our React app</li> <li>Building a simple server-rendered React app</li> <li>Booting that app on the client-side</li> </ul> <p>If all goes well, ES6 and React may become the driving topics on Pony Foo. Let&#x2019;s see where this article takes us, first.</p></div>

<div><h1 id="the-plan">The Plan</h1> <p>The first thing I did was installing some dependencies. I decided I would use <code class="md-code md-code-inline">browserify</code> because that way I can easily leverage any of the many CommonJS modules on <code class="md-code md-code-inline">npm</code>. I&#x2019;d use the <a href="https://github.com/babel/babelify" target="_blank" aria-label="babel/babelify on GitHub"><code class="md-code md-code-inline">babelify</code></a> transform to turn ES6 code into something the browser understands, and <a href="https://babeljs.io/docs/usage/cli/" target="_blank" aria-label="Babel CLI Documentation"><code class="md-code md-code-inline">babel-node</code></a> <em>(for now &#x2013; it&#x2019;s not meant for use in production)</em> to run that code on the server-side. I&#x2019;ll be using <code class="md-code md-code-inline">nodemon</code> and <code class="md-code md-code-inline">watchify</code> to speed up my development cycle, and the latest version of <strong>io.js</strong> <em>(<code class="md-code md-code-inline">3.0.0</code> at the time of this writing)</em>.</p> <h2 id="iojs-and-nvm">io.js and <code class="md-code md-code-inline">nvm</code></h2> <p>First off, if you don&#x2019;t use <strong>io.js</strong> or <code class="md-code md-code-inline">nvm</code>, it&#x2019;s time. Installing <code class="md-code md-code-inline">nvm</code> let&#x2019;s you easily switch around different versions of Node.js <em>(and io.js &#x2013; whatever)</em> without any friction. Installing <a href="https://github.com/creationix/nvm" target="_blank" aria-label="creationix/nvm on GitHub"><code class="md-code md-code-inline">nvm</code></a> is easy, and it makes installing different versions of <code class="md-code md-code-inline">node</code> just as easy. Here&#x2019;s how to install <code class="md-code md-code-inline">nvm</code>:</p> <pre class="md-code-block"><code class="md-code md-lang-bash">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.<span class="md-code-number">26.0</span>/install.sh | bash
</code></pre> <p>Once you have <code class="md-code md-code-inline">nvm</code>, you can easily install any version of <code class="md-code md-code-inline">io.js</code>. We&#x2019;ll install <code class="md-code md-code-inline">3.0.0</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">nvm install iojs-v3.<span class="md-code-number">0.0</span>
</code></pre> <p>When you want to switch to that version of the <code class="md-code md-code-inline">node</code> binary, just run the following.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">nvm use iojs-v3.<span class="md-code-number">0.0</span>
</code></pre> <h2 id="getting-started">Getting Started</h2> <p>Next up let&#x2019;s create a directory for our application and install some dependencies.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">mkdir my-app
<span class="md-code-built_in">cd</span> my-app
npm init
npm i react -S
npm i babel babelify browserify watchify nodemon -D
</code></pre> <h3 id="setting-up-babel">Setting up Babel</h3> <p>The next order of business is to set up Babel, so that we can leverage ES6 everywhere. When it comes to the server-side, we can use <a href="https://babeljs.io/docs/usage/cli/" target="_blank" aria-label="Babel CLI Documentation"><code class="md-code md-code-inline">babel-node</code></a> as a drop-in replacement for <code class="md-code md-code-inline">node</code>. There&#x2019;s a big warning sign against using this in production flows, but it works very well during development.</p> <p>First off, we&#x2019;ll need a <code class="md-code md-code-inline">scripts</code> entry for <code class="md-code md-code-inline">babel-node</code> in our <code class="md-code md-code-inline">package.json</code>. This is necessary because <code class="md-code md-code-inline">npm run</code> understands how to find the <code class="md-code md-code-inline">babel-node</code> executable, so now you can do <code class="md-code md-code-inline">npm run babel-node app.js</code> and run things using <code class="md-code md-code-inline">babel-node</code> without installing it globally and <a href="https://ponyfoo.com/articles/semver" aria-label="Pragmatic Semantic Versioning on Pony Foo">messing up versioning</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">scripts</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">babel-node</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;babel-node --stage 0&quot;</span>
  </span>}
</span>}
</code></pre> <p>When it comes to client-side ES6, we were already going to compile our code into a bundle via <code class="md-code md-code-inline">browserify</code>, so it makes a lot of sense to throw in the <code class="md-code md-code-inline">babelify</code> transform in there. Babelify leverages Babel to automatically transform our ES6 code into ES5 when bundling the code in our package. We can easily set <code class="md-code md-code-inline">babelify</code> up by adding the following entry to our <code class="md-code md-code-inline">package.json</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">browserify</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">transform</span>&quot;: <span class="md-code-value">[
      [<span class="md-code-string">&quot;babelify&quot;</span>, { &quot;<span class="md-code-attribute">stage</span>&quot;: <span class="md-code-value">[<span class="md-code-number">0</span>] </span>}]
    ]
  </span>}
</span>}
</code></pre> <p>You also definitely want a continuous development script. These save you precious time during development. Whenever your source code changes, the Browserify bundle will be rebuilt. Whenever the server-side code changes, the application should be restarted. For now, we can stick to just those two things. You&#x2019;ll need a small change to <code class="md-code md-code-inline">package.json</code> and a build script.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">scripts</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">start</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;build/build-development&quot;</span>
  </span>}
</span>}
</code></pre> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-shebang">#!/bin/bash
</span>
watchify client/main.js -o public/bundle.js -dv &amp;
nodemon --exec npm run babel-node -- app.js
</code></pre> <p><sub><em>Don&#x2019;t forget to run <code class="md-code md-code-inline">chmod +x build/build-development</code> so that you can execute that script!</em></sub></p> <p>The <code class="md-code md-code-inline">-dv</code> flags on <code class="md-code md-code-inline">watchify</code> mean debug mode <em>(source maps)</em> and verbose output <em>(a single line written to the terminal whenever the bundle gets recompiled)</em>. We pass <code class="md-code md-code-inline">--exec npm run babel-node</code> to <code class="md-code md-code-inline">nodemon</code> so that it runs our app through <code class="md-code md-code-inline">babel-node</code> instead of using the regular <code class="md-code md-code-inline">node</code> executable.</p> <h3 id="using-jsx-built-into-babel">Using JSX? Built-into Babel</h3> <p>Given that Babel now has built-in support for JSX, &#x2013; <em>not very modular of Babel, but we&#x2019;ll play along</em> &#x2013; I figured this is <em>a great opportunity</em> to try out JSX. In case you haven&#x2019;t ever tried React before, you&#x2019;ve probably heard the saying: <strong>&#x201C;Everyone hates JSX until they try it&#x201D;</strong>. Thus far I&#x2019;m on the &#x201C;what is this non-sense&#x201D; camp, but I&#x2019;ll probably end up accepting it.</p> <p>In case you have no idea what I&#x2019;m talking about, JSX is a templating engine from Facebook that allows you to embed XML into your JavaScript files, enabling seemingly awful lines of code such as <code class="md-code md-code-inline">React.renderToString(<mark class="md-mark md-code-mark">&lt;App /&gt;</mark>)</code>, as we&#x2019;ll explore in a minute.</p> <h2 id="onto-the-server-side">Onto the server-side</h2> <p>When it comes to the server-side, I&#x2019;ll stick to what I&#x2019;m comfortable with. I&#x2019;ll be using <code class="md-code md-code-inline">express</code>. We need something to render the layout surrounding our React application, and I chose <code class="md-code md-code-inline">express-handlebars</code> for that, but really any kind of templating language would do &#x2013; and to be fair, we probably could get away with just <a href="http://www.2ality.com/2015/01/template-strings-html.html" target="_blank" aria-label="HTML templating with ES6 template strings">using ES6 template strings</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">npm i express express-handlebars -S
</code></pre> <p>Let&#x2019;s put together our <code class="md-code md-code-inline">app.js</code> file using some light ES6 code. First off, some <code class="md-code md-code-inline">import</code> statements. These are equivalent to doing <code class="md-code md-code-inline">var express = require(&apos;express&apos;);</code> and so forth. We&#x2019;ll get to the <code class="md-code md-code-inline">App</code> later on. For now, all you need to know is that this will be the root entry point of our application. The server-side and the client-side will leverage <code class="md-code md-code-inline">App</code> slightly differently in order to render the application on both the server-side and the client-side.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import express from <span class="md-code-string">&apos;express&apos;</span>;
import hbs from <span class="md-code-string">&apos;express-handlebars&apos;</span>;
import React from <span class="md-code-string">&apos;react/addons&apos;</span>;
import App from <span class="md-code-string">&apos;./components/app&apos;</span>;
</code></pre> <p>Now that we have our dependencies in place, we can configure basic stuff about Express. This sets up <code class="md-code md-code-inline">express-handlebars</code> so that we can place our layout in <code class="md-code md-code-inline">views/layout.html</code>. I&#x2019;ve also turned off the <code class="md-code md-code-inline">x-powered-by</code> header because it makes no sense to advertise your technology stack like that.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> app = express();
app.engine(<span class="md-code-string">&apos;html&apos;</span>, hbs({ extname: <span class="md-code-string">&apos;html&apos;</span> }));
app.set(<span class="md-code-string">&apos;view engine&apos;</span>, <span class="md-code-string">&apos;html&apos;</span>);
app.locals.settings[<span class="md-code-string">&apos;x-powered-by&apos;</span>] = <span class="md-code-literal">false</span>;
</code></pre> <p>The view route is where things get a tad more interesting. This route will be hit once, whenever the page is first loaded. After that, the client-side rendering engine in React will take over. We&#x2019;ll get worried about routing and whatnot another day, for now our focus is on figuring out <mark class="md-mark">the correct way to render React apps</mark>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">app.get(<span class="md-code-string">&apos;/&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">home</span> <span class="md-code-params">(req, res, next)</span> </span>{
  res.render(<span class="md-code-string">&apos;layout&apos;</span>, {
    reactHtml: React.renderToString(<mark class="md-mark md-code-mark">&lt;App /&gt;</mark>)
  });
});
</code></pre> <p>The <code class="md-code md-code-inline">&lt;App /&gt;</code> expression is just JSX for <code class="md-code md-code-inline">React.createFactory(App)({})</code>. Good thing JSX is built into Babel! The <code class="md-code md-code-inline">app</code> should listen on a port, so that you can actually visit the site.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">app.listen(process.env.PORT || <span class="md-code-number">3000</span>);
</code></pre> <p>Oh, and the <code class="md-code md-code-inline">layout.html</code> we&#x2019;ve been discussing should be placed in <code class="md-code md-code-inline">views/layout.html</code>. For the moment, we&#x2019;ll get away with this measly piece of code. This will guarantee that if we can actually see some HTML, it&#x2019;ll be because it was server-side rendered. Here is <code class="md-code md-code-inline">layout.html</code> in all its glory.</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">main</span>&gt;</span>{{{reactHtml}}}<span class="md-code-tag">&lt;/<span class="md-code-title">main</span>&gt;</span>
</code></pre> <p>Now let&#x2019;s turn into what you came here for.</p> <h2 id="some-actual-react-code">Some Actual React Code</h2> <p>The <code class="md-code md-code-inline">App</code> component looks like the piece of code below. It was taken from <a href="https://github.com/substack/react-starter-es6-babel" target="_blank" aria-label="substack/react-starter-es6-babel on GitHub"><code class="md-code md-code-inline">react-starter-es6-babel</code></a> <em>(as the app itself is not important)</em> with some minor modifications, so that <strong>it works as a <em>universal</em> script</strong>. If you head over to their repository, you&#x2019;ll notice here I&#x2019;m exporting the component via <code class="md-code md-code-inline">export default</code>, instead of just calling <code class="md-code md-code-inline">React.render(&lt;App /&gt;, el)</code>.</p> <p>That simple change will allow us to render the component on both the server-side and the client-side alike. The <code class="md-code md-code-inline">App</code> component <code class="md-code md-code-inline">extends</code> the <code class="md-code md-code-inline">React.Component</code> <code class="md-code md-code-inline">class</code>. It has a <code class="md-code md-code-inline">state</code> property with an <code class="md-code md-code-inline">n</code> value &#x2013; that can be incremented using a button. It gets rendered through a <code class="md-code md-code-inline">render</code> method which returns the JSX that makes up the component. It also binds a click handler to another method on the component, which changes the state by calling <code class="md-code md-code-inline">setState</code> on the component.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>

<mark class="md-mark md-code-mark">export default</mark> <span class="md-code-keyword">class</span> App extends React.Component {
  constructor () {
    super()
    <span class="md-code-keyword">this</span>.state = { n: <span class="md-code-number">0</span> }
  }
  render () {
    <span class="md-code-keyword">return</span> <span><span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">h1</span>&gt;</span>clicked {this.state.n} times<span class="md-code-tag">&lt;/<span class="md-code-title">h1</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">button</span> <span class="md-code-attribute">onClick</span>=<span class="md-code-value">{this.handleClick.bind(this)}</span>&gt;</span>click me!<span class="md-code-tag">&lt;/<span class="md-code-title">button</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  }
  handleClick () {
    this.setState({ n: this.state.n + 1 })
  }
}
</span></code></pre> <h2 id="trying-it-out">Trying it out</h2> <p>If you run <code class="md-code md-code-inline">npm start</code>, it&#x2019;ll execute the <code class="md-code md-code-inline">app.js</code> script via <code class="md-code md-code-inline">babel-node</code>, and if you visit the application at <code class="md-code md-code-inline">http://localhost:3000</code>, you should see something like the screenshot below.</p> <p><img alt="The application running on Google Chrome" class="" src="https://i.imgur.com/bKa0V5A.png"></p> <p>You might also notice that the button doesn&#x2019;t do anything, even though our component has a click handler and everything. If we retrace our steps, you&#x2019;ll remember that our layout <em>only</em> consists of the rendered React HTML inside a <code class="md-code md-code-inline">&lt;main&gt;</code> tag &#x2013; not very dynamic.</p> <h2 id="onto-the-client-side">Onto the client-side</h2> <p>We&#x2019;ve already set up our build to <code class="md-code md-code-inline">browserify</code> a bundle earlier. Let&#x2019;s put that bundle together at <code class="md-code md-code-inline">client/main.js</code>. When you run <code class="md-code md-code-inline">npm start</code> the next time, a bundle should be created at <code class="md-code md-code-inline">public/bundle.js</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react/addons&apos;</span>;
import App from <span class="md-code-string">&apos;../components/app&apos;</span>;
<span class="md-code-keyword">var</span> main = <span class="md-code-built_in">document</span>.getElementsByTagName(<span class="md-code-string">&apos;main&apos;</span>)[<span class="md-code-number">0</span>];

React.render(<span><span class="md-code-tag">&lt;<span class="md-code-title">App</span> /&gt;</span>, main);
</span></code></pre> <p>You&#x2019;ll need the <code class="md-code md-code-inline">serve-static</code> package in order to serve the bundle.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">npm i serve-static -S
</code></pre> <p>It should be mounted on the <code class="md-code md-code-inline">public</code> directory.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import serveStatic from <span class="md-code-string">&apos;serve-static&apos;</span>;

app.use(serveStatic(<span class="md-code-string">&apos;public&apos;</span>));
</code></pre> <p>Also, don&#x2019;t forget to add the <code class="md-code md-code-inline">&lt;script&gt;</code> tag to your <code class="md-code md-code-inline">layout.html</code>!</p> <pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">main</span>&gt;</span>{{{reactHtml}}}<span class="md-code-tag">&lt;/<span class="md-code-title">main</span>&gt;</span>
<span class="md-code-tag">&lt;<span class="md-code-title">script</span> <span class="md-code-attribute">src</span>=<span class="md-code-value">&apos;/bundle.js&apos;</span>&gt;</span><span></span><span class="md-code-tag">&lt;/<span class="md-code-title">script</span>&gt;</span>
</code></pre> <p>The bundle takes over what we had already rendered on the server-side, and sets up the click handler. You can now click on the button and things will happen!</p> <p><img alt="Clicking the button increases the counter" class="" src="https://i.imgur.com/BR10Hvh.png"></p> <p>Next up we&#x2019;ll figure out how routing is set up, and we&#x2019;ll adjust our code as necessary. Think this should turn into an extensive series? It&#x2019;s kind of fun to write about.</p></div>
