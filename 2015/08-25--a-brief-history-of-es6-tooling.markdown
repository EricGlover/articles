<h1>A Brief History of ES6 Tooling</h1>

<div><kbd>es6</kbd> <kbd>history-lesson</kbd> <kbd>traceur</kbd> <kbd>babel</kbd> <kbd>es6-in-depth</kbd></div>

<blockquote><p>I wrote a few articles about React and ES6 these last few days, and today I wanted to add a bit more of context as to why I seem to be super into ES6 all of sudden. &#x2026;</p></blockquote>

<div><p>I wrote a few articles about React and ES6 these last few days, and today I wanted to add a bit more of context as to why I seem to be super into ES6 all of sudden. I&#x2019;ve had an interest in ES6 for a long time, but we weren&#x2019;t always prepared to write code in ES6. In this post I wanted to briefly touch on the history of ES6 tooling and why I believe that today we&#x2019;re in a much better place to adopt ES6 than where we were half a year ago.</p></div>

<div></div>

<div><p>For the most part, we have Browserify, Babel, and the spec being finalized to thank for. But we didn&#x2019;t always have these tools and they weren&#x2019;t born as mature as they are today.</p> <p><a href="http://babeljs.io/" target="_blank"><img src="https://i.imgur.com/DlNQvKS.png" alt="Babel JavaScript Compiler"></a></p></div>

<div><p>Before <strong>JavaScript-to-JavaScript</strong> transpilers became a <em>(serious)</em> thing, there were modules that would add specific bits of ES6 functionality to your apps. There were things like <a href="https://github.com/TooTallNate/gnode" target="_blank" aria-label="TooTallNate/gnode on GitHub"><code class="md-code md-code-inline">gnode</code></a>, which allows you to use generators in <code class="md-code md-code-inline">node</code> by interpreting your code during runtime <em>(or turning on the Harmony flag for generators in <code class="md-code md-code-inline">node &gt;= 0.11.x</code>)</em></p> <blockquote> <p><em>Trivia question: how many different names has ES6 accrued over the years?</em></p> </blockquote> <p>Then we also started to see libraries that implemented ES6 module loading, such as <a href="https://github.com/ModuleLoader/es6-module-loader" target="_blank" aria-label="ModuleLoader/es6-module-loader on GitHub"><code class="md-code md-code-inline">es6-module-loader</code></a>. These libraries helped advance the spec by giving developers something to chew on as implementations started cropping up. Of course, you could always use CoffeeScript or TypeScript back then which had implemented language features equivalent to those in ES6.</p> <p>I didn&#x2019;t care for the syntax in CoffeeScript, nor the fact that it would&#x2019;ve effectively reduced my ability to <a href="http://bevacqua.io/opensource" target="_blank" aria-label="I contribute on many open-source modules">contribute to open-source</a>, so that one was out. TypeScript would&#x2019;ve been okay but they have many features on top of what&#x2019;s coming with ES6, and <em>where possible</em> I try to learn things that will be <strong>useful to me for a long time</strong>. That being said, both of these languages contributed to the shaping of ES6, so we have them to thank for that. There&#x2019;s also the fact that for a long time, they were as close as you could get to trying a language with anything resembling the features in ES6.</p> <p>Eventually, transpilers made an appearance. The first one was <a href="https://github.com/google/traceur-compiler" target="_blank" aria-label="google/traceur-compiler on GitHub">Traceur</a>, and it came out around a time where the spec wasn&#x2019;t locked down yet. It was constantly changing so it wasn&#x2019;t a very good idea to try and use it for more than a few minutes to toy around with the syntax. I got frustrated very quickly while writing <a href="https://github.com/buildfirst/buildfirst/tree/master/ch05/17_harmony-traceur" target="_blank" aria-label="&apos;Harmony through Traceur, using Grunt&apos; code sample for JavaScript Application Design">example code</a> for my <a href="http://bevacquia.io/buildfirst" target="_blank" aria-label="JavaScript Application Design">application design book</a>. Around the same time, <a href="https://www.npmjs.com/package/6to5" target="_blank" aria-label="6to5 on npm">6to5</a> started making waves and there was also <a href="https://github.com/esnext/esnext" target="_blank" aria-label="esnext/esnext on GitHub"><code class="md-code md-code-inline">esnext</code></a>, but <code class="md-code md-code-inline">esnext</code> never implemented ES6 modules. Earlier this year <a href="http://babeljs.io/blog/2015/01/12/6to5-esnext/" target="_blank" aria-label="6to5 + esnext">those projects merged</a> into what we know as <a href="http://babeljs.io/" target="_blank" aria-label="Babel JavaScript Compiler">Babel</a> today.</p> <blockquote> <p><em>Come june, <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_blank" aria-label="ECMA-262 6th Edition was standarized on June 2015">the spec was finalized</a>.</em></p> </blockquote> <p><a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_blank" aria-label="ECMA-262 6th Edition was standarized on June 2015"><img alt="ECMAScript 2015 Spec" title="Screen Shot 2015-08-25 at 17.37.57.png" class="" src="https://i.imgur.com/SiBLQvN.png"></a></p> <p>Locking down the language features was crucial for adoption. It meant that compilers could now finally implement something and <em>not have stale syntax</em> within the next month. The spec being finalized and Babel becoming the de-facto <em>JavaScript-to-JavaScript</em> build tool got me interested in ES6 once again, so I started experimenting with them again.</p> <p>We now have the ability to mix Browserify and Babel using <code class="md-code md-code-inline">babelify</code>. We can use <code class="md-code md-code-inline">babel-node</code> on the server during development &#x2013; <em>and compile to ES5 for production because performance reasons</em>. We can use Webpack if we&#x2019;re into <a href="http://glenmaddern.com/articles/css-modules" target="_blank" aria-label="CSS Modules article by Glen Maddern">CSS Modules</a>, and there&#x2019;s a bunch of ES6 features ready for us to use. <em>We need to be careful not to overplay our hand, though.</em> With this much going on, it&#x2019;s going to be hard trying to keep up while maintaining a high quality codebase that doesn&#x2019;t get every single new feature and shiny toy crammed into it just because we can.</p> <blockquote> <p>There&#x2019;s plenty of room in front-end tooling for feature creep, unfortunately, but <strong>we need to battle against that</strong> now.</p> <p>Tomorrow I&#x2019;ll be publishing an article about the parts of the future of JavaScript I&#x2019;m most excited about and the concerns I have about mindlessly adopting ES6 features.</p> </blockquote></div>
