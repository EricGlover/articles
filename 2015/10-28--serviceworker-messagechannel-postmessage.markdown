<div><blockquote>
  <h1>ServiceWorker, MessageChannel, &amp; postMessage</h1>
  <div><p>Last week I wrote an article about <a href="https://ponyfoo.com/articles/progressive-networking-serviceworker" aria-label="ServiceWorker and Progressive Networking on Pony Foo">a caching strategy for progressive networking</a> that uses a cache first and then goes to the networking, sharing messages between web &#x2026;</p></div>
</blockquote></div>

<div><p>Last week I wrote an article about <a href="https://ponyfoo.com/articles/progressive-networking-serviceworker" aria-label="ServiceWorker and Progressive Networking on Pony Foo">a caching strategy for progressive networking</a> that uses a cache first and then goes to the networking, sharing messages between web pages and a <code class="md-code md-code-inline">ServiceWorker</code> to coordinate updates to cached content. Today I&#x2019;ll describe the inner workings of the <a href="https://github.com/bevacqua/swivel" target="_blank" aria-label="bevacqua/swivel on GitHub"><code class="md-code md-code-inline">swivel</code></a> library that&#x2019;s used to simplify message passing for ServiceWorkers.</p></div>

<div></div>

<div><p>As it turns out, there&#x2019;s many different ways in which you can share messages between a <code class="md-code md-code-inline">ServiceWorker</code> and the web pages it controls.</p> <ul> <li>A client may want to <a href="https://ponyfoo.com/#messaging-the-serviceworker">message a <code class="md-code md-code-inline">ServiceWorker</code></a>, asking something or notifying about something <em>&#x2013; this is &#x201C;unicast&#x201D; (1-to-1)</em></li> <li>A <code class="md-code md-code-inline">ServiceWorker</code> may want to send a <a href="https://ponyfoo.com/#getting-replies-from-the-serviceworker">reply to a client</a> <em>&#x2013; unicast</em></li> <li>A <code class="md-code md-code-inline">ServiceWorker</code> may want to send <a href="https://ponyfoo.com/#broadcasting-from-a-serviceworker-to-every-client">an update to every client</a> under its control <em>&#x2013; a &#x201C;broadcast&#x201D; (1-to-many) message</em></li> <li>A <code class="md-code md-code-inline">ServiceWorker</code> may want to send <a href="https://ponyfoo.com/#dual-channeling-fetch-requests">an update</a> to the client where a <code class="md-code md-code-inline">fetch</code> request originated <em>&#x2013; unicast</em></li> </ul></div>

<div><h1 id="messaging-the-serviceworker">Messaging the ServiceWorker</h1> <p>In order to message a <code class="md-code md-code-inline">ServiceWorker</code>, you can use a piece of code like the following snippet.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">worker.postMessage(data);
</code></pre> <p>By default you probably want to use <code class="md-code md-code-inline">navigator.serviceWorker.controller</code>, the active ServiceWorker instance for the current page that controls its requests, as the <code class="md-code md-code-inline">worker</code>. I haven&#x2019;t <em>personally</em> found a need yet for talking to workers other than the controller, <em>which is why that&#x2019;s the default <code class="md-code md-code-inline">worker</code> you talk to in <a href="https://github.com/bevacqua/swivel" target="_blank" aria-label="bevacqua/swivel on GitHub"><code class="md-code md-code-inline">swivel</code></a></em>. That being said, there are use cases for them, which is why there&#x2019;s <a href="https://github.com/bevacqua/swivel#swivelatworker" target="_blank" aria-label="swivel.at API documentation"><code class="md-code md-code-inline">swivel.at(worker)</code></a>, but let&#x2019;s go back to our focus area.</p> <p>The worker can set up an event handler that deals with the <code class="md-code md-code-inline">data</code> payload we posted from the web page.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">self.addEventListener(<span class="md-code-string">&apos;message&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">handler</span> <span class="md-code-params">(event)</span> </span>{
  <span class="md-code-built_in">console</span>.log(event.data);
});
</code></pre> <p>As soon as you have different types of messages you want to send to workers, this becomes an issue. You&#x2019;ll have to turn to a convention for message routing. A common convention is to define an envelope for your messages that has a <code class="md-code md-code-inline">command</code> property in it, so now you&#x2019;d send messages like the following.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">worker.postMessage({ <mark class="md-mark md-code-mark">command: <span class="md-code-string">&apos;deleteCache&apos;</span></mark>, key: key });
</code></pre> <p>Then the worker needs to be updated with a command handling router, a bunch of <code class="md-code md-code-inline">if</code> will do in the simpler case. You can see how the code starts becoming diluted with implementation details.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">self.addEventListener(<span class="md-code-string">&apos;message&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">handler</span> <span class="md-code-params">(event)</span> </span>{
  <span class="md-code-keyword">if</span> (<mark class="md-mark md-code-mark">event.data.command === <span class="md-code-string">&apos;deleteCache&apos;</span></mark>) {
    caches.delete(event.data.key);
  }
});
</code></pre> <h1 id="getting-replies-from-the-serviceworker">Getting Replies from the <code class="md-code md-code-inline">ServiceWorker</code></h1> <p>If you want the worker to be able to reply to the message <strong>things get very ugly, very quickly</strong>, mostly because browsers haven&#x2019;t implemented the final API quite yet.<br> For the time being, on the client-side you&#x2019;ll need to set up a <code class="md-code md-code-inline">MessageChannel</code>, bind a listener to <code class="md-code md-code-inline">port1</code> and pass along <code class="md-code md-code-inline">port2</code> when posting the message.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> messageChannel = <mark class="md-mark md-code-mark">new MessageChannel()</mark>;
messageChannel.<mark class="md-mark md-code-mark">port1</mark>.addEventListener(<span class="md-code-string">&apos;message&apos;</span>, replyHandler);
worker.postMessage(data, <mark class="md-mark md-code-mark">[messageChannel.port2]</mark>);
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">replyHandler</span> <span class="md-code-params">(event)</span> </span>{
  <span class="md-code-built_in">console</span>.log(event.data); <span class="md-code-comment">// <mark class="md-mark md-code-mark">this comes from the ServiceWorker</mark></span>
}
</code></pre> <p>On the <code class="md-code md-code-inline">ServiceWorker</code> side, it&#x2019;s not that fun either. You have to reference <code class="md-code md-code-inline">port2</code> of the <code class="md-code md-code-inline">messageChannel</code> using <code class="md-code md-code-inline">event.ports[0]</code>, as its the port in position zero of the <code class="md-code md-code-inline">ports</code> passed along with the message.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">self.addEventListener(<span class="md-code-string">&apos;message&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">handler</span> <span class="md-code-params">(event)</span> </span>{
  <mark class="md-mark md-code-mark">event.ports[<span class="md-code-number">0</span>].postMessage(data)</mark>; <span class="md-code-comment">// handle this using the <mark class="md-mark md-code-mark">replyHandler</mark> shown earlier</span>
});
</code></pre> <p>Browsers will eventually have an <code class="md-code md-code-inline">event.source</code> alternative to <code class="md-code md-code-inline">event.ports[0]</code> on the <code class="md-code md-code-inline">ServiceWorker</code> side that doesn&#x2019;t need us to do any of the <code class="md-code md-code-inline">MessageChannel</code> stuff on the pages. Unfortunately that&#x2019;s <em>not here yet</em>, and so we have to resort to <code class="md-code md-code-inline">MessageChannel</code> for now.</p> <h1 id="broadcasting-from-a-serviceworker-to-every-client">Broadcasting from a ServiceWorker to every client</h1> <p>This one is straightforward, but it&#x2019;s also pretty different from the two situations we&#x2019;ve just talked about. And, quite honestly, <em>very</em> verbose. Of course, <code class="md-code md-code-inline">ServiceWorker</code> is all about expressiveness and being able to cater for multiple different use cases, and we&#x2019;ve all seen the veiled evil in <a href="http://alistapart.com/article/application-cache-is-a-douchebag" target="_blank" aria-label="Application Cache is a Douchebag">seemingly simple but cleverly complicated</a> interfaces like the AppCache manifest.</p> <p>That being said, having to type this out sucks. Libraries will definitely help abstract the pain away, while <code class="md-code md-code-inline">ServiceWorker</code> can go on being just about <a href="https://ponyfoo.com/articles/serviceworker-revolution" aria-label="ServiceWorker: Revolution of the Web Platform on Pony Foo">the most powerful feature</a> the modern web has to offer.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">self.<mark class="md-mark md-code-mark">clients.matchAll()</mark>.then(all =&gt; all.map(client =&gt; <mark class="md-mark md-code-mark">client.postMessage</mark>(data)));
</code></pre> <p>To listen to these messages from a <code class="md-code md-code-inline">ServiceWorker</code>, you can register an event listener like below in your web page. Note how the listener is added on <code class="md-code md-code-inline">navigator.serviceWorker</code> and not on an specific <code class="md-code md-code-inline">worker</code> <em>(like <code class="md-code md-code-inline">navigator.serviceWorker.controller</code>)</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">navigator.serviceWorker.addEventListener(<span class="md-code-string">&apos;message&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">handler</span> <span class="md-code-params">(event)</span> </span>{
  <span class="md-code-built_in">console</span>.log(event.data);
});
</code></pre> <p>You probably want to keep a reference to the <code class="md-code md-code-inline">worker</code> you&#x2019;re interested in, and then filter on the message listener by <code class="md-code md-code-inline">event.source</code>. That way you&#x2019;ll avoid messages broadcasted from workers other than the one you&#x2019;re expecting messages from.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">navigator.serviceWorker.addEventListener(<span class="md-code-string">&apos;message&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">handler</span> <span class="md-code-params">(event)</span> </span>{
  <span class="md-code-keyword">if</span> (event.source !== <mark class="md-mark md-code-mark">worker</mark>) {
    <span class="md-code-keyword">return</span>;
  }
  <span class="md-code-built_in">console</span>.log(event.data);
});
</code></pre> <h1 id="dual-channeling-fetch-requests">Dual Channeling <code class="md-code md-code-inline">fetch</code> Requests</h1> <p>Sending updates to the origin of <code class="md-code md-code-inline">fetch</code> requests is, perhaps, the most interesting use case for communication between <code class="md-code md-code-inline">ServiceWorker</code> and web pages. Sending an update to the origin of a <code class="md-code md-code-inline">fetch</code> request is what makes using the cache immediately and then sending an update as soon as possible so effective.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">self.on(<span class="md-code-string">&apos;fetch&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">handler</span> <span class="md-code-params">(event)</span> </span>{
  <span class="md-code-comment">// reply to client here</span>
});
</code></pre> <p>Eventually, <code class="md-code md-code-inline">event</code> will have a <code class="md-code md-code-inline">clientId</code> property identifying the client where the request came from. We could then use code like below to send a message to the <code class="md-code md-code-inline">client</code> using <code class="md-code md-code-inline">client.postMessage</code>. No browser implements <code class="md-code md-code-inline">event.clientId</code> yet.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">self.on(<span class="md-code-string">&apos;fetch&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">handler</span> <span class="md-code-params">(event)</span> </span>{
  event.respondWith(caches.match(event.request));
  fetch(event.request).then(response =&gt; response.json()).then(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(data)</span> </span>{
    self.clients.match(<mark class="md-mark md-code-mark">event.clientId</mark>).then(client =&gt; client.postMessage(data));
  });
});
</code></pre> <p>You could still use the broadcasting mechanism discussed earlier, but it&#x2019;d go to every client and not just the origin of the <code class="md-code md-code-inline">fetch</code> event. A better alternative, for now, may be to issue another request from the page after load, maybe adding a custom header indicating that we should force a <code class="md-code md-code-inline">fetch</code> on the <code class="md-code md-code-inline">ServiceWorker</code> side.</p> <h1 id="swivel-makes-your-life-easier">Swivel Makes Your Life Easier</h1> <p>If you&#x2019;d prefer to avoid all of this frivolous knowledge, you may like to <a href="https://github.com/bevacqua/swivel" target="_blank" aria-label="bevacqua/swivel on GitHub"><code class="md-code md-code-inline">swivel</code></a> like Ron Swanson.</p> <p><img alt="Ron Swanson swivelling to avoid human contact" class="" src="https://i.imgur.com/Svqju4J.gif"></p> <p>Swivelling has a number of benefits. The API is unified under an event emitter style. On the client, you can send messages to the <code class="md-code md-code-inline">ServiceWorker</code> like below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark">swivel.emit</mark>(<span class="md-code-string">&apos;remove-cache&apos;</span>, <span class="md-code-string">&apos;v1&apos;</span>);
</code></pre> <p>Then on the worker, you could just listen for that with a matching API.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">swivel.on(<span class="md-code-string">&apos;remove-cache&apos;</span>, (context, key) =&gt; caches.delete(key));
</code></pre> <p>If the worker needs to reply, it can use <code class="md-code md-code-inline">context.reply</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">swivel.on(<span class="md-code-string">&apos;remove-cache&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">handler</span> <span class="md-code-params">(context, key)</span> </span>{
  caches.delete(key).then(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
      <mark class="md-mark md-code-mark">context.reply</mark>(<span class="md-code-string">&apos;removed-cache&apos;</span>, <span class="md-code-string">&apos;ok&apos;</span>, <span class="md-code-string">&apos;whatever&apos;</span>);
  });
});
</code></pre> <p>The client that sent the message then gets to handle the reply as long as they&#x2019;re listening for the <code class="md-code md-code-inline">removed-cache</code> event. Note how the API here is identical to the API for listening on events on the ServiceWorker.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">swivel.on(<span class="md-code-string">&apos;removed-cache&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">handler</span> <span class="md-code-params">(context, success, metadata)</span> </span>{
  <span class="md-code-comment">// do something else</span>
});
</code></pre> <p>When <code class="md-code md-code-inline">ServiceWorker</code> has important announcements, it can broadcast to every client.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark">swivel.broadcast</mark>(<span class="md-code-string">&apos;announcement&apos;</span>, { super: <span class="md-code-string">&apos;!important&apos;</span> });
</code></pre> <p>Broadcasted messages can be listened using the exact same <code class="md-code md-code-inline">swivel.on</code> API in the client-side. In addition to <code class="md-code md-code-inline">swivel.on</code>, there&#x2019;s also <code class="md-code md-code-inline">swivel.once</code> that binds one time event handlers, and <code class="md-code md-code-inline">swivel.off</code> to remove event handlers.</p> <p>Lastly, as we mentioned earlier you can interact with different ServiceWorker instances. Instead of using the <code class="md-code md-code-inline">swivel.*</code> API directly, you could use <code class="md-code md-code-inline">swivel.at(worker).*</code> instead. Messages sent from a client using <code class="md-code md-code-inline">swivel.at(worker).emit</code> will only go to <code class="md-code md-code-inline">worker</code>, and messages broadcasted by <code class="md-code md-code-inline">worker</code> will only be available to listeners registered using <code class="md-code md-code-inline">swivel.at(worker).on</code>. This kind of scoping helps prevent accidents when phasing out old workers and when installing new ones.</p> <p>You can check out the <a href="https://github.com/bevacqua/swivel" target="_blank" aria-label="bevacqua/swivel on GitHub">full documentation on GitHub</a>.</p> <blockquote> <p><code class="md-code md-code-inline">ServiceWorker</code>, <code class="md-code md-code-inline">MessageChannel</code>, &amp; <code class="md-code md-code-inline">postMessage</code>. Oh, my!</p> </blockquote></div>
