<h1>ES6 Object Changes in Depth</h1>

<div><kbd>es6</kbd> <kbd>object</kbd> <kbd>es6-in-depth</kbd></div>

<blockquote><p>Howdy. You&#x2019;re reading <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;I vehemently <code>Object</code> to come up with a better tagline&#x201D;</em> &#x2013; in Depth</a> series. If you&#x2019;ve never been &#x2026;</p></blockquote>

<div><p>Howdy. You&#x2019;re reading <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;I vehemently <code class="md-code md-code-inline">Object</code> to come up with a better tagline&#x201D;</em> &#x2013; in Depth</a> series. If you&#x2019;ve never been around here before, start with <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="https://ponyfoo.com/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>, <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a>, <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>, <a href="https://ponyfoo.com/articles/es6-symbols-in-depth">Symbols</a>, <a href="https://ponyfoo.com/articles/es6-maps-in-depth">Maps</a>, <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="https://ponyfoo.com/articles/es6-proxies-in-depth">proxies</a>, <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth">proxy traps</a>, <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="https://ponyfoo.com/articles/es6-reflection-in-depth">reflection</a>, <a href="https://ponyfoo.com/articles/es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>, <a href="https://ponyfoo.com/articles/es6-math-additions-in-depth"><code class="md-code md-code-inline">Math</code></a>, and <a href="https://ponyfoo.com/articles/es6-array-extensions-in-depth"><code class="md-code md-code-inline">Array</code></a>. Today we&#x2019;ll learn about changes to <code class="md-code md-code-inline">Object</code>.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for reading that, and let&#x2019;s go into changes to <code class="md-code md-code-inline">Object</code>. Make sure to read some of the articles from <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">earlier in the series</a> to get comfortable with ES6 syntax changes.</p></div>

<div><h1 id="upcoming-object-changes">Upcoming <code class="md-code md-code-inline">Object</code> Changes</h1> <p>Objects didn&#x2019;t get as many new methods in ES6 as <a href="https://ponyfoo.com/articles/es6-array-extensions-in-depth" aria-label="ES6 Array Extensions in Depth on Pony Foo">arrays did</a>. In the case of objects, we get four new static methods, and no new instance methods or properties.</p> <ul> <li><a href="https://ponyfoo.com/#objectassign"><code class="md-code md-code-inline">Object.assign</code></a></li> <li><a href="https://ponyfoo.com/#objectis"><code class="md-code md-code-inline">Object.is</code></a></li> <li><a href="https://ponyfoo.com/#objectgetownpropertysymbols"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a></li> <li><a href="https://ponyfoo.com/#objectsetprototypeof"><code class="md-code md-code-inline">Object.setPrototypeOf</code></a></li> </ul> <p>And just like arrays, objects are slated to get a few more static methods in ES2016 <em>(ES7)</em>. We&#x2019;re not going to cover these today.</p> <ul> <li><code class="md-code md-code-inline">Object.observe</code></li> <li><code class="md-code md-code-inline">Object.unobserve</code></li> </ul> <p><em>Shall we?</em></p> <h1 id="objectassign"><code class="md-code md-code-inline">Object.assign</code></h1> <p>This is another example of the kind of helper method that has been beaten to death by libraries like Underscore and Lodash. I even wrote my own implementation that&#x2019;s <a href="https://github.com/bevacqua/assignment/blob/master/assignment.js" target="_blank" aria-label="bevacqua/assignment on GitHub">around 20 lines of code</a>. You can use <code class="md-code md-code-inline">Object.assign</code> to recursively overwrite properties on an object with properties from other objects. The first argument passed to <code class="md-code md-code-inline">Object.assign</code>, <code class="md-code md-code-inline">target</code>, will be <em>used as the return value as well.</em> Subsequent values are <em>&#x201C;applied&#x201D;</em> onto that object.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Object</span>.assign(<mark class="md-mark md-code-mark">{}</mark>, { a: <span class="md-code-number">1</span> })
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">{ a: 1 }</mark></span>
</code></pre> <p>If you already had a property, it&#x2019;s overwritten.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Object</span>.assign(<mark class="md-mark md-code-mark">{ a: <span class="md-code-number">1</span> }</mark>, { a: <span class="md-code-number">2</span> })
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">{ a: 2 }</mark></span>
</code></pre> <p>Properties that aren&#x2019;t present in the object being assigned are left untouched.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Object</span>.assign(<mark class="md-mark md-code-mark">{ a: <span class="md-code-number">1</span>, b: <span class="md-code-number">2</span> }</mark>, { a: <span class="md-code-number">3</span> })
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">{ a: 3, b: 2 }</mark></span>
</code></pre> <p>You can assign as many objects as you want. You can think of <code class="md-code md-code-inline">Object.assign(a, b, c)</code> as the equivalent of doing <code class="md-code md-code-inline">Object.assign(Object.assign(a, b), c)</code>, if that makes it easier for you to reason about it. I like to reason about it as a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" aria-label="Array.prototype.reduce on MDN">reduce</a> operation.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Object</span>.assign(<mark class="md-mark md-code-mark">{ a: <span class="md-code-number">1</span>, b: <span class="md-code-number">2</span> }</mark>, { a: <span class="md-code-number">3</span> }, { c: <span class="md-code-number">4</span> })
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">{ a: 3, b: 2, c: 4 }</mark></span>
</code></pre> <p>Note that only enumerable own properties are copied over <em>&#x2013; think <code class="md-code md-code-inline">Object.keys</code> plus <code class="md-code md-code-inline">Object.getOwnPropertySymbols</code>.</em> The example below shows an <code class="md-code md-code-inline">invisible</code> property that didn&#x2019;t get copied over. Properties from the prototype chain aren&#x2019;t taken into account either.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> a = { b: <span class="md-code-string">&apos;c&apos;</span> }
<span class="md-code-built_in">Object</span>.defineProperty(a, <span class="md-code-string">&apos;invisible&apos;</span>, { <mark class="md-mark md-code-mark">enumerable: false</mark>, value: <span class="md-code-string">&apos;boo! ahhh!&apos;</span> })
<span class="md-code-built_in">Object</span>.assign(<mark class="md-mark md-code-mark">{}</mark>, a)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">{ b: &apos;c&apos; }</mark></span>
</code></pre> <p>You can use this API against arrays as well.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Object</span>.assign(<mark class="md-mark md-code-mark">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>]</mark>, [<span class="md-code-number">4</span>, <span class="md-code-number">5</span>])
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">[4, 5, 3]</mark></span>
</code></pre> <p>Properties using symbols as their keys are also copied over.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Object</span>.assign(<mark class="md-mark md-code-mark">{ a: <span class="md-code-string">&apos;b&apos;</span> }</mark>, { [Symbol(<span class="md-code-string">&apos;c&apos;</span>)]: <span class="md-code-string">&apos;d&apos;</span> })
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">{ a: &apos;b&apos;, Symbol(c): &apos;d&apos; }</mark></span>
</code></pre> <p>As long as they&#x2019;re enumerable and found directly on the object, that is.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> a = {}
<span class="md-code-built_in">Object</span>.defineProperty(a, <mark class="md-mark md-code-mark">Symbol(<span class="md-code-string">&apos;b&apos;</span>)</mark>, { <mark class="md-mark md-code-mark">enumerable: false</mark>, value: <span class="md-code-string">&apos;c&apos;</span> })
<span class="md-code-built_in">Object</span>.assign(<mark class="md-mark md-code-mark">{}</mark>, a)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">{}</mark></span>
</code></pre> <p>There&#x2019;s a problem with <code class="md-code md-code-inline">Object.assign</code>. It doesn&#x2019;t allow you to control how deep you want to go. You may be hoping for a way to do the following while preserving the <code class="md-code md-code-inline">target.a.d</code> property, but <code class="md-code md-code-inline">Object.assign</code> replaces <code class="md-code md-code-inline">target.a</code> entirely with <code class="md-code md-code-inline">source.a</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = { a: { b: <span class="md-code-string">&apos;c&apos;</span>, d: <span class="md-code-string">&apos;e&apos;</span> } }
<span class="md-code-keyword">var</span> source = { a: { b: <span class="md-code-string">&apos;ahh!&apos;</span> } }
<span class="md-code-built_in">Object</span>.assign(target, source)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">{ a: { b: &apos;ahh!&apos; } }</mark></span>
</code></pre> <p>Most implementations in the wild work differently, at least giving you <em>the option</em> to make a <em>&#x201C;deep assign&#x201D;</em>. Take <a href="https://github.com/bevacqua/assignment/blob/master/assignment.js#L3" target="_blank" aria-label="assignment on GitHub"><code class="md-code md-code-inline">assignment</code></a> for instance. If it finds an object reference in <code class="md-code md-code-inline">target</code> for a given property, it has two options.</p> <ul> <li>If the value in <code class="md-code md-code-inline">source[key]</code> is an object, it goes recursive with an <a href="https://github.com/bevacqua/assignment/blob/master/assignment.js#L13" target="_blank" aria-label="Recursive assignment on GitHub"><code class="md-code md-code-inline">assignment(target[key], source[key])</code></a> call</li> <li>If the value is not an object, it just replaces it: <code class="md-code md-code-inline">target[key] = source[key]</code></li> </ul> <p>This means that the last example we saw would work differently with <a href="https://github.com/bevacqua/assignment/blob/master/assignment.js#L3" target="_blank" aria-label="assignment on GitHub"><code class="md-code md-code-inline">assignment</code></a> than how it did with <code class="md-code md-code-inline">Object.assign</code>, which only allows for shallow extensions.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> target = { a: { b: <span class="md-code-string">&apos;c&apos;</span>, d: <span class="md-code-string">&apos;e&apos;</span> } }
<span class="md-code-keyword">var</span> source = { a: { b: <span class="md-code-string">&apos;ahh!&apos;</span> } }
assignment(target, source)
<span class="md-code-comment">// &lt;- { a: { b: &apos;ahh!&apos;, <mark class="md-mark md-code-mark">d: &apos;e&apos;</mark> } }</span>
</code></pre> <p>The <a href="https://github.com/bevacqua/assignment/blob/master/assignment.js#L3" target="_blank" aria-label="assignment on GitHub"><code class="md-code md-code-inline">assignment</code></a> approach is <strong>usually preferred</strong> when it comes to the most common use case of this type of method: providing sensible defaults that can be overwritten by the user. Consider the following example. It uses the well-known pattern of providing your <em>&#x201C;assign&#x201D;</em> method with an empty object, that&#x2019;s then filled with default values, and then poured user preferences for good measure. Note that it doesn&#x2019;t change the defaults object directly because those are supposed to stay the same across invocations.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">markdownEditor</span> <span class="md-code-params">(user)</span> </span>{
  <span class="md-code-keyword">var</span> defaults = {
    height: <span class="md-code-number">400</span>,
    markdown: {
      githubFlavored: <span class="md-code-literal">true</span>,
      tables: <span class="md-code-literal">false</span>
    }
  }
  <span class="md-code-keyword">var</span> options = <mark class="md-mark md-code-mark">Object.assign({}, defaults, user)</mark>
  <span class="md-code-built_in">console</span>.log(options)
}
</code></pre> <p>The problem with <code class="md-code md-code-inline">Object.assign</code> is that if the <code class="md-code md-code-inline">markdownEditor</code> consumer wants to change <code class="md-code md-code-inline">markdown.tables</code> to <code class="md-code md-code-inline">true</code>, all of the other defaults in <code class="md-code md-code-inline">markdown</code> will be lost!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">markdownEditor({ markdown: { tables: <span class="md-code-literal">true</span> } })
<span class="md-code-comment">// &lt;- {</span>
<span class="md-code-comment">//      height: 400,</span>
<span class="md-code-comment">//      markdown: {</span>
<span class="md-code-comment">//        tables: true</span>
<span class="md-code-comment">//      }</span>
<span class="md-code-comment">//    }</span>
</code></pre> <p>From both the library author&#x2019;s perspective and the library&#x2019;s user perspective, this is just unacceptable and weird. If we were to use <code class="md-code md-code-inline">assignment</code> we wouldn&#x2019;t be having those issues, because <code class="md-code md-code-inline">assignment</code> is built with this particular use case in mind. Libraries like Lodash usually provide <a href="https://lodash.com/docs#defaultsDeep" target="_blank" aria-label="See .assign, .defaults, and .defaultsDeep on their documentation">many different flavors</a> of this method.</p> <p>Note that when it comes to nested arrays, <strong>replacement</strong> <em>probably is</em> the behavior you want most of the time. Given defaults like <code class="md-code md-code-inline">{ extensions: [&apos;css&apos;, &apos;js&apos;, &apos;html&apos;] }</code>, the following would be quite weird.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">markdownEditor({ extensions: [<span class="md-code-string">&apos;js&apos;</span>] })
<span class="md-code-comment">// &lt;- { extensions: [&apos;js&apos;, <mark class="md-mark md-code-mark">&apos;js&apos;, &apos;html&apos;</mark>] }</span>
</code></pre> <p>For that reason, <a href="https://github.com/bevacqua/assignment/blob/master/assignment.js" target="_blank" aria-label="bevacqua/assignment on GitHub"><code class="md-code md-code-inline">assignment</code></a> replaces arrays entirely, just like <code class="md-code md-code-inline">Object.assign</code> would. This difference <strong>doesn&#x2019;t</strong> make <code class="md-code md-code-inline">Object.assign</code> useless, but it&#x2019;s still necessary to know about the difference between shallow and deep assignment.</p> <h1 id="objectis"><code class="md-code md-code-inline">Object.is</code></h1> <p>This method is pretty much a programmatic way to use the <code class="md-code md-code-inline">===</code> operator. You pass in two arguments and it tells you whether they&#x2019;re the same reference or the same primitive value.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">Object</span>.is(<span class="md-code-string">&apos;foo&apos;</span>, <span class="md-code-string">&apos;foo&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">Object</span>.is({}, {})
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>There are <strong>two important differences</strong>, however. First off, <code class="md-code md-code-inline">-0</code> and <code class="md-code md-code-inline">+0</code> are considered unequal by this method, even though <code class="md-code md-code-inline">===</code> returns <code class="md-code md-code-inline">true</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">-<span class="md-code-number">0</span> === +<span class="md-code-number">0</span>
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">Object</span>.is(-<span class="md-code-number">0</span>, +<span class="md-code-number">0</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
</code></pre> <p>The other difference is when it comes to <code class="md-code md-code-inline">NaN</code>. The <code class="md-code md-code-inline">Object.is</code> method treats <code class="md-code md-code-inline">NaN</code> as equal to <code class="md-code md-code-inline">NaN</code>. This is a behavior we&#x2019;ve <a href="https://ponyfoo.com/articles/es6-maps-in-depth" aria-label="ES6 Maps in Depth on Pony Foo">already observed in maps and sets</a>, which also treats <code class="md-code md-code-inline">NaN</code> as being the same value as <code class="md-code md-code-inline">NaN</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-literal">NaN</span> === <span class="md-code-literal">NaN</span>
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">Object</span>.is(<span class="md-code-literal">NaN</span>, <span class="md-code-literal">NaN</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
</code></pre> <p>While this may be convenient in some cases, I&#x2019;d probably go for the more explicit <a href="https://ponyfoo.com/articles/es6-number-improvements-in-depth#numberisnan" aria-label="ES6 Number Improvements in Depth on Pony Foo"><code class="md-code md-code-inline">Number.isNaN</code></a> most of the time.</p> <h1 id="objectgetownpropertysymbols"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></h1> <p>This method returns all own property symbols found on an object.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> a = {
  [Symbol(<span class="md-code-string">&apos;b&apos;</span>)]: <span class="md-code-string">&apos;c&apos;</span>,
  [Symbol(<span class="md-code-string">&apos;d&apos;</span>)]: <span class="md-code-string">&apos;e&apos;</span>,
  <span class="md-code-string">&apos;f&apos;</span>: <span class="md-code-string">&apos;g&apos;</span>,
  <span class="md-code-string">&apos;h&apos;</span>: <span class="md-code-string">&apos;i&apos;</span>
}
<span class="md-code-built_in">Object</span>.getOwnPropertySymbols(a)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">[Symbol(b), Symbol(d)]</mark></span>
</code></pre> <p>We&#x2019;ve already covered <code class="md-code md-code-inline">Object.getOwnPropertySymbols</code> in depth in the <a href="https://ponyfoo.com/articles/es6-symbols-in-depth" aria-label="ES6 Symbols in Depth on Pony Foo">symbols dossier</a>. If I were you, I&#x2019;d read it!</p> <h1 id="objectsetprototypeof"><code class="md-code md-code-inline">Object.setPrototypeOf</code></h1> <p>Again, something we&#x2019;ve covered earlier in the series. One of the articles about <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth#setprototypeof" aria-label=".setPrototypeOf is in the More ES6 Proxy Traps in Depth article on Pony Foo">proxy traps</a> covers this method tangentially. You can use <code class="md-code md-code-inline">Object.setPrototypeOf</code> to change the prototype of an object.</p> <p>It is, in fact, the equivalent of setting <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" aria-label="Object.prototype.__proto__ on MDN"><code class="md-code md-code-inline">__proto__</code></a> on runtimes that have that property.</p></div>
