<h1>Baking Modularity into Tag Editing</h1>

<blockquote><p>For quite some time I&#x2019;ve been wanting some sort of input that dealt with user-submitted tags in a reasonable way. I wanted this input to still be half-decent when &#x2026;</p></blockquote>

<div><kbd>modularity</kbd> <kbd>insignia</kbd> <kbd>rome</kbd></div>

<div><p>For quite some time I&#x2019;ve been wanting some sort of input that dealt with user-submitted tags in a reasonable way. I wanted this input to still be half-decent when JavaScript was out of the picture, so this meant starting with the basic building blocks of HTML.</p></div>

<div></div>

<div><p>Turns out, all libraries out there <em>(google for <a href="https://www.google.com/search?q=tag+input+javascript" target="_blank">&#x201C;tag input javascript&#x201D;</a> if you&#x2019;re curious)</em> that do this have at least one of these flaws.</p> <ul> <li>Feature bloat</li> <li>Human unfriendly</li> <li>Addiction to dependencies</li> </ul> <p>Instead of creating separate components for, <em>say</em>, tag input and autocompletion, most of these libraries try to do it all, and fail miserably at <strong>doing any one thing well</strong>. This is the <em>defining characteristic</em> of modular development, where we define a <em>(narrow)</em> purpose for what we&#x2019;re building and we set out to build the best possible solution to meet that purpose.</p> <blockquote> <p>Multi-purpose libraries end up doing a lot of things I do not need or want, while single-purpose components typically do exactly what you need.</p> </blockquote> <p>Being user friendly is why we build these libraries, and yet I couldn&#x2019;t find a single library that I would&#x2019;ve used over a simple <code class="md-code md-code-inline">&lt;input type=&apos;text&apos; /&gt;</code> and telling my humans to enter tags separated by a single space. The vast majority of these presented inconveniences such as being <strong>unable to walk around the input</strong> like we do in an input tag, insert tags in any position, or <strong>not even allowing humans to edit tags</strong> once they receive the <em>&#x201C;this is a tag&#x201D;</em> treatment.</p> <blockquote> <p>Human-facing interface elements <em>must</em> be sensitive to the needs of the human. Sometimes we have to wonder if a component is even worth the trouble. Wouldn&#x2019;t a simple <code class="md-code md-code-inline">&lt;input&gt;</code> be <strong>more amicable</strong> than an inflexible <em>&#x201C;tag input&#x201D;</em> solution? Is the component more useful to your humans?</p> </blockquote> <p>Finally, most of these libraries tie themselves to a dependency. If I really liked one of them, I probably would&#x2019;ve needed to commit to jQuery myself. Or Angular. Or React. It doesn&#x2019;t matter what their <em>&#x201C;big dependency&#x201D;</em> is, the point is that it <strong>constraints</strong> the consumer from being able to easily <strong>port the component to different projects</strong> with other assortments of frameworks or libraries.</p> <blockquote> <p>The fact that most of them count jQuery among their dependencies leaves much to be desired.</p> </blockquote> <p>This article will explore the approach I took to build <a href="https://github.com/bevacqua/insignia" target="_blank">Insignia</a> in just one day, as I think you may apply some of these concepts to any development you do on a daily basis.</p></div>

<div><h1 id="insignia">Insignia</h1> <p><a href="https://github.com/bevacqua/insignia" target="_blank" aria-label="bevacqua/insignia on GitHub">Insignia</a> has the purpose to <strong>make tag editing simple</strong>. If you want to suggest tags to your humans, based on the results of an API endpoint or events over a WebSocket, you are certainly welcome to do that, but Insignia won&#x2019;t take any part of it.</p> <p>If I needed something to suggest tags for humans using Insignia, I wouldn&#x2019;t create a plugin system. The DOM is the plugin system. <strong>I would create a separate component to do just that</strong>. It would also be a component that makes sense on its own, when paired with another input that deserves a suggestion mechanism. For instance, that theoretical component might work well enough to suggest dates on a field that&#x2019;s already using <a href="https://github.com/bevacqua/rome" target="_blank" aria-label="bevacqua/rome on GitHub">Rome</a> for date input. This way, the composable small components I create could serve me well for other projects, and hooking them to my framework of choice shouldn&#x2019;t take a lot of effort.</p> <p>The purpose then is to create a tag editor that&#x2019;s human friendly. Humans should be able to enter values into the field even when JavaScript hasn&#x2019;t finished loading. Once JavaScript loads, the tags that are already in the field should be extracted into a prettier visualization, but the human should still be <em>able to remove them, edit them, and walk through them</em> with the arrow keys.</p> <p>A minimal API would also go a long way towards being able to translate the altered visual representation into a collection of tags, something the implementation shouldn&#x2019;t have any problem putting together.</p> <p><a href="http://bevacqua.github.io/insignia/" target="_blank" aria-label="Try a demo of Insignia online"><img alt="screenshot.png" class="" src="https://i.imgur.com/d9M762N.png"></a></p> <p>Once I&#x2019;ve settled for a purpose and I roughly understand how the interface should look like, there&#x2019;s one more pause we need to take before starting to smash our fingers on the keyboard.</p> <blockquote> <p>What kind of browser support will we offer?</p> </blockquote> <p>This is an important question because there&#x2019;s nothing quite terrible as suddenly trying to support <strong>IE7+</strong> and finding out that even things like <code class="md-code md-code-inline">Element.setAttribute</code> or <code class="md-code md-code-inline">Array.prototype.indexOf</code> aren&#x2019;t even in the browser, let alone <code class="md-code md-code-inline">Element.selectionStart</code> and <code class="md-code md-code-inline">Element.selectionEnd</code>.</p> <p>If you face module development with a <em>&#x201C;take no API for granted&#x201D;</em> mentality, you&#x2019;ll be a significantly happier web developer than most people <em>&#x201C;dealing with IE8&#x201D;</em>. You won&#x2019;t just think of everything in terms of <em>&#x201C;Is there a polyfill for this?&#x201D;</em> but rather you&#x2019;ll be able to see further along and say <em>&#x201C;I&#x2019;ll just use a <code class="md-code md-code-inline">for</code> loop, then&#x201D;</em>.</p> <h1 id="initial-commit">Initial Commit</h1> <p>Think of the following as a recipe. Set up an <code class="md-code md-code-inline">index.html</code> page with usage examples before you have any working code. That&#x2019;s what you&#x2019;ll use as a playground for your component. It doesn&#x2019;t have to actually exist yet, but I find this works best when I also display code for how I want the API to look like.</p> <p>This kind of preemptive design allows you to predict issues with the API and work your way from basic HTML elements <em>(in my case, just an <code class="md-code md-code-inline">&lt;input type=&apos;text&apos; /&gt;</code>)</em>, towards the component you want. Effectively, this is the same progression that will be followed by user agents, allowing you to experience the same <em>&#x201C;rollout&#x201D;</em> your humans will.</p> <p>Once you&#x2019;ve put together the HTML page, start adding the JavaScript and styling. Feel free to code up the examples in plain JavaScript and CSS <em>(basically consuming the API and styling the page itself)</em>, but do use whatever module system and pre-processor you feel comfortable with for the library code. These always come with a simple CLI to compile the code into a JavaScript or CSS bundle.</p> <p>In my case, it just takes the command below to compile any number of CommonJS modules into a single bundle.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">browserify main.js -o bundle.js
</code></pre> <p>I usually use <code class="md-code md-code-inline">watchify</code> during development, which is equivalent to <code class="md-code md-code-inline">browserify</code>, except it incrementally rebuilds the bundle. For styles I use Stylus, which also comes with a CLI that can be used to watch for changes.</p> <p>Here&#x2019;s <a href="https://github.com/bevacqua/insignia/blob/master/package.json#L6-L12" target="_blank" aria-label="bevacqua/insignia/package.json on GitHub">the entire build and deployment process</a> for <code class="md-code md-code-inline">insignia</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&quot;scripts&quot;</span>: {
  <span class="md-code-string">&quot;start&quot;</span>: <span class="md-code-string">&quot;watchify -s insignia -do dist/insignia.js insignia.js &amp; stylus -w insignia.styl -o dist&quot;</span>,
  <span class="md-code-string">&quot;scripts&quot;</span>: <span class="md-code-string">&quot;jshint . &amp;&amp; browserify -s insignia -do dist/insignia.js insignia.js &amp;&amp; uglifyjs -m -c -o dist/insignia.min.js dist/insignia.js&quot;</span>,
  <span class="md-code-string">&quot;styles&quot;</span>: <span class="md-code-string">&quot;stylus insignia.styl -o dist &amp;&amp; cleancss dist/insignia.css -o dist/insignia.min.css&quot;</span>,
  <span class="md-code-string">&quot;build&quot;</span>: <span class="md-code-string">&quot;npm run scripts &amp;&amp; npm run styles&quot;</span>,
  <span class="md-code-string">&quot;deployment&quot;</span>: <span class="md-code-string">&quot;npm version ${BUMP:-\&quot;patch\&quot;} --no-git-tag-version &amp;&amp; git add package.json &amp;&amp; git commit -m \&quot;Autogenerated pre-deployment commit\&quot; &amp;&amp; bower version ${BUMP:-\&quot;patch\&quot;} &amp;&amp; git reset HEAD~2 &amp;&amp; git add . &amp;&amp; git commit -am \&quot;Release $(cat package.json | jq -r .version)\&quot; &amp;&amp; git push --tags &amp;&amp; npm publish &amp;&amp; git push&quot;</span>,
  <span class="md-code-string">&quot;sync&quot;</span>: <span class="md-code-string">&quot;git checkout gh-pages ; git merge master ; git push ; git checkout master&quot;</span>,
  <span class="md-code-string">&quot;deploy&quot;</span>: <span class="md-code-string">&quot;npm run build &amp;&amp; npm run deployment &amp;&amp; npm run sync&quot;</span>
}
</code></pre> <p>Throw in any assortment of <code class="md-code md-code-inline">.gitignore</code>, <code class="md-code md-code-inline">.editorconfig</code>, <code class="md-code md-code-inline">license</code>, <code class="md-code md-code-inline">changelog.markdown</code>, <code class="md-code md-code-inline">readme.markdown</code>, <code class="md-code md-code-inline">.jshintrc</code>, and <code class="md-code md-code-inline">.jshintignore</code> you feel comfortable with, and you&#x2019;re ready to get started developing your module.</p> <p>Make sure to <em>abstract potentially troublesome code into separate modules</em>, so that you can later brush off cross-browser inconsistencies. For instance, I created a <code class="md-code md-code-inline">&apos;./selection&apos;</code> module for getting and setting the selected text range, even when I was initially just working on Google Chrome <em>(which has perfectly functional <code class="md-code md-code-inline">Element.selectionStart</code> and <code class="md-code md-code-inline">Element.selectionEnd</code> property getters and setters)</em>.</p> <h1 id="conclusion">Conclusion</h1> <p>If you approach component design thoughtfully you should have very little issue making a functioning cross-browser component that doesn&#x2019;t alienate your humans, does what you need, and has a focused API surface that allows you to compose several modules into a complex, scalable application.</p></div>
