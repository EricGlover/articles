<div><blockquote>
  <h1>ES6 Iterators in Depth</h1>
  <div><p>This is yet another edition of <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a>. First time here? Welcome! So far we covered <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest &#x2026;</a></p></div>
</blockquote></div>

<div><p>This is yet another edition of <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a>. First time here? Welcome! So far we covered <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="https://ponyfoo.com/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, and an article on <a href="https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>. The soup of the day is: <strong>Iterators</strong>.</p></div>

<div></div>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for listening to that, and without further ado&#x2026; <em>shall we?</em></p></div>

<div><h2 id="iterator-protocol-and-iterable-protocol">Iterator Protocol and Iterable Protocol</h2> <blockquote> <p><em>There&#x2019;s a lot of new, intertwined terminology here. Please bear with me as I get some of these explanations out of the way!</em></p> </blockquote> <p>JavaScript gets two new protocols in ES6, <em>Iterators</em> and <em>Iterables</em>. In plain terms, you can think of protocols as <em>conventions</em>. As long as you follow a determined convention in the language, you get a side-effect. The <em>iterable</em> protocol allows you to define the behavior when JavaScript objects are being iterated. Under the hood, deep in the world of JavaScript interpreters and language specification <em>keyboard-smashers</em>, we have the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" aria-label="Iteration Protocols on MDN"><code class="md-code md-code-inline">@@iterator</code></a> method. This method underlies the <em>iterable</em> protocol and, in the real world, you can assign to it using something called &#x201C;the <em>&#x201C;well-known&#x201D;</em> <code class="md-code md-code-inline">Symbol.iterator</code> Symbol&#x201D;.</p> <p>We&#x2019;ll get back to <a href="https://ponyfoo.com/articles/es6-symbols-in-depth" aria-label="ES6 Symbols in Depth on Pony Foo">what Symbols are</a> <em>later in the series</em>. Before losing focus, you should know that the <code class="md-code md-code-inline">@@iterator</code> method is called <strong>once, whenever an object needs to be iterated</strong>. For example, at the beginning of a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of" target="_blank" aria-label="for..of is on MDN"><code class="md-code md-code-inline">for..of</code></a> loop <em>(which we&#x2019;ll also get back to in a few minutes)</em>, the <code class="md-code md-code-inline">@@iterator</code> will be asked for an <em>iterator</em>. The returned <em>iterator</em> will be used to obtain values out of the object.</p> <p>Let&#x2019;s use the snippet of code found below as a crutch to understand the concepts behind iteration. The first thing you&#x2019;ll notice is that I&#x2019;m making my object an iterable by assigning to it&#x2019;s mystical <code class="md-code md-code-inline">@@iterator</code> property through the <code class="md-code md-code-inline">Symbol.iterator</code> property. I can&#x2019;t use the symbol as a property name directly. Instead, I have to wrap in square brackets, meaning it&#x2019;s a computed property name that evaluates to the <code class="md-code md-code-inline">Symbol.iterator</code> <em>expression</em> &#x2013; as you might recall from the <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth" aria-label="ES6 Object Literal Features in Depth on Pony Foo">article on object literals</a>. The object returned by the method assigned to the <code class="md-code md-code-inline">[Symbol.iterator]</code> property must adhere to the <em>iterator</em> protocol. The <em>iterator</em> protocol defines how to get values out of an object, and we must return an <code class="md-code md-code-inline">@@iterator</code> that adheres to <em>iterator</em> protocol. The protocol indicates we must have an object with a <code class="md-code md-code-inline">next</code> method. The <code class="md-code md-code-inline">next</code> method takes no arguments and it should return an object with these two properties.</p> <ul> <li><code class="md-code md-code-inline">done</code> signals that the sequence has ended when <code class="md-code md-code-inline">true</code>, and <code class="md-code md-code-inline">false</code> means there may be more values</li> <li><code class="md-code md-code-inline">value</code> is the current item in the sequence</li> </ul> <p>In my example, the iterator method returns an object that has a finite list of items and which emits those items until there aren&#x2019;t any more left. The code below is an iterable object in ES6.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = {
  <mark class="md-mark md-code-mark">[Symbol.iterator]</mark>: () =&gt; ({
    items: [<span class="md-code-string">&apos;p&apos;</span>, <span class="md-code-string">&apos;o&apos;</span>, <span class="md-code-string">&apos;n&apos;</span>, <span class="md-code-string">&apos;y&apos;</span>, <span class="md-code-string">&apos;f&apos;</span>, <span class="md-code-string">&apos;o&apos;</span>, <span class="md-code-string">&apos;o&apos;</span>],
    <mark class="md-mark md-code-mark">next</mark>: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">next</span> <span class="md-code-params">()</span> </span>{
      <span class="md-code-keyword">return</span> {
        done: <span class="md-code-keyword">this</span>.items.length === <span class="md-code-number">0</span>,
        value: <span class="md-code-keyword">this</span>.items.shift()
      }
    }
  })
}
</code></pre> <p>To actually iterate over the object, we could use <code class="md-code md-code-inline">for..of</code>. How would that look like? See below. The <code class="md-code md-code-inline">for..of</code> iteration method is also new in ES6, and it settles the everlasting war against looping over JavaScript collections and randomly finding things that didn&#x2019;t belong in the result-set you were expecting.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<mark class="md-mark md-code-mark">let pony of foo</mark>) {
  <span class="md-code-built_in">console</span>.log(pony)
  <span class="md-code-comment">// &lt;- &apos;p&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;o&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;n&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;y&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;f&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;o&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;o&apos;</span>
}
</code></pre> <p>You can use <code class="md-code md-code-inline">for..of</code> to iterate over any object that adheres to the <em>iterable</em> protocol. In ES6, that includes arrays, any objects with an user-defined <code class="md-code md-code-inline">[Symbol.iterator]</code> method, <a href="https://ponyfoo.com/articles/es6-generators-in-depth" aria-label="ES6 Generators in Depth on Pony Foo"><em>generators</em></a>, DOM node collections from <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll" target="_blank" aria-label="Element.querySelectorAll() on MDN"><code class="md-code md-code-inline">.querySelectorAll</code></a> and friends, etc. If you just want to <em>&#x201C;cast&#x201D;</em> any iterable into an array, a couple of terse alternatives would be using the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread operator</a> and <code class="md-code md-code-inline">Array.from</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">[...foo]</mark>)
<span class="md-code-comment">// &lt;- [&apos;p&apos;, &apos;o&apos;, &apos;n&apos;, &apos;y&apos;, &apos;f&apos;, &apos;o&apos;, &apos;o&apos;]</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">Array.from(foo)</mark>)
<span class="md-code-comment">// &lt;- [&apos;p&apos;, &apos;o&apos;, &apos;n&apos;, &apos;y&apos;, &apos;f&apos;, &apos;o&apos;, &apos;o&apos;]</span>
</code></pre> <p>To recap, our <code class="md-code md-code-inline">foo</code> object adheres to the <em>iterable</em> protocol by assigning a method to <code class="md-code md-code-inline">[Symbol.iterator]</code> <em>&#x2013; anywhere in the prototype chain for <code class="md-code md-code-inline">foo</code> would work</em>. This means that the object is <em>iterable</em>: it can be iterated. Said method returns an object that adheres to the <em>iterator</em> protocol. The iterator method is called once whenever we want to start iterating over the object, and the returned <em>iterator</em> is used to pull values out of <code class="md-code md-code-inline">foo</code>. To iterate over iterables, we can use <code class="md-code md-code-inline">for..of</code>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread operator</a>, or <code class="md-code md-code-inline">Array.from</code>.</p> <h2 id="what-does-this-all-mean">What Does This All Mean?</h2> <p>In essence, the selling point about iteration protocols, <code class="md-code md-code-inline">for..of</code>, <code class="md-code md-code-inline">Array.from</code>, and the spread operator is that they provide expressive ways to effortlessly iterate over collections and array-likes <em>(such as <code class="md-code md-code-inline">arguments</code>)</em>. Having the ability to define how any object may be iterated is huge, because it enables any libraries like <a href="http://lodash.com/docs" target="_blank" aria-label="Lodash documentation">lo-dash</a> to converge under a protocol the language natively understands <em>&#x2013; iterables.</em> This is <strong>huge</strong>.</p> <blockquote class="twitter-tweet"><p>Lodash&apos;s chaining wrapper is now an iterator and iterable: var w = _({ a: 1, b: 2 }); Array.from(w); // =&gt; [1, 2]</p>&#x2014; John-David Dalton (@jdalton) <a href="https://twitter.com/jdalton/status/638238228869283841">August 31, 2015</a></blockquote> <p>Just to give you another example, remember how I always complain about jQuery wrapper objects not being <a href="http://ponyfoo.com/articles/how-to-avoid-objectprototype-pollution" target="_blank" aria-label="How To Avoid Object.prototype Pollution on Pony Foo">true arrays</a>, or how <code class="md-code md-code-inline">document.querySelectorAll</code> doesn&#x2019;t return a true array either? If jQuery implemented the iterator protocol on their collection&#x2019;s prototype, then you could do something like below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> item of $(<span class="md-code-string">&apos;li&apos;</span>)) {
  <span class="md-code-built_in">console</span>.log(item)
  <span class="md-code-comment">// &lt;- the &lt;li&gt; wrapped in a jQuery object</span>
}
</code></pre> <p>Why wrapped? Because it&#x2019;s more expressive. You could easily iterate as deep as you need to.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> list of $(<span class="md-code-string">&apos;ul&apos;</span>)) {
  <span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> item of list.find(<span class="md-code-string">&apos;li&apos;</span>)) {
    <span class="md-code-built_in">console</span>.log(item)
    <span class="md-code-comment">// &lt;- the &lt;li&gt; wrapped in a jQuery object</span>
  }
}
</code></pre> <p>This brings me to an important aspect of iterables and iterators.</p> <h2 id="lazy-in-nature">Lazy in Nature</h2> <p>Iterators are <em>lazy in nature</em>. This is fancy-speak for saying that the sequence is accessed one item at a time. It can even be an infinite sequence &#x2013; a legitimate scenario with many use cases. Given that iterators are lazy, having jQuery wrap every result in the sequence with their wrapper object wouldn&#x2019;t have a big upfront cost. Instead, a wrapper is created each time a value is pulled from the <em>iterator</em>.</p> <p>How would an infinite iterator look? The example below shows an iterator with a <code class="md-code md-code-inline">1..Infinity</code> range. Note how it will never yields <code class="md-code md-code-inline">done: true</code>, signaling that the sequence is over. Attempting to cast the iterable <code class="md-code md-code-inline">foo</code> object into an array using either <code class="md-code md-code-inline">Array.from(foo)</code> or <code class="md-code md-code-inline">[...foo]</code> would crash our program, since the sequence <em>never ends</em>. We must be very careful with these types of sequences as they can crash and burn our Node process, or the human&#x2019;s browser tab.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = {
  [Symbol.iterator]: () =&gt; {
    <span class="md-code-keyword">var</span> i = <span class="md-code-number">0</span>
    <span class="md-code-keyword">return</span> { next: () =&gt; (<mark class="md-mark md-code-mark">{ value: ++i }</mark>) }
  }
}
</code></pre> <p>The correct way of working with such an iterator is with an escape condition that prevents the loop from going infinite. The example below loops over our infinite sequence using <code class="md-code md-code-inline">for..of</code>, but it breaks the loop as soon as the value goes over <code class="md-code md-code-inline">10</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> pony of foo) {
  <span class="md-code-keyword">if</span> (pony &gt; <span class="md-code-number">10</span>) {
    <mark class="md-mark md-code-mark">break</mark>
  }
  <span class="md-code-built_in">console</span>.log(pony)
}
</code></pre> <blockquote> <p>The iterator doesn&#x2019;t really <em>know</em> that the sequence is infinite. In that regard, this is similar to the <a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank" aria-label="Halting Problem on Wikipedia">halting problem</a> &#x2013; there is no way of knowing whether the sequence is infinite or not in code.</p> <p><a href="https://xkcd.com/1266/" target="_blank" aria-label="Halting Problem on XKCD"><img alt="The halting problem depicted by XKCD" class="" src="https://imgs.xkcd.com/comics/halting_problem.png"></a></p> <p>We <strong>usually have a good idea</strong> about whether a sequence is <em>finite or infinite</em>, since we construct those sequences. Whenever we have an infinite sequence it&#x2019;s up to us to add an escape condition that ensures our program won&#x2019;t crash in an attempt to loop over every single value in the sequence.</p> </blockquote> <p><em>Come back tomorrow for <a href="https://ponyfoo.com/articles/es6-generators-in-depth" aria-label="ES6 Generators in Depth on Pony Foo">a discussion about generators!</a></em></p></div>
