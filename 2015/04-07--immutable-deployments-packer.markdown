<h1>Immutable Deployments and Packer</h1>

<blockquote><p>A correct<em>er</em> title for this series would be something along the lines of <strong>&#x201C;Automating autoscaled zero-downtime immutable deployments using plain old bash, <a href="http://packer.io/" target="_blank">Packer</a>, &#x2026;</strong></p></blockquote>

<div><kbd>packer</kbd> <kbd>aws</kbd> <kbd>ami</kbd> <kbd>immutable-deployments</kbd></div>

<div><p>A correct<em>er</em> title for this series would be something along the lines of <strong>&#x201C;Automating autoscaled zero-downtime immutable deployments using plain old bash, <a href="http://packer.io/" target="_blank">Packer</a>, nginx, Node.js, and AWS&#x201D;</strong>, but that would&#x2019;ve been kind of long <em>(although it does fit on a tweet)</em>. My last article on the subject was two years ago, when I wrote about <a href="https://ponyfoo.com/articles/deploying-node-apps-to-aws-using-grunt">Deploying Node apps to AWS using Grunt</a>. Here&#x2019;s a <em>long overdue</em> update, containing everything I&#x2019;ve learned about deployments in the time since then.</p></div>

<div></div>

<div><p>This detailed article series aims to explain:</p> <ul> <li>How to provision a ready-made image <em>before every deployment</em></li> <li>How to make that image set up <code class="md-code md-code-inline">nginx</code>, <code class="md-code md-code-inline">node</code>, and your web application</li> <li>How to dynamically update DNS record sets</li> <li>How to let AWS handle scaling on your behalf</li> <li>How to <strong>avoid downtime</strong> during deployments</li> <li>How to clean up all this mess</li> <li>How to do all of the above in <strong>plain old bash</strong></li> <li><em>Why any of the above matters</em></li> </ul> <p>In this article <strong>I&#x2019;ll start by explaining why doing any of this matters</strong>, and then move on to <em>creating <a href="http://chadfowler.com/blog/2013/06/23/immutable-deployments/" target="_blank">immutable</a> images</em> ready for deployment using <a href="http://packer.io/" target="_blank">Packer</a>.</p></div>

<div><h1 id="motivation">Motivation</h1> <p>The process I described years ago is <em>notoriously dated</em>. It doesn&#x2019;t handle autoscaling, immutability, or unobtrusive deployments. Given that the process <strong>isn&#x2019;t immutable</strong>, it takes a long time between the moment you decide to launch an instance and the moment it becomes able to start serving responses.</p> <blockquote> <p>That being said, most people <em>(at least most of those who don&#x2019;t rely on a PaaS provider to handle their deployments on a <code class="md-code md-code-inline">git push</code>)</em> use some sort of mutable deployment script, often <strong>believing it really is a better strategy than immutable deployments</strong>.</p> </blockquote> <p>I decided to revisit the topic because I&#x2019;ve come across the need to design a robust deployment process that scales well for a project I&#x2019;m working on, and I naturally came back to what I originally had. Back when I redesigned Pony Foo, I redid <a href="http://github.com/bevacqua/grunt-ec2" target="_blank" aria-label="grunt-ec2 on GitHub">grunt-ec2</a> using just Bash. It definitely has <a href="https://github.com/ponyfoo/ponyfoo/tree/master/build/ec2" target="_blank" aria-label="Bash EC2 deployment scripts on GitHub">made it easier on the DevOps side of things</a>, but it was still as mutable as ever.</p> <h2 id="why-stop-using-something-that-works">Why stop using something that works?</h2> <p>There were quite a few problems with <a href="https://ponyfoo.com/articles/deploying-node-apps-to-aws-using-grunt" aria-label="Deploying Node apps to AWS using Grunt on Pony Foo">the approach I was taking</a>. To name a few:</p> <ul> <li>Instances took a long time to boot, and deployments would reuse an existing instance</li> <li>Scaling would be hard because there was <strong>no clear cut way to scale horizontally</strong> <em>(add more hardware)</em></li> <li>Deployments could effectively <a href="http://en.wikipedia.org/wiki/Brick_%28electronics%29" target="_blank" aria-label="Brick (electronics) on Wikipedia"><em>&#x201C;brick&#x201D;</em></a> an instance that <strong>took a long time to spin into existence</strong> in the first place</li> <li>Thus, deployments could be zero-downtime or &#x201C;a-few-minutes-<em>(until a new instance is up and running)</em>-downtime&#x201D;</li> <li>Configuring a new environment, adding a DNS record set, or <a href="http://aws.amazon.com/elasticloadbalancing/" target="_blank" aria-label="Amazon Web Services Elastic Load Balancer">conjuring up a load balancer</a>, was carried out by hand</li> </ul> <p>In contrast, I now have more serious requirements than simply running a blog <em>(which hardly gets updated, too)</em>. I wanted the system to be able to make deployments safer, without downtime, and without meddling with currently running instances. My experience with mutable deployments in the last two years was <em>nothing short of disappointing</em>. Mutable deployments are disappointing because they&#x2019;re super hard to scale, and also because <strong>they make it super easy to disrupt the state of a perfectly healthy production web server</strong>.</p> <p>I wanted the system to be able to scale out on its own <em>(to a certain degree)</em>. While I certainly wouldn&#x2019;t want the system to suddenly boot up tens of <a href="http://aws.amazon.com/ec2/instance-types/#c4" target="_blank" aria-label="Amazon Web Services Instance Types">c4.8xlarge</a> instances and get an electricity bill worthy of an operation the size of a nuclear power plant, I wanted something that would operate on a range and was able to <strong>handle mounting traffic</strong> load patterns.</p> <p>What I really needed was to make server instances <strong>disposable</strong> and make it faster to add extra instances behind the load balancer. The best way to accomplish this is by creating an image. You always use images. Amazon has a huge repository of bare OS images you can use. So far, <a href="https://ponyfoo.com/articles/deploying-node-apps-to-aws-using-grunt" aria-label="Deploying Node apps to AWS using Grunt on Pony Foo">as explained in my old article</a>, I had been using a Ubuntu base image, and then running my mutable deployments on top of that, over and over.</p> <p>Instead of creating your EC2 instance with a bare OS image, we&#x2019;ll take a multi-step approach.</p> <ol> <li>Create a base image <em>(code-named <code class="md-code md-code-inline">primal</code>)</em> to be <strong>reused in every deploy</strong></li> </ol> <ul> <li>Based on the bare OS image</li> <li>Make basic OS networking tweaks</li> <li>Install and configure <code class="md-code md-code-inline">nginx</code> and <code class="md-code md-code-inline">node</code></li> <li>Install your application&#x2019;s <code class="md-code md-code-inline">npm</code> dependencies so that the next step takes less time</li> <li>Once <code class="md-code md-code-inline">primal</code> is created it can be reused in every subsequent deployment</li> </ul> <ol> <li>Build your application</li> </ol> <ul> <li>Compile static assets, running tools like <code class="md-code md-code-inline">browserify</code></li> <li>Optimize them <em>(if target environment is <strong>production</strong>)</em></li> </ul> <ol> <li>Create a deployment image <em>(code-named <code class="md-code md-code-inline">carnivore</code>)</em></li> </ol> <ul> <li>Based on <code class="md-code md-code-inline">primal</code></li> <li>Upload latest changes to your application</li> <li>Upload latest changes to <code class="md-code md-code-inline">nginx</code> configuration</li> <li>Install latest <code class="md-code md-code-inline">npm</code> dependencies <em>(faster if &#x201C;pre-filled&#x201D; in previous step)</em></li> <li>Register the web application as a service in <code class="md-code md-code-inline">upstart</code> or <code class="md-code md-code-inline">init.d</code></li> </ul> <ol> <li>Launch an instance based on <code class="md-code md-code-inline">carnivore</code></li> </ol> <ul> <li>It&#x2019;ll be <strong>ready to use as soon as it boots</strong> and the application starts</li> <li>Launching extra instances can skip provisioning steps <code class="md-code md-code-inline">1</code>, <code class="md-code md-code-inline">2</code>, and <code class="md-code md-code-inline">3</code></li> </ul> <p>As you can see, this workflow is <em>a bit more involved</em> than what you need to do to get mutable deployments up and running, but it will definitely be worth your while.</p> <p>When your <strong>infrastructure becomes disposable</strong>, you can supervise your instances. As soon as one of them seems unhealthy you could create a replacement, and then eventually terminate the unhealthy instance, with the replacement taking its place. This process is fast for immutable systems, but it&#x2019;s a nightmare if you actively rely on specific instances that take a long time to boot up. What happens when <em>&#x201C;Dependency Server 3&#x201D;</em> is down? You&#x2019;re unable to scale.</p> <p>The new approach doesn&#x2019;t get rid of the fixation on third party dependency management systems, but it contains that to the image creation steps. This is already an improvement, because you&#x2019;ll then be able to scale out your infrastructure even when dependency services are down <em>(as an image would have been already created once)</em>.</p> <p>Better yet, you can leave the disposing and scaling to an <a href="http://aws.amazon.com/autoscaling/" target="_blank" aria-label="Amazon Web Services Auto Scaling">Auto Scaling Group</a> in Amazon, as we&#x2019;ll uncover in the next article.</p> <h1 id="using-packer">Using Packer</h1> <p>I&#x2019;ve only recently stumbled upon <a href="http://packer.io/" target="_blank" aria-label="Packer by HashiCorp">Packer</a>. Here&#x2019;s how they describe it.</p> <blockquote> <p><strong>Packer</strong> is a tool for creating identical machine images for multiple platforms from a single source configuration.</p> </blockquote> <p>First off, you&#x2019;ll need to <a href="https://packer.io/intro/getting-started/setup.html" target="_blank" aria-label="Installing Packer">install Packer</a>. If you&#x2019;re using OSX and like <code class="md-code md-code-inline">brew</code>ing things, you&#x2019;re in luck.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">brew tap homebrew/binary
brew install packer
</code></pre> <p>The <em>&#x201C;single source configuration&#x201D;</em> they speak of is really a small_ish_ JSON manifest that describes user variables, how the image is going to be built, and how it&#x2019;s going to be provisioned. In our case, we&#x2019;ll have two of these manifests. One is for the <code class="md-code md-code-inline">primal</code> image I described in step 1 above, and the other is for the <code class="md-code md-code-inline">carnivore</code> image described in step 3.</p> <h1 id="defining-the-base-image">Defining the base image</h1> <p>Below you&#x2019;ll find the <code class="md-code md-code-inline">primal</code> manifest used to bake images for <strong>Pony Foo</strong>. You&#x2019;ll note that it&#x2019;s mostly readable, but we&#x2019;ll tear it apart anyways.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">variables</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">INSTANCE_USER</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;admin&quot;</span></span>,
    &quot;<span class="md-code-attribute">NVM_VERSION</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;v0.24.0&quot;</span></span>,
    &quot;<span class="md-code-attribute">NODE_VERSION</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;0.10&quot;</span>
  </span>}</span>,
  &quot;<span class="md-code-attribute">builders</span>&quot;: <span class="md-code-value">[{
    &quot;<span class="md-code-attribute">type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;amazon-ebs&quot;</span></span>,
    &quot;<span class="md-code-attribute">region</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;us-east-1&quot;</span></span>,
    &quot;<span class="md-code-attribute">source_ami</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;ami-22de994a&quot;</span></span>,
    &quot;<span class="md-code-attribute">instance_type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;t1.micro&quot;</span></span>,
    &quot;<span class="md-code-attribute">ssh_username</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;{{user `INSTANCE_USER`}}&quot;</span></span>,
    &quot;<span class="md-code-attribute">ami_name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;ponyfoo-primal {{timestamp}}&quot;</span>
  </span>}]</span>,
  &quot;<span class="md-code-attribute">provisioners</span>&quot;: <span class="md-code-value">[{
    &quot;<span class="md-code-attribute">type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;file&quot;</span></span>,
    &quot;<span class="md-code-attribute">source</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;deploy/mailtube&quot;</span></span>,
    &quot;<span class="md-code-attribute">destination</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;/tmp/mailtube&quot;</span>
  </span>}, {
    &quot;<span class="md-code-attribute">type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;shell&quot;</span></span>,
    &quot;<span class="md-code-attribute">environment_vars</span>&quot;: <span class="md-code-value">[
      <span class="md-code-string">&quot;INSTANCE_USER={{user `INSTANCE_USER`}}&quot;</span>,
      <span class="md-code-string">&quot;NVM_VERSION={{user `NVM_VERSION`}}&quot;</span>,
      <span class="md-code-string">&quot;NODE_VERSION={{user `NODE_VERSION`}}&quot;</span>
    ]</span>,
    &quot;<span class="md-code-attribute">script</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;deploy/templates/primal&quot;</span>
  </span>}]
</span>}
</code></pre> <p>The first section of the manifest has a series of <code class="md-code md-code-inline">variables</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">variables</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">INSTANCE_USER</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;admin&quot;</span></span>,
    &quot;<span class="md-code-attribute">NVM_VERSION</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;v0.24.0&quot;</span></span>,
    &quot;<span class="md-code-attribute">NODE_VERSION</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;0.10&quot;</span>
  </span>}
</span>}
</code></pre> <p>Variables in packer can be modified by the user who is creating an image. We&#x2019;ll just allow them to change the version of <a href="https://github.com/creationix/nvm" target="_blank" aria-label="creationix/nvm on GitHub">nvm</a> and the version of <code class="md-code md-code-inline">node</code> that they want installed. <code class="md-code md-code-inline">nvm</code> is a &#x201C;Node Version Manager&#x201D; that makes it very easy to switch between versions of <code class="md-code md-code-inline">node</code> <em>(and <code class="md-code md-code-inline">io.js</code>)</em>, which makes it ideal if we want to leave the version of <code class="md-code md-code-inline">node</code> up to the image builder.</p> <p>Next up we have the <code class="md-code md-code-inline">builders</code> section.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">builders</span>&quot;: <span class="md-code-value">[{
    &quot;<span class="md-code-attribute">type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;amazon-ebs&quot;</span></span>,
    &quot;<span class="md-code-attribute">region</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;us-east-1&quot;</span></span>,
    &quot;<span class="md-code-attribute">source_ami</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;ami-22de994a&quot;</span></span>,
    &quot;<span class="md-code-attribute">instance_type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;t1.micro&quot;</span></span>,
    &quot;<span class="md-code-attribute">ssh_username</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;{{user `INSTANCE_USER`}}&quot;</span></span>,
    &quot;<span class="md-code-attribute">ami_name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;ponyfoo-primal {{timestamp}}&quot;</span>
  </span>}]
</span>}
</code></pre> <p>First off, I should point out that <code class="md-code md-code-inline">ami-22de994a</code> is a <strong>Debian Wheezy</strong> base image. The <code class="md-code md-code-inline">ssh_username</code> is what will be used to <code class="md-code md-code-inline">ssh</code> onto the instance while provisioning, and the <code class="md-code md-code-inline">{{user VARIABLE}}</code> expression allows us to make the user configurable through <code class="md-code md-code-inline">variables</code>. The AMI name contains a <code class="md-code md-code-inline">{{timestamp}}</code> expression so that the resulting AMI has a unique name, a requirement of AWS. The rest of the configuration speaks for itself: we want a <code class="md-code md-code-inline">t1.micro</code> instance backed by <a href="http://aws.amazon.com/ebs/" target="_blank" aria-label="Elastic Block Store on Amazon">EBS storage</a> on the <code class="md-code md-code-inline">us-east-1</code> region.</p> <p>Oh, also, I&#x2019;m prefixing the AMI with <code class="md-code md-code-inline">ponyfoo-</code> so that it doesn&#x2019;t collide with <code class="md-code md-code-inline">primal</code> images for other applications in my AWS account. Throughout the series, you&#x2019;ll notice that resources are tagged with the application name, and sometimes also with the execution environment <em>(<code class="md-code md-code-inline">staging</code>, <code class="md-code md-code-inline">production</code>, etc.)</em> This helps us to both quickly identify what application an instance belongs to, as well prevent naming collisions across our AWS resources.</p> <p>We&#x2019;ve saved the best for last, and we&#x2019;re now getting to the <code class="md-code md-code-inline">provisioners</code> in our <a href="http://packer.io/" target="_blank" aria-label="Packer by HashiCorp">Packer</a> manifest. There&#x2019;s two provisioners, let&#x2019;s start with the <code class="md-code md-code-inline">file</code> one.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;file&quot;</span></span>,
  &quot;<span class="md-code-attribute">source</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;deploy/mailtube&quot;</span></span>,
  &quot;<span class="md-code-attribute">destination</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;/tmp/mailtube&quot;</span>
</span>}
</code></pre> <p>There&#x2019;s quite a bit going on here. The AMI image builder in Packer spins up an Amazon EC2 instance, where you make your adjustments <em>(provisioning)</em> and then it gets frozen into an AMI. Provisioners come into play once the instance is accessible via <code class="md-code md-code-inline">ssh</code>.</p> <p>We&#x2019;re going to upload an entire directory to <code class="md-code md-code-inline">/tmp/mailtube</code>. <a href="http://packer.io/" target="_blank" aria-label="Packer by HashiCorp">Packer</a> will figure out on its own whether to use <code class="md-code md-code-inline">rsync</code>, <code class="md-code md-code-inline">scp</code>, or something else entirely. <em>Not our problem!</em></p> <p><img alt="A mail tube" class="" src="https://i.imgur.com/u4Vdu3R.jpg"></p> <p>We&#x2019;re going to send a few precious things up the tube.</p> <ul> <li>A template to set up our service in <code class="md-code md-code-inline">init.d</code></li> <li>Templates to provision our application in <code class="md-code md-code-inline">nginx</code></li> <li>The initial <code class="md-code md-code-inline">package.json</code> so we can install some preliminary packages</li> </ul> <p>The <code class="md-code md-code-inline">package.json</code> step seems hacky, but it&#x2019;s also crucial. Installing dependencies takes <em>a long time</em>, and having as many of them pre-installed in <code class="md-code md-code-inline">primal</code> allows us to keep the build time for <code class="md-code md-code-inline">carnivore</code> at a minimum. Considering we&#x2019;re going to build <code class="md-code md-code-inline">primal</code> far less often, it&#x2019;s a good thing to do. <em>We&#x2019;ll worry about copying our <code class="md-code md-code-inline">package.json</code> over to the mailtube later.</em></p> <p>There&#x2019;s also the <code class="md-code md-code-inline">shell</code> provisioner. This one uploads and runs a script on the instance we&#x2019;re using to define our AMI.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;shell&quot;</span></span>,
  &quot;<span class="md-code-attribute">environment_vars</span>&quot;: <span class="md-code-value">[
    <span class="md-code-string">&quot;INSTANCE_USER={{user `INSTANCE_USER`}}&quot;</span>,
    <span class="md-code-string">&quot;NVM_VERSION={{user `NVM_VERSION`}}&quot;</span>,
    <span class="md-code-string">&quot;NODE_VERSION={{user `NODE_VERSION`}}&quot;</span>
  ]</span>,
  &quot;<span class="md-code-attribute">script</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;deploy/templates/primal&quot;</span>
</span>}
</code></pre> <p>Here again you see a few <code class="md-code md-code-inline">{{user VARIABLE}}</code> expressions, used to expose those user variables to the shell script described below. This is probably where your provisioning of <code class="md-code md-code-inline">primal</code> is going to differ the most from mine, so let&#x2019;s take it slow.</p> <h1 id="provisioning-primal-with-bash">Provisioning <code class="md-code md-code-inline">primal</code> with Bash</h1> <p>First off, this is a Bash script <a href="https://github.com/bevacqua/baal/blob/master/deploy/templates/primal" target="_blank" aria-label="Primal provisioning script on GitHub"><em>(full script here)</em></a>, not a lot of mystery.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-shebang">#!/bin/bash
</span></code></pre> <p>We kick off our provisioning by updating <code class="md-code md-code-inline">apt-get</code>, and installing essentials such as <code class="md-code md-code-inline">git</code>, <code class="md-code md-code-inline">curl</code>, and <code class="md-code md-code-inline">gm</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: updating aptitude&quot;</span>
sudo apt-key update
sudo apt-get update
sudo apt-get remove apt-listchanges
sudo apt-get install git make g++ graphicsmagick curl -y
</code></pre> <p>Right after, we&#x2019;ll install <code class="md-code md-code-inline">nginx</code>. We need to <code class="md-code md-code-inline">chown</code> the logs or else we&#x2019;ll run into trouble when starting <code class="md-code md-code-inline">nginx</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: nginx&quot;</span>
sudo mkdir -p /var/<span class="md-code-built_in">log</span>/nginx
sudo chown <span class="md-code-variable">$INSTANCE_USER</span> /var/<span class="md-code-built_in">log</span>/nginx
sudo chmod -R <span class="md-code-number">755</span> /var/<span class="md-code-built_in">log</span>/nginx
sudo apt-get install nginx -y
</code></pre> <p>We install <code class="md-code md-code-inline">nvm</code> right off of GitHub, using <code class="md-code md-code-inline">NVM_VERSION</code> as provided.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: nvm&quot;</span>
curl https://raw.githubusercontent.com/creationix/nvm/<span class="md-code-variable">$NVM_VERSION</span>/install.sh | bash
. ~/.nvm/nvm.sh
</code></pre> <p>Time to install <code class="md-code md-code-inline">node</code> at the agreed upon <code class="md-code md-code-inline">NODE_VERSION</code> version, and update <code class="md-code md-code-inline">npm</code> to the latest possible version. Updating <code class="md-code md-code-inline">npm</code> seems unnecessary but it actually resolves a lot of potential issues.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: nodejs&quot;</span>
nvm install <span class="md-code-variable">$NODE_VERSION</span>
nvm <span class="md-code-built_in">alias</span> default <span class="md-code-variable">$NODE_VERSION</span>
npm update -g npm
</code></pre> <p>Make sure we source <code class="md-code md-code-inline">nvm</code> if we manually <code class="md-code md-code-inline">ssh</code> into the instance, for convenience.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&apos;[[ -s $HOME/.nvm/nvm.sh ]] &amp;&amp; . $HOME/.nvm/nvm.sh&apos;</span> &gt;&gt; ~/.bashrc
</code></pre> <p>The next command makes TCP a tad faster for bursty connections <em>(HTTP is bursty)</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: tweaking tcp&quot;</span>
sudo sysctl -w net.ipv4.tcp_slow_start_after_idle=<span class="md-code-number">0</span>
</code></pre> <p>The next batch of commands enables port forwarding, forwards port <code class="md-code md-code-inline">80</code> to port <code class="md-code md-code-inline">8080</code>, and instructs the instance to remember the new port forwarding rules across restarts. This is so that our application doesn&#x2019;t have to bind on port <code class="md-code md-code-inline">80</code>, which would require elevated privileges.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: ipv4 forwarding&quot;</span>
cp /etc/sysctl.conf /tmp/
<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /tmp/sysctl.conf
sudo cp /tmp/sysctl.conf /etc/
sudo sysctl -p /etc/sysctl.conf

<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: forward port 80 to 8080&quot;</span>
sudo iptables -A PREROUTING -t nat -i eth0 -p tcp --dport <span class="md-code-number">80</span> -j REDIRECT --to-port <span class="md-code-number">8080</span>
sudo iptables -A INPUT -p tcp -m tcp --sport <span class="md-code-number">80</span> -j ACCEPT
sudo iptables -A OUTPUT -p tcp -m tcp --dport <span class="md-code-number">80</span> -j ACCEPT
sudo iptables-save &gt; /tmp/iptables-store.conf
sudo mv /tmp/iptables-store.conf /etc/iptables-store.conf

<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: remember port forwarding rule across reboots&quot;</span>
<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;#!/bin/sh&quot;</span> &gt; /tmp/iptables-ifupd
<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;iptables-restore &lt; /etc/iptables-store.conf&quot;</span> &gt;&gt; /tmp/iptables-ifupd
chmod +x /tmp/iptables-ifupd
sudo mv /tmp/iptables-ifupd /etc/network/<span class="md-code-keyword">if</span>-up.d/iptables
</code></pre> <p>The time has come to pre-fill <code class="md-code md-code-inline">node_modules</code>. Since we don&#x2019;t actually have the application yet <em>(the tube only had a <code class="md-code md-code-inline">package.json</code>)</em>, we&#x2019;ll install these dependencies somewhere and then move them later. We only care about <code class="md-code md-code-inline">--production</code> modules, of course.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: precaching server dependencies&quot;</span>
mkdir -p ~/app/precache
cp -r /tmp/mailtube ~/app/mailtube
cp ~/app/mailtube/package.json ~/app/precache
npm install --prefix ~/app/precache --production
</code></pre> <p>Finally, we tell <code class="md-code md-code-inline">init.d</code> to run <code class="md-code md-code-inline">nginx</code> at system startup.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: installing nginx at system startup&quot;</span>
sudo update-rc.d nginx defaults
</code></pre> <p><strong>Sweet!</strong> We&#x2019;re done with the first step! Running <code class="md-code md-code-inline">packer build primal.json</code> will produce the <code class="md-code md-code-inline">primal</code> image and give us the ID for the AMI, <em><code class="md-code md-code-inline">ami-xxxxxx</code></em>.</p> <p><img alt="Screenshot of the terminal output when building primal image" class="" src="https://i.imgur.com/LW1gBuj.png"></p> <p>That took us a bunch of time, but to be quite fair we did all of this in <a href="https://ponyfoo.com/articles/deploying-node-apps-to-aws-using-grunt" aria-label="Deploying Node apps to AWS using Grunt on Pony Foo">our old setup</a>. The only difference is that now you can <em>&#x201C;take a shortcut&#x201D;</em>, and create instances based on this AMI, saving you the time of installing all those lumps of dependencies over and over again.</p> <p>We can now build <code class="md-code md-code-inline">carnivore</code> based on the <code class="md-code md-code-inline">primal</code> AMI.</p> <h1 id="building-carnivore-with-packer">Building <code class="md-code md-code-inline">carnivore</code> with Packer</h1> <p>Now that we have <code class="md-code md-code-inline">primal</code>, and assuming you&#x2019;ll take it upon yourself to build and optimize your static assets, it&#x2019;s time for step 3, burning <code class="md-code md-code-inline">carnivore</code>. Given that <code class="md-code md-code-inline">carnivore</code> is built on virtually every deployment, it has more configurability built into it, and at the same time its provisioning script is smaller.</p> <p>First off, some variables. Arguably you&#x2019;ll rarely want to change the amount of <code class="md-code md-code-inline">nginx</code> workers, but you&#x2019;ll definitely want to be able to set the <code class="md-code md-code-inline">NODE_ENV</code>, <code class="md-code md-code-inline">SERVER_NAME</code>, and whatnot.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">variables</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">NODE_ENV</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;staging&quot;</span></span>,
    &quot;<span class="md-code-attribute">SERVER_NAME</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;ponyfoo.com&quot;</span></span>,
    &quot;<span class="md-code-attribute">INSTANCE_USER</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;admin&quot;</span></span>,
    &quot;<span class="md-code-attribute">NGINX_WORKERS</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;4&quot;</span></span>,
    &quot;<span class="md-code-attribute">SOURCE_ID</span>&quot;: <span class="md-code-value"><span class="md-code-literal">null</span>
  </span>}
</span>}
</code></pre> <p>As you can see below, the <code class="md-code md-code-inline">SOURCE_ID</code> variable is used as input for the base AMI to be extended by <code class="md-code md-code-inline">carnivore</code>. This will be configured by our deployment script to use the ID provided by Packer when building <code class="md-code md-code-inline">primal</code>. The AMI in this case is also tagged with <code class="md-code md-code-inline">NODE_ENV</code>, because you built your static assets specifically for that environment, right before building the image.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">builders</span>&quot;: <span class="md-code-value">[{
    &quot;<span class="md-code-attribute">type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;amazon-ebs&quot;</span></span>,
    &quot;<span class="md-code-attribute">region</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;us-east-1&quot;</span></span>,
    &quot;<span class="md-code-attribute">instance_type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;t1.micro&quot;</span></span>,
    &quot;<span class="md-code-attribute">ssh_username</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;{{user `INSTANCE_USER`}}&quot;</span></span>,
    &quot;<span class="md-code-attribute">ami_name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;ponyfoo-carnivore-{{user `NODE_ENV`}} {{timestamp}}&quot;</span></span>,
    &quot;<span class="md-code-attribute">source_ami</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;{{user `SOURCE_ID`}}&quot;</span>
  </span>}]
</span>}
</code></pre> <p>Once again we have two provisioners. The first one is a directory upload, just like last time. This time, we&#x2019;re uploading everything that&#x2019;s needed to run our application in its current state. Given that we&#x2019;ve built static assets on our local environment, we&#x2019;ll copy the essentials to run the application onto <code class="md-code md-code-inline">tmp/appserver</code> and upload that to build the image.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;file&quot;</span></span>,
  &quot;<span class="md-code-attribute">source</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;tmp/appserver&quot;</span></span>,
  &quot;<span class="md-code-attribute">destination</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;/tmp/appserver&quot;</span>
</span>}
</code></pre> <p>We have the base <code class="md-code md-code-inline">primal</code> image as well as the uploaded <code class="md-code md-code-inline">/tmp/appserver</code> application. Our last step is to upload and execute the <code class="md-code md-code-inline">carnivore</code> provisioning script.</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">type</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;shell&quot;</span></span>,
  &quot;<span class="md-code-attribute">environment_vars</span>&quot;: <span class="md-code-value">[
    <span class="md-code-string">&quot;INSTANCE_USER={{user `INSTANCE_USER`}}&quot;</span>,
    <span class="md-code-string">&quot;NGINX_WORKERS={{user `NGINX_WORKERS`}}&quot;</span>,
    <span class="md-code-string">&quot;SERVER_NAME={{user `SERVER_NAME`}}&quot;</span>,
    <span class="md-code-string">&quot;NODE_ENV={{user `NODE_ENV`}}&quot;</span>,
    <span class="md-code-string">&quot;NAME=ponyfoo-{{user `NODE_ENV`}}&quot;</span>
  ]</span>,
  &quot;<span class="md-code-attribute">script</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;deploy/templates/carnivore&quot;</span>
</span>}
</code></pre> <p>Once the script is uploaded, Packer will execute it and our final AMI will be ready.</p> <h1 id="priming-carnivore-with-bash">Priming <code class="md-code md-code-inline">carnivore</code> with Bash</h1> <p>Again, we&#x2019;ll use a Bash script. You can also <a href="https://github.com/bevacqua/baal/blob/master/deploy/templates/carnivore" target="_blank" aria-label="Carnivore provisioning script on GitHub">skip ahead to the full script on GitHub</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-shebang">#!/bin/bash
</span></code></pre> <p>For some awkward reason, I can&#x2019;t figure out why I need to source <code class="md-code md-code-inline">nvm</code> again <em>(after adding it to <code class="md-code md-code-inline">~/.bashrc</code>)</em>. It works when I <code class="md-code md-code-inline">ssh</code> into the instance, but not here, unless I explicitly source it again.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: sourcing nvm&quot;</span>
. ~/.nvm/nvm.sh
</code></pre> <p>We now take the <code class="md-code md-code-inline">nginx.conf</code> and <code class="md-code md-code-inline">site.conf</code> templates made available to <code class="md-code md-code-inline">primal</code> and copy them over to our application directory. We use <code class="md-code md-code-inline">sed</code> to replace a bunch of variables in the template, and we link up <code class="md-code md-code-inline">/etc/nginx/nginx.conf</code> to what we did. I&#x2019;m using <code class="md-code md-code-inline">~/app/server/.bin/public</code> as the static root just because that&#x2019;s where I end up compiling static assets, no other particular reason.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: updating nginx configuration&quot;</span>
cp -r ~/app/mailtube/nginx ~/app/nginx

sed -i <span class="md-code-string">&quot;s#{NGINX_USER}#<span class="md-code-variable">$INSTANCE_USER</span>#g&quot;</span> ~/app/nginx/nginx.conf
sed -i <span class="md-code-string">&quot;s#{NGINX_WORKERS}#<span class="md-code-variable">$NGINX_WORKERS</span>#g&quot;</span> ~/app/nginx/nginx.conf
sed -i <span class="md-code-string">&quot;s#{SERVER_NAME}#<span class="md-code-variable">$SERVER_NAME</span>#g&quot;</span> ~/app/nginx/site.conf
sed -i <span class="md-code-string">&quot;s#{STATIC_ROOT}#<span class="md-code-variable">$HOME</span>/app/server/.bin/public#g&quot;</span> ~/app/nginx/site.conf

sudo ln -sfn ~/app/nginx/nginx.conf /etc/nginx/nginx.conf
sudo ln -sfn ~/app/nginx/site.conf /etc/nginx/sites-enabled/<span class="md-code-variable">$NAME</span>.conf
sudo rm /etc/nginx/sites-enabled/default
</code></pre> <p>Once that&#x2019;s done, we make sure <code class="md-code md-code-inline">nginx</code> is up <em>(or whine about it.)</em></p> <pre class="md-code-block"><code class="md-code md-lang-bash">sudo service nginx restart || sudo service nginx start || (sudo cat /var/<span class="md-code-built_in">log</span>/nginx/error.log &amp;&amp; <span class="md-code-built_in">exit</span> <span class="md-code-number">1</span>)
</code></pre> <p>We take the <code class="md-code md-code-inline">appserver</code> directory that we&#x2019;ve just uploaded and move it to the application directory. We also take the modules we&#x2019;ve pre-installed during <code class="md-code md-code-inline">primal</code> provisioning. Then, we install whatever dependencies are missing or outdated. Again on a personal note, I always upload a specially crafted <code class="md-code md-code-inline">deploy/env/$NODE_ENV.json</code> with environment secrets, for convenience.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: moving uploaded server code&quot;</span>
mv /tmp/appserver ~/app/server

<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: installing server dependencies&quot;</span>
mv ~/app/server/deploy/env/<span class="md-code-variable">$NODE_ENV</span>.json ~/app/server/.env.json
mv ~/app/precache/node_modules ~/app/server/node_modules
npm install --prefix ~/app/server --production
</code></pre> <p>Lastly we register a service on <code class="md-code md-code-inline">init.d</code> for the web application to run at startup. Again, I believe I shouldn&#x2019;t be sourcing <code class="md-code md-code-inline">nvm</code> if I&#x2019;m already using <code class="md-code md-code-inline">bash</code> for an environment, but it won&#x2019;t show up unless I do. The <code class="md-code md-code-inline">init.d</code> service configuration template was previously uploaded through the tube, and it&#x2019;s configurable mostly so that I can reuse it across applications using a similar deployment strategy.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: installing appserver daemon...&quot;</span>
<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;#!/bin/bash&quot;</span> &gt; ~/app/start
<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;. ~/.nvm/nvm.sh&quot;</span> &gt;&gt; ~/app/start
<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;node ~/app/server/cluster.js&quot;</span> &gt;&gt; ~/app/start
chmod +x ~/app/start
cp ~/app/mailtube/init.d/appserver.conf ~/app/<span class="md-code-variable">$NAME</span>.conf
sed -i <span class="md-code-string">&quot;s#{NAME}#<span class="md-code-variable">$NAME</span>#g&quot;</span> ~/app/<span class="md-code-variable">$NAME</span>.conf
sed -i <span class="md-code-string">&quot;s#{DESCRIPTION}#Web application daemon service for <span class="md-code-variable">$NAME</span>#g&quot;</span> ~/app/<span class="md-code-variable">$NAME</span>.conf
sed -i <span class="md-code-string">&quot;s#{USER}#<span class="md-code-variable">$INSTANCE_USER</span>#g&quot;</span> ~/app/<span class="md-code-variable">$NAME</span>.conf
sed -i <span class="md-code-string">&quot;s#{COMMAND}#<span class="md-code-variable">$HOME</span>/app/start#g&quot;</span> ~/app/<span class="md-code-variable">$NAME</span>.conf
sudo mv ~/app/<span class="md-code-variable">$NAME</span>.conf /etc/init.d/<span class="md-code-variable">$NAME</span>
sudo chmod +x /etc/init.d/<span class="md-code-variable">$NAME</span>
sudo touch /var/<span class="md-code-built_in">log</span>/<span class="md-code-variable">$NAME</span>.log
sudo chown <span class="md-code-variable">$INSTANCE_USER</span> /var/<span class="md-code-built_in">log</span>/<span class="md-code-variable">$NAME</span>.log
sudo update-rc.d <span class="md-code-variable">$NAME</span> defaults

<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;packer: booting appserver daemon...&quot;</span>
sudo service <span class="md-code-variable">$NAME</span> start
</code></pre> <p>Note that, given that this is a hosted environment, I play it safe and always run the <code class="md-code md-code-inline">node</code> application off of <code class="md-code md-code-inline">cluster</code>.</p> <p><strong>That&#x2019;s it!</strong> The command below will bring your per-deployment AMI to life. <code class="md-code md-code-inline">PRIMAL_ID</code> should be the ID of your <code class="md-code md-code-inline">primal</code> AMI.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">packer build \
  -var NODE_ENV=<span class="md-code-variable">$NODE_ENV</span> \
  -var SOURCE_ID=<span class="md-code-variable">$PRIMAL_ID</span> \
  carnivore.json
</code></pre> <p>As far as building images for immutable deployments goes, that&#x2019;s all you need.</p> <p>The next article will describe the process through which new environments are set up and deployed to with zero-downtime, all the while leveraging autoscaling groups.</p> <blockquote> <p>Or in <strong>Amazon Web Services acronym speak</strong>: &#x201C;In the next article we&#x2019;ll learn how to leverage <a href="http://aws.amazon.com/autoscaling/" target="_blank" aria-label="Amazon Web Services Auto Scaling">AWS ASG</a> to deploy <a href="http://aws.amazon.com/ec2/" target="_blank" aria-label="Amazon Web Services Elastic Cloud Compute">EC2</a> instances behind an <a href="http://aws.amazon.com/elasticloadbalancing/" target="_blank" aria-label="Amazon Web Services Elastic Load Balancer">ELB</a> that&#x2019;s connected to <a href="http://aws.amazon.com/route53/" target="_blank" aria-label="Amazon Web Services Route 53">Route53</a> changing the <a href="http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/WorkingWithLaunchConfig.html" target="_blank" aria-label="Amazon Web Services Launch Configurations">LC</a> and the <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html" target="_blank" aria-label="Amazon Web Services Machine Images">AMI</a> every time.&#x201D;</p> </blockquote></div>
