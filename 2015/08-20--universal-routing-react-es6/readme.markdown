<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/master/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/universal-routing-react-es6">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/universal-routing-react-es6"><div></div></a>

<h1>Universal Routing in React with ES6</h1>

<p><kbd>babel</kbd> <kbd>react</kbd> <kbd>react-router</kbd> <kbd>es6</kbd> <kbd>universal</kbd></p>

<blockquote><p>Yesterday, we learned about how to set up a build process for an universal ES6 React app using Babel, and <a href="https://ponyfoo.com/articles/universal-react-babel">how to have that React app render &#x201C;universally&#x201D;</a> &#x2026;</p></blockquote>

<div><p>Yesterday, we learned about how to set up a build process for an universal ES6 React app using Babel, and <a href="https://ponyfoo.com/articles/universal-react-babel">how to have that React app render &#x201C;universally&#x201D;</a> &#x2013; on both the server-side and the client-side. Today we&#x2019;ll add <em>routing capabilities</em> to the application so that it isn&#x2019;t <strong><em>literally</em> a &#x201C;single-page app&#x201D;</strong> anymore.</p></div>

<div></div>

<div><p>One thing there&#x2019;s to like about React for sure is that it&#x2019;s only the <strong>V</strong> in <strong>V*</strong> <em>(View, Whatever)</em>. When it comes to routing in your React app, you could implement it yourself by hand or you could use <a href="https://github.com/rackt/react-router" target="_blank"><code class="md-code md-code-inline">react-router</code></a>. Implementing it yourself might sound tempting at first, but <code class="md-code md-code-inline">react-router</code> makes it easy to expand the <em>already-universal</em> app we have with routing capabilities without having to do much different things in either the server or the browser.</p></div>

<div><h1 id="using-react-router">Using <code class="md-code md-code-inline">react-router</code></h1> <p>The Express <code class="md-code md-code-inline">app.js</code> module we <a href="https://ponyfoo.com/articles/universal-react-babel" aria-label="Universal React with Babel, Browserify on Pony Foo">built in the last article</a> looks something like this.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import express from <span class="md-code-string">&apos;express&apos;</span>;
import hbs from <span class="md-code-string">&apos;express-handlebars&apos;</span>;
import React from <span class="md-code-string">&apos;react/addons&apos;</span>;
<mark class="md-mark md-code-mark">import App from <span class="md-code-string">&apos;./components/app&apos;</span>;</mark>

<span class="md-code-keyword">var</span> app = express();
app.engine(<span class="md-code-string">&apos;html&apos;</span>, hbs({ extname: <span class="md-code-string">&apos;html&apos;</span> }));
app.set(<span class="md-code-string">&apos;view engine&apos;</span>, <span class="md-code-string">&apos;html&apos;</span>);
app.locals.settings[<span class="md-code-string">&apos;x-powered-by&apos;</span>] = <span class="md-code-literal">false</span>;
<mark class="md-mark md-code-mark">app.get(<span class="md-code-string">&apos;/&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">home</span> <span class="md-code-params">(req, res, next)</span> </span>{
  res.render(<span class="md-code-string">&apos;layout&apos;</span>, {
    reactHtml: React.renderToString(<span><span class="md-code-tag">&lt;<span class="md-code-title">App</span> /&gt;</span>)
  });
});</span></mark>
app.listen(process.env.PORT || 3000);
</code></pre> <p>If we wanted to add more routes, we&#x2019;d have to add more statements like <code class="md-code md-code-inline">app.get(&apos;/&apos;, function...)</code> above, as well as load each component necessary to render every one fo those routes. As your application grows, complexity would grow linearly as well. A better alternative is using <a href="https://github.com/rackt/react-router" target="_blank" aria-label="rackt/react-router on GitHub"><code class="md-code md-code-inline">react-router</code></a>, which allows you to remove Express from the equation and leave routing to the React application itself. Let&#x2019;s install <code class="md-code md-code-inline">react-router</code> via <code class="md-code md-code-inline">npm</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">npm i react-router -S
</code></pre> <p>Then, you&#x2019;ll need to import the module into your <code class="md-code md-code-inline">app.js</code> file.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import Router from <span class="md-code-string">&apos;react-router&apos;</span>;
</code></pre> <p>We&#x2019;ll now defer routing to <code class="md-code md-code-inline">react-router</code> instead of <em>routing at the Express level</em>, using <code class="md-code md-code-inline">app.get</code> and the like. If you&#x2019;re following along in code, get rid of the <code class="md-code md-code-inline">app.get(&apos;/&apos;, function...)</code> piece, and also slash the <code class="md-code md-code-inline">import</code> statement for <code class="md-code md-code-inline">App</code>. We&#x2019;re going to implement <a href="http://expressjs.com/guide/using-middleware.html" target="_blank" aria-label="Using Express middleware">a middleware method</a> for Express that will handle routing on its behalf.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">app.use(router);
</code></pre> <p>The <code class="md-code md-code-inline">router</code> method is displayed below. It creates a routing context using <code class="md-code md-code-inline">react-router</code> and the request&#x2019;s <code class="md-code md-code-inline">req.url</code>. <code class="md-code md-code-inline">react-router</code> will figure out the component that should be rendered for that particular <code class="md-code md-code-inline">location</code>, and we&#x2019;ll get that back as a <code class="md-code md-code-inline">Handler</code>. We can then leverage JSX to render the <code class="md-code md-code-inline">&lt;Handler /&gt;</code> using <a href="https://facebook.github.io/react/docs/top-level-api.html#react.rendertostring" target="_blank" aria-label="React.renderToString() documentation"><code class="md-code md-code-inline">React.renderToString</code></a>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">router</span> <span class="md-code-params">(req, res, next)</span> </span>{
  <span class="md-code-keyword">var</span> context = {
    <mark class="md-mark md-code-mark">routes: routes</mark>, location: req.url
  };
  Router.create(context).run(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">ran</span> <span class="md-code-params">(Handler, state)</span> </span>{
    res.render(<span class="md-code-string">&apos;layout&apos;</span>, {
      reactHtml: React.renderToString(<span><span class="md-code-tag">&lt;<span class="md-code-title">Handler</span> /&gt;</span>)
    });
  });
}
</span></code></pre> <p><sub><mark class="md-mark">*</mark> <em>More on these in a moment!</em></sub></p> <p>Note how this method is component-agnostic, as it should be able to figure out what component to render based on all the <code class="md-code md-code-inline">routes</code> that we have and the <code class="md-code md-code-inline">location</code> the human is trying to visit. This helps us decouple the web application from our React components for good.</p> <h2 id="defining-your-routes">Defining Your Routes</h2> <p>How does the <code class="md-code md-code-inline">routes</code> object look like? It should be a module, because you&#x2019;ll also be leveraging the exact same module in your client-side code so that routing stays consistent. Fair enough, let&#x2019;s add the <code class="md-code md-code-inline">import</code> statement.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import routes from <span class="md-code-string">&apos;./routes&apos;</span>;
</code></pre> <p>How should the module actually look like? Something like this, maybe? As you can see, the route definitions for <code class="md-code md-code-inline">react-router</code> leverage JSX to declare <strong>a nested route hierarchy</strong>. We only have one route, though.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import {Route} from <span class="md-code-string">&apos;react-router&apos;</span>;
import HomeIndex from <span class="md-code-string">&apos;./components/home/index&apos;</span>;

export <span class="md-code-keyword">default</span> (
  <span><span class="md-code-tag">&lt;<span class="md-code-title">Route</span> <span class="md-code-attribute">path</span>=<span class="md-code-value">&apos;/&apos;</span> <span class="md-code-attribute">handler</span>=<span class="md-code-value">{HomeIndex}</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">Route</span>&gt;</span>
);
</span></code></pre> <p>Except that, <em>most of the time</em>, you&#x2019;ll have pieces of your app <strong>outside of routing</strong> &#x2013; your navigation, sidebars and whatnot. In order to <em>future-proof</em>, you&#x2019;re better off defining an <code class="md-code md-code-inline">&lt;App /&gt;</code> component as well. Consider the following mockup from the <code class="md-code md-code-inline">react-router</code> documentation, which illustrates the point well enough.</p> <p><img alt="A mockup of an application with a top navigation bar and a dashboard" class="" src="https://i.imgur.com/5Vkx3Tm.png"></p> <p>It&#x2019;ll be useful to wire up an <code class="md-code md-code-inline">&lt;App /&gt;</code> component where we can at a later point add some navigation elements. Let&#x2019;s start with the changes to the <code class="md-code md-code-inline">router.js</code> module. You just need to also import the <code class="md-code md-code-inline">components/app</code> component, and change the routing definition.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import {Route<mark class="md-mark md-code-mark">, DefaultRoute</mark>} from <span class="md-code-string">&apos;react-router&apos;</span>;
<mark class="md-mark md-code-mark">import App from <span class="md-code-string">&apos;./components/app&apos;</span>;</mark>
import HomeIndex from <span class="md-code-string">&apos;./components/home/index&apos;</span>;

export <span class="md-code-keyword">default</span> (
  <span><span class="md-code-tag">&lt;<span class="md-code-title">Route</span> <span class="md-code-attribute">path</span>=<span class="md-code-value">&apos;/&apos;</span> <span class="md-code-attribute">handler</span>=<span class="md-code-value">{App}</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title"><mark class="md-mark md-code-mark">DefaultRoute</mark></span> <span class="md-code-attribute">handler</span>=<span class="md-code-value">{HomeIndex}</span> /&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">Route</span>&gt;</span>
);
</span></code></pre> <p>The <code class="md-code md-code-inline">&lt;DefaultRoute /&gt;</code> is used when the parent route&#x2019;s <code class="md-code md-code-inline">path</code> is matched exactly. So when the human navigates to <code class="md-code md-code-inline">/</code>, <code class="md-code md-code-inline">&lt;HomeIndex /&gt;</code> will be rendered.</p> <p>Now that our routing is wrapped within the <code class="md-code md-code-inline">&lt;App /&gt;</code> component, you can place shared functionality and markup in that component <em>(like we said earlier &#x2013; navigation and whatnot)</em>. For the time being though, our <code class="md-code md-code-inline">components/app.js</code> file is almost an empty component. The relevant code is highlighted.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>
import {RouteHandler} from <span class="md-code-string">&apos;react-router&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-keyword">class</span> App extends React.Component {
  render () {
    <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">&lt;RouteHandler /&gt;</mark>
  }
};
</code></pre> <p>You can think of <code class="md-code md-code-inline">&lt;RouteHandler /&gt;</code> as <em>&#x201C;nesting continues here&#x201D;</em>. In other words, whenever you have a React component rendered using <code class="md-code md-code-inline">react-router</code>, it&#x2019;ll be rendered at <code class="md-code md-code-inline">&lt;RouteHandler /&gt;</code> in its <em>parent route&#x2019;s</em> component. See <a href="https://github.com/rackt/react-router/blob/0.13.x/docs/guides/overview.md" target="_blank" aria-label="Architecture Overview for react-router">the documentation</a> if I lost you on that one.</p> <p>Continuing with the example about a human visiting <code class="md-code md-code-inline">/</code>, the <code class="md-code md-code-inline">react-router</code> will render <code class="md-code md-code-inline">{HomeIndex}</code>, and then jump to the parent route. The parent has an <code class="md-code md-code-inline">{App}</code> handler, so it&#x2019;ll render that and place the result of rendering <code class="md-code md-code-inline">{HomeIndex}</code> inside <code class="md-code md-code-inline">{App}</code>&apos;s <code class="md-code md-code-inline">&lt;RouteHandler /&gt;</code>. It&#x2019;s very straightforward and subtly powerful.</p> <p>React&#x2019;s <code class="md-code md-code-inline">react-router</code> was modeled after the <a href="http://guides.emberjs.com/v1.10.0/routing/defining-your-routes/" target="_blank" aria-label="Defining Your Routes in Ember.js">often-praised Ember router</a>. You can nest your routes as deep as you need to, and you can mix in as many components as needed too. All your routing needs are now covered by <code class="md-code md-code-inline">routes.js</code>.</p> <blockquote> <p>But, wait! What about client-side routing to match?</p> </blockquote> <p>There isn&#x2019;t much else that needs to be done on the client-side to match your server-side <code class="md-code md-code-inline">react-router</code> routes. Let&#x2019;s go back to what we used to have. As you probably guessed, references to your old <code class="md-code md-code-inline">&lt;App /&gt;</code> will now be removed in favor of our newfound routing capabilities.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react/addons&apos;</span>;
<mark class="md-mark md-code-mark">import App from <span class="md-code-string">&apos;../../components/app&apos;</span>;</mark>
<span class="md-code-keyword">var</span> main = <span class="md-code-built_in">document</span>.getElementsByTagName(<span class="md-code-string">&apos;main&apos;</span>)[<span class="md-code-number">0</span>];

React.render(<mark class="md-mark md-code-mark">&lt;App /&gt;</mark>, main);
</code></pre> <p>We&#x2019;ll be once again pulling in the <code class="md-code md-code-inline">react-router</code> as well as reusing the <code class="md-code md-code-inline">routes.js</code> module we&#x2019;ve defined for the server-side, one directory up. Instead of rendering <code class="md-code md-code-inline">&lt;App /&gt;</code> directly like we used to, we&#x2019;re going to defer to the wisdom of <a href="https://github.com/rackt/react-router" target="_blank" aria-label="rackt/react-router on GitHub"><code class="md-code md-code-inline">react-router</code></a> to tell us what component should be rendered. You can specify whether you want the router to work through hashes like <code class="md-code md-code-inline">#/foo/bar</code> <em>(the default)</em>, or via the <a href="https://developer.mozilla.org/en-US/docs/Web/API/History" target="_blank" aria-label="History API documentation on MDN"><code class="md-code md-code-inline">history</code> API</a> &#x2013; by specifying the use of <code class="md-code md-code-inline">Router.HistoryLocation</code> explicitly.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react/addons&apos;</span>;
import Router from <span class="md-code-string">&apos;react-router&apos;</span>;
import routes from <span class="md-code-string">&apos;../routes&apos;</span>;
<span class="md-code-keyword">var</span> main = <span class="md-code-built_in">document</span>.getElementsByTagName(<span class="md-code-string">&apos;main&apos;</span>)[<span class="md-code-number">0</span>];

Router.run(routes, <mark class="md-mark md-code-mark">Router.HistoryLocation</mark>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">ran</span> <span class="md-code-params">(Handler, state)</span> </span>{
  React.render(<mark class="md-mark md-code-mark">&lt;Handler /&gt;</mark>, main);
});
</code></pre> <p>We&#x2019;re done. You should now understand how to handle routing in your brand new React app, how to get that working on both the server-side and the client-side without having to make changes in multiple places, and how to leverage nesting so that you can add some navigation or layout to your app from within a React component.</p> <blockquote> <p>This is fun stuff!</p> </blockquote></div>
