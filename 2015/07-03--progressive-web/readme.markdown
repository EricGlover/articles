<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/progressive-web">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/progressive-web"><div></div></a>

<h1><p>The Progressive Web</p></h1>

<p><kbd>progressive-enhancement</kbd> <kbd>taunus</kbd> <kbd>server-first</kbd> <kbd>browserify</kbd></p>

<blockquote><p>I&#x2019;ve blogged very little about <a href="https://github.com/taunus/taunus" target="_blank">Taunus</a> since I first released it, <a href="https://ponyfoo.com/articles/taunus-micro-isomorphic-mvc-framework">roughly a year ago</a>. Back then, <em>it only powered <a href="https://ponyfoo.com/">ponyfoo.com</a></em>, but now there&#x2019;s a few cases in &#x2026;</p></blockquote>

<div><p>I&#x2019;ve blogged very little about <a href="https://github.com/taunus/taunus" target="_blank">Taunus</a> since I first released it, <a href="https://ponyfoo.com/articles/taunus-micro-isomorphic-mvc-framework">roughly a year ago</a>. Back then, <em>it only powered <a href="https://ponyfoo.com/">ponyfoo.com</a></em>, but now there&#x2019;s a few cases in the wild where it&#x2019;s being used, and I even got to do some consulting in a project where they&#x2019;re using Taunus! In the year since its release, it has had <a href="https://www.npmjs.com/package/taunus" target="_blank">a whooping 174 releases</a>, but not a whole lot has changed, and its API has remained stable for the most part. Its feature-set grew quite a bit, although it remains fairly light-weight at <code class="md-code md-code-inline">18.8kB</code> after gzip and minification. Today, it&#x2019;s able to figure out how to <a href="https://github.com/taunus/formium" target="_blank">submit forms via AJAX automatically</a>, as long as they already work as plain HTML, and it has support for <em>WebSockets</em> <a href="https://github.com/taunus/skyrocket" target="_blank">via a plugin</a>.</p></div>

<div></div>

<div><p>If I were to define Taunus in <em>&#x201C;elevator pitch&#x201D;</em> style, I would say:</p> <blockquote> <p>Taunus is the logical step forward after server-side MVC web frameworks such as Rails or <a href="http://asp.net/" target="_blank">ASP.NET</a> MVC. It turns server-side rendered apps in Node.js <em>(or io.js?)</em> into single-page applications after the initial page load by hijacking link clicks, form submissions, and defining a format you can leverage for realtime communications.</p> </blockquote> <p>Building an app in <a href="https://ponyfoo.com/articles/server-first-apps">a Server-First fashion</a> is important because then you aren&#x2019;t taking <a href="https://remysharp.com/2015/07/02/assumptions" target="_blank">a huge leap of faith in assuming</a> that your customers have a browser capable of supporting all the <strong>bleeding edge features</strong> your dedicated client-side application demands.</p> <p>After the <strong>initial load</strong>, which <strong>should be blazing fast</strong> so that your customers are happier <em>(tons of <a href="http://blog.codinghorror.com/speed-still-matters/" target="_blank">research</a> point to <a href="https://ponyfoo.com/articles/critical-path-performance-optimization">this fact</a>)</em>, you can should turn to a single page application, hijacking links, making AJAX requests that ask for the bare minimum <em>(view models)</em> and then rendering those view models directly in the client-side.</p> <h1 id="why-server-first-matters">Why Server-First Matters</h1> <p><em>Server-First</em> matters because it&#x2019;s the exact opposite of <a href="https://ponyfoo.com/articles/stop-breaking-the-web">breaking the web</a>. You establish a bare minimum experience that you know most people can access, <a href="https://adactio.com/journal/9206" target="_blank">a baseline</a>, and you go from there. This baseline isn&#x2019;t just there for SEO purposes or to be more amicable to people turning off JavaScript.</p> <p>Think of the ways in which your app is shared on the web. What other places is it rendered to? Services that crawl around it. With client-side rendering, Twitter and Facebook display a pile of garbage instead of <em>descriptive metadata and a thumbnail</em> whenever someone links to your site. Humans might think your site is bogus and not even click on links leading to it, because the description on their Facebook feed just shows a bunch of <a href="https://mustache.github.io/" target="_blank">Mustache templates</a> and gibberish.</p> <p>Search engines other than Google are <strong>completely oblivious to your content</strong>. Even Google is not as good at crawling client-side rendered apps as you think they are. Often times, <em>you also get penalized</em> for not being fast enough.</p> <p><strong>Mobile performance degrades substantially</strong> in client-side rendered applications as opposed to those server-side rendered. Both because the connection is slower, and because the scripts you depend on to actually render your site take a long time to download. When they do, mobile devices take longer to parse them and execute them, because they&#x2019;re not as powerful as the Mac Book Pro you use during development.</p> <p><img src="https://i.imgur.com/EfS2ijh.png" alt="Demand Progress!"></p> <p>Not doing server-side rendering might be <strong>just as bad</strong> as not designing a website to be responsive.</p> <blockquote> <p>It&#x2019;s <em>about time</em> we <code class="md-code md-code-inline">.shift()</code> <em>&quot;SEO purposes and <code class="md-code md-code-inline">&lt;noscript&gt;</code>&quot;</em> from our list of <strong>excuses</strong> for not doing server-side rendering anymore.</p> </blockquote></div>

<div><h1 id="productivity-then">Productivity, Then?</h1> <p>In a sense, it&#x2019;s <em>all about perceived productivity</em>. If you pause and think about it, we&#x2019;ve made the shift towards client-side rendering because it&#x2019;s <em>&#x201C;more productive&#x201D;</em>. That&#x2019;s why the whole &#x201C;no-backend&#x201D; approach even exists. If we ignore the <em>poorly named</em> &#x201C;Offline First&#x201D; philosophy for a minute, <em>&#x201C;hey, you can implement this in under five minutes and not even have to spin up a server instance!&#x201D;</em> sounds like a reasonable goal.</p> <p>But in reality, how much more productive are using Angular than using something else? What is productivity, really? Is it about saving time, keystrokes? Or is it about standing back, taking a walk, and being able to think a problem through and come up with a solution? Because, let&#x2019;s face it, some of our most productive engineering sessions <strong>happen while we&#x2019;re in the shower</strong>, not due to saving precious milliseconds with our over-engineered build systems <em>(where we actually spend more time than we used to, ironically)</em>.</p> <p>We surely aren&#x2019;t all just building <em>throw-away prototypes</em>, are we? And even when we do, we are definitely <strong>throwing them away</strong>, since that&#x2019;s what they&#x2019;re for. Right?</p> <p>In the complex world of front-end development that exists today, why are we even bothering to learn complicated domain languages in order to do something that&#x2019;s detrimental to the web platform? You could argue it&#x2019;s more productive, sure.</p> <p>Productivity only takes you so far, though. There are lots of frameworks out there, and while developing in Angular might be confusingly fun, you don&#x2019;t really take away a lot from it. There&#x2019;s all these complicated abstractions that don&#x2019;t translate very well when you try to move on and use something else. I can almost hear somebody complaining just about now, &#x201C;Angular&#x2019;s not that hard&#x201D;.</p> <blockquote> <p>Sure, it&#x2019;s not. But <em>ask yourself</em>, when are you going to ever come across things like <strong>directives, transclusion, isolated scopes</strong>, and factory service value providers that return a single integer?</p> </blockquote> <p>You gain very little by specializing in Angular, because once the technology moves on, you&#x2019;ll have a harder time adapting, since you&#x2019;ll have to peel back many layers of abstraction until you can get back out to the real world.</p> <h1 id="what-is-taunus-1">What is <a href="https://taunus.bevacqua.io/" target="_blank" aria-label="Taunus documentation site">Taunus</a>?</h1> <p>Taunus latches onto Express or Hapi and lays out a few conventions <em>(which you can configure as per the <a href="https://en.wikipedia.org/wiki/Convention_over_configuration" target="_blank" aria-label="Wikipedia definition">&#x201C;Convention over Configuration&#x201D;</a> paradigm)</em>. To get started, you might want to look at the <a href="http://taunus.bevacqua.io/getting-started" target="_blank" aria-label="Getting Started with Taunus">Tutorial in the documentation</a>, or play around with <a href="https://github.com/taunus/giffy.club" target="_blank" aria-label="giffy.club on GitHub">giffy.club</a>, a <a href="http://giffy.club/" target="_blank" aria-label="giffy.club">silly site</a> we built to demonstrate how you can use Taunus to build your apps in a way that makes sense from a UX standpoint while still being server-side rendered.</p> <p>Just because you&#x2019;re on an article on Pony Foo, we&#x2019;ll walk over how rendering an article works, since <a href="https://github.com/ponyfoo/ponyfoo" target="_blank" aria-label="ponyfoo/ponyfoo on GitHub">ponyfoo</a> is open-source. First of all, we have a traditional Express application <em>(you can also use Hapi)</em>, with a few routes in it. Then we add a call to <code class="md-code md-code-inline">taunus-express</code> to <em>mount</em> Taunus in the back-end.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">taunusExpress(taunus, app, {
  routes: routes,
  layout: layout,
  getDefaultViewModel: getDefaultViewModel,
  plaintext: {
    root: <span class="md-code-string">&apos;article&apos;</span>, ignore: <span class="md-code-string">&apos;footer,.mm-count,.at-meta&apos;</span>
  },
  deferMinified: production
});
</code></pre> <p>Ignore the rest of the options for now, and let&#x2019;s focus on the <code class="md-code md-code-inline">routes</code> property. This points to a module where the view routes that are used by Taunus are declared. You&#x2019;ll notice <a href="https://github.com/ponyfoo/ponyfoo/blob/34e81b2b676f9e4f7f12f2d3cec2a061aa4796ad/controllers/routes.js#L19" target="_blank" aria-label="The articles/article route">the <em>exported array</em> follows the patterns</a> in Express when it comes to routing, allowing you to use parameters, wildcards, regular expressions, and whatnot. The routes are ultimately used to set up raw Express <code class="md-code md-code-inline">GET</code> routes with all the relevant middleware applied to them. You can also supply any extra middleware of your own, besides the controller which is assumed <em>(although optional)</em>.</p> <p>These routes are kept in a module that exports an array because Taunus comes with a CLI that will be used to translate those Express routes into something the front-end understands. This is an important piece of the puzzle, because it means you don&#x2019;t have to maintain a list of routes for the front-end that&#x2019;s effectively a duplicate of the routes you use to render views in the server-side.</p> <p>The route that we care about is <code class="md-code md-code-inline">/articles/:slug</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">{ route: <span class="md-code-string">&apos;/articles/:slug&apos;</span>, action: <span class="md-code-string">&apos;articles/article&apos;</span> }
</code></pre> <p>This innocent looking route follows a few conventions. Because we indicated that the action is <code class="md-code md-code-inline">articles/article</code>, Taunus comes up with a few expectations, all of which are optional, that is, these files don&#x2019;t <em>necessarily have</em> to exist.</p> <ul> <li>A server-side controller in <code class="md-code md-code-inline">$SERVER_CTRL/articles/article.js</code></li> <li>A view exposed as <code class="md-code md-code-inline">$VIEWS/articles/article.js</code></li> <li>A client-side controller in <code class="md-code md-code-inline">$CLIENT_CTRL/articles/article.js</code></li> </ul> <p>I intentionally used variables like <code class="md-code md-code-inline">$SERVER_CTRL</code> to highlight the fact that all of these <a href="http://taunus.bevacqua.io/api#the-taunusrc-manifest" target="_blank" aria-label="The .taunusrc manifest">directories are configurable</a>.</p> <h1 id="server-side-flow">Server-Side Flow</h1> <p>The general idea in server-side controllers is that you&#x2019;re getting ready to tell Taunus <strong>what</strong> <code class="md-code md-code-inline">action</code> to render and what <code class="md-code md-code-inline">viewModel</code> to use. Pony Foo&#x2019;s <code class="md-code md-code-inline">articles/article</code> action controller ends up populating the <code class="md-code md-code-inline">viewModel</code> property in the response.</p> <p>A controller example can be found below, inspired by the <a href="https://github.com/ponyfoo/ponyfoo/blob/34e81b2b676f9e4f7f12f2d3cec2a061aa4796ad/controllers/author/compose.js" target="_blank" aria-label="The author/compose server-side controller on ponyfoo/ponyfoo">author/compose</a> action. In this example we set the <code class="md-code md-code-inline">viewModel</code> that&#x2019;ll be used but we omit the <code class="md-code md-code-inline">action</code>. That means the <code class="md-code md-code-inline">action</code> will be <em>inferred from the route</em>, just like the server-side controller&#x2019;s location was.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">module</span>.exports = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">article</span> <span class="md-code-params">(req, res, next)</span> </span>{
  res.viewModel = {
    model: {
      articles: [{
        title: <span class="md-code-string">&apos;Stop Breaking the Web&apos;</span>,
        description: <span class="md-code-string">&apos;...&apos;</span>
      }]
    }
  };
  next();
  };
};
</code></pre> <blockquote> <p>Note also how we&#x2019;re using <code class="md-code md-code-inline">next()</code> to fall into <a href="https://github.com/taunus/taunus/blob/a26dcc6b0da926e49f60952aadc093bebef3a933/lib/render.js#L41" target="_blank" aria-label="Taunuses&apos; rendering engine on GitHub">Taunuses&#x2019; rendering engine</a>.</p> </blockquote> <p>Once we&#x2019;ve figured out the <code class="md-code md-code-inline">viewModel</code> and <code class="md-code md-code-inline">action</code>, Taunus will internally determine <strong>how</strong> to render the response, <a href="https://github.com/taunus/taunus/blob/a26dcc6b0da926e49f60952aadc093bebef3a933/lib/render.js#L70-L76" target="_blank" aria-label="The code is pretty easy to follow, taunus/taunus on GitHub">based on request headers and query string</a>. If the request had asked for JSON, then the response is in JSON and it contains the <code class="md-code md-code-inline">viewModel.model</code> for your partial view. If the request had asked for HTML, then the response will be in HTML, and rendered by using the template functions for both the layout and the partial view. When a request asks for plain text, Taunus renders an HTML response and <a href="https://github.com/bevacqua/hget" target="_blank" aria-label="Render websites in plain text from your terminal with hget">figures out the plain text</a>.</p> <p><img alt="This article as a plain text response" class="" src="https://i.imgur.com/6SfH143.png"></p> <p><em><sub>This article can be rendered as plain text in terminal, just use <code class="md-code md-code-inline">curl</code>!</sub></em></p> <p>Following the progression we&#x2019;ve laid out, suppose we are going to be handling the first request made by a browser against <a href="https://ponyfoo.com/articles/random" aria-label="What will it be!?">ponyfoo.com/articles/random</a>. The server-side controller comes into play, decides what the <code class="md-code md-code-inline">viewModel</code> should be, and it also has the ability to change what view should be rendered.</p> <p>Then, <em>the view gets rendered</em>. This is done by compiling the view template and then <a href="https://github.com/ponyfoo/ponyfoo/blob/34e81b2b676f9e4f7f12f2d3cec2a061aa4796ad/views/server/layout/layout.jade#L65" target="_blank" aria-label="Rendering the view within the layout">passing that to the layout function</a> as a plain HTML string <code class="md-code md-code-inline">partial</code>.</p> <h1 id="views-as-pure-functions-in-taunus">Views as Pure Functions in Taunus</h1> <p>Views are expected to be CommonJS modules that export a single method, the view method. Here&#x2019;s an example view method.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">module</span>.exports = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(model)</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-string">&apos;&lt;a href=&apos;</span> + model.url + <span class="md-code-string">&apos;&gt;&apos;</span> + model.title + <span class="md-code-string">&apos;&lt;/a&gt;&apos;</span>;
};
</code></pre> <p>Security terribleness aside, it can be nice that Taunus doesn&#x2019;t make lots of demands about view rendering engines, and instead just asks that you somehow write a <code class="md-code md-code-inline">function(model)</code> that returns an HTML string, and place it in a module at <code class="md-code md-code-inline">$VIEWS/$ACTION_NAME</code>.</p> <p>Of course, expecting you to define your views <em>directly</em> using JavaScript functions is kind of bonkers, as it&#x2019;d be pretty cumbersome and clunky. Fortunately, most templating engines offer the ability to <em>&#x201C;pre-compile&#x201D;</em> your views into JavaScript methods, and export those to files. Thus, you can pick your favorite template engine <em>(granted that it can compile views into JavaScript functions)</em>, and use that to code up your views for Taunus applications.</p> <p>I <em>personally like <a href="http://jade-lang.com/" target="_blank" aria-label="Jade Template Engine">Jade</a></em>, so I use that. The function above could be expressed in a Jade template as follows:</p> <pre class="md-code-block"><code class="md-code md-lang-css">a(href=url)=title
</code></pre> <p>The problem with Jade is that <strong>their compiler inlines entire view templates</strong> when you use the <code class="md-code md-code-inline">include</code> keyword, making compiled views <strong>fat</strong>. I presume this is because Jade strives to not make assumptions about compiled views being <em>related</em> which would mean they&#x2019;d be able to use <code class="md-code md-code-inline">require</code> statements instead of inlining the whole dependency tree. Inlining becomes an issue when you plan to reuse views in a few places, because your views get fat fast and there&#x2019;s a lot of duplicate code in the compiled templates. I made <a href="https://github.com/bevacqua/jadum" target="_blank" aria-label="bevacqua/jadum on GitHub">jadum</a> to solve the duplication issue. It uses <code class="md-code md-code-inline">require</code> statements pointed at other files when you use <code class="md-code md-code-inline">include</code> in your Jade templates. Jadum <em>knows</em> a view doesn&#x2019;t just exist in isolation, but that they are part of a whole and live in the tree structure <code class="md-code md-code-inline">jadum</code> created on your behalf.</p> <p>Why does Taunus want <strong>pure</strong> view functions? Because <em>they offer great simplicity</em>. It&#x2019;s simple for Taunus to use your views in both the server and the client, since these are just functions that you can <code class="md-code md-code-inline">require</code>. This way, Taunus doesn&#x2019;t need to worry about providing its own view engine. There&#x2019;s <strong>plenty</strong> to choose from already.</p> <p>The <a href="https://github.com/ponyfoo/ponyfoo/blob/34e81b2b676f9e4f7f12f2d3cec2a061aa4796ad/views/shared/articles/article.jade" target="_blank" aria-label="articles/article Jade view template for Pony Foo">articles/article.jade template</a> in Pony Foo is compiled into a module <a href="https://github.com/ponyfoo/ponyfoo/blob/34e81b2b676f9e4f7f12f2d3cec2a061aa4796ad/build/build-production#L17" target="_blank" aria-label="Build script for Pony Foo in production">using jadum</a>, and then fed into Taunus. This sounds hard, but <code class="md-code md-code-inline">jadum</code> lets you compile every single template in your app with <a href="https://github.com/ponyfoo/ponyfoo/blob/34e81b2b676f9e4f7f12f2d3cec2a061aa4796ad/build/build-production#L17" target="_blank" aria-label="How is Pony Foo built for production?">a single shell command</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">jadum views/**/*.jade -o .bin --no-debug --obj <span class="md-code-string">&apos;{&quot;basedir&quot;:&quot;views&quot;}&apos;</span>
</code></pre> <p>In Pony Foo, we keep compiled view functions in <code class="md-code md-code-inline">.bin/views</code>, in a tree structure. After Taunus renders a view, it needs to take control of rendering in the client-side, when JavaScript finally loads. This is done in a couple of steps.</p> <h1 id="the-client-side-wiring-module">The Client-Side &#x201C;Wiring&#x201D; Module</h1> <p>First off, we need a build step <a href="http://taunus.bevacqua.io/api#command-line-interface" target="_blank" aria-label="Taunuses&apos; command-line interface documentation">using the Taunus CLI</a> to build out the &#x201C;wiring module&#x201D;. This module is basically a collection of every assumption Taunus is going to make about your app.</p> <p>Here is how the wiring module looks like for Pony Foo <a href="https://gist.github.com/bevacqua/bc169cc641c356ee97d3" target="_blank" aria-label="The wiring module in ponyfoo/ponyfoo when autogenerated by `taunus -o`"><em>(except in reality it&#x2019;s actually a bit larger)</em></a>. It follows the CommonJS module spec by convention, but you may produce a standalone <code class="md-code md-code-inline">&lt;script&gt;</code> version if you&#x2019;re not using Browserify.</p> <p><a href="https://gist.github.com/bevacqua/bc169cc641c356ee97d3" target="_blank" aria-label="The wiring module in ponyfoo/ponyfoo when autogenerated by `taunus -o`"><img alt="A screenshot of Taunuses&apos; client-side wiring module" class="" src="https://i.imgur.com/rIvOCQz.png"></a></p> <p>Why is this file necessary? A couple of reasons. First off, Browserify isn&#x2019;t able to read dynamic <code class="md-code md-code-inline">require</code> statements, <em>unless they&#x2019;re look like <code class="md-code md-code-inline">require(__dirname + &apos;/foo.js&apos;)</code></em>, and you definitely don&#x2019;t want to be typing all of these by hand. Secondly, if you&#x2019;re using Hapi then you can use the <a href="https://github.com/taunus/hapiify" target="_blank" aria-label="taunus/hapiify on GitHub">hapiify transform</a> to convert Hapi routes into something <a href="http://github.com/bevacqua/ruta3" target="_blank" aria-label="bevacqua/ruta3 on GitHub">the front-end router</a> understands. Finally, this file is a clearly defined bridge between your back-end routes and what the front-end is doing.</p> <p>All you have to do to generate the wiring module is run the following command.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">taunus --output
</code></pre> <h1 id="mounting-taunus-in-the-front-end">Mounting Taunus in the Front-End</h1> <p>Once we&#x2019;ve incorporated the wiring module into our build process, we need to <code class="md-code md-code-inline">.mount</code> Taunus in the front-end, just like we did in the back-end <em>(through <code class="md-code md-code-inline">taunus-express</code>)</em>. Mounting <a href="https://github.com/ponyfoo/ponyfoo/blob/34e81b2b676f9e4f7f12f2d3cec2a061aa4796ad/client/js/main.js#L24" target="_blank" aria-label="Mounting ponyfoo/ponyfoo on GitHub">takes a few parameters</a>. It needs a DOM element that exists in your layout where the view should be rendered. It asks for the wiring module we&#x2019;ve just generated. It also has some <code class="md-code md-code-inline">options</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">taunus.mount(main, wiring, { bootstrap: <span class="md-code-string">&apos;manual&apos;</span> });
</code></pre> <blockquote> <p>The <code class="md-code md-code-inline">bootstrap</code> option asks the question: <em>&#x201C;how are you going to get the <code class="md-code md-code-inline">viewModel.model</code> to the client-side view controller on first load?&#x201D;</em></p> </blockquote> <p>Once client-side JavaScript hits, Taunus is mounted on the client, and it starts to hijack link clicks <em>(and <code class="md-code md-code-inline">&lt;form&gt;</code> submissions, unless you&#x2019;ve disabled <a href="https://github.com/taunus/gradual" target="_blank" aria-label="taunus/gradual on GitHub">gradual</a>)</em>. Taunus will also immediately execute the client-side view controller for the current action, if one exists. That&#x2019;s why you need to figure out how to provide the <code class="md-code md-code-inline">model</code>, because the client-side controller might need it!</p> <p>When a link is clicked, instead of navigating away <em>like the web regularly does</em>, Taunus will issue an AJAX request. On the server-side your view controller will generate a view model just like it did the first time, and trust Taunus again to render the appropriate response. Taunus will notice the browser is asking for JSON this time around, <a href="https://ponyfoo.com/articles/progressive-web?json" aria-label="The Progressive Web as JSON">and respond in kind</a>.</p> <p>When the AJAX response gets back to the client-side, Taunus will figure out whether the <code class="md-code md-code-inline">action</code> has been changed by the response, or if it should still use the route&#x2019;s default. Then, Taunus will render said action&#x2019;s view template by passing it the model we just received from the AJAX response. Once it has the view&#x2019;s HTML, it&#x2019;ll simply render it on the DOM element that was passed to <code class="md-code md-code-inline">taunus.mount</code> a while back. Finally, the client-side view controller will be invoked, if one exists, just like on first load.</p> <p>Along the way, Taunus emits events, caches responses <em>(if you want it to)</em>, and ensures the server-side is serving data for the view templates cached in the client-side <em>(otherwise you may want to reload the page because of outdated views in the client)</em>.</p> <h1 id="how-much-does-taunus-assume">How Much does Taunus <em>Assume</em>?</h1> <p>At first, the only assumption Taunus makes is that it can render views for most of the links that point to the current domain. That is, if there&#x2019;s a link to, say, <em><a href="https://ponyfoo.com/articles/first" aria-label="Pony Foo Begins">/articles/first</a></em>, it&#x2019;ll just be a link. Then, when Taunus gets mounted in the client-side, an event handler will be bound to that link. When the link gets clicked, Taunus will check if it matches one of its routes <em>(in this case, it matches the <code class="md-code md-code-inline">/articles/first</code> route)</em>, and if it does, it&#x2019;ll trigger the AJAX mechanism and <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history" target="_blank" aria-label="Manipulating the browser history">use the history API</a> to behave just like a true <strong>single page application</strong>.</p> <p>If the <code class="md-code md-code-inline">history</code> API isn&#x2019;t supported, then Taunus will fall back to setting <code class="md-code md-code-inline">location.href</code>, like in the old days. Sure, it&#x2019;s slower than using hashed routes. But it&#x2019;s more accessible, and it&#x2019;s not like there&#x2019;s that many users in browsers without a functioning <code class="md-code md-code-inline">history</code> API nowadays anyway. The point is that the site will still work if the <code class="md-code md-code-inline">history</code> API isn&#x2019;t there, because <strong>Taunus is an upgrade on top of plainly server-side rendered HTML views</strong>. This is key if we want to provide the baseline we discussed earlier, and we want to make <em>as few assumptions as possible</em> while doing so.</p> <h1 id="what-about-data-binding">What About Data Binding?</h1> <p>Taunus doesn&#x2019;t offer a data binding mechanism out the box <em>(<code class="md-code md-code-inline">skyrocket</code> is such a mechanism, but <a href="https://github.com/taunus/skyrocket" target="_blank" aria-label="taunus/skyrocket on GitHub">it has a rough API</a> at the moment)</em>. Instead, it strongly expects you to rely on the progressive web.</p> <blockquote> <p>The more <strong>progressively</strong> your site is going to be built, the more it makes sense to use Taunus to build it.</p> </blockquote> <p>Let&#x2019;s suppose for a minute that you aren&#x2019;t such a big proponent on data-binding, because you feel sometimes it&#x2019;s too magic, confusing, or just because you got so far into this article, or all of the above. What else could we do to lighten the load on your end while providing a <strong>progressively enhanced</strong> experience where Taunus does the heavy lifting of improving the UX on your behalf <em>while you develop sane plain server-first web apps</em>?</p> <h1 id="gradual-automated-ajax-form-submission">Gradual: Automated AJAX Form Submission</h1> <p>I&#x2019;ve just recently open-sourced <a href="https://github.com/taunus/gradual" target="_blank" aria-label="taunus/gradual on GitHub">gradual</a>. As we strive to simplify the usability of Taunuses&#x2019; API, we&#x2019;ve incorporated it into the core experience. It provides a mechanism to turn regular HTML forms into AJAX.</p> <blockquote> <p>This is powerful because we end up with <strong>a pure SPA</strong> out of <em>just HTML <code class="md-code md-code-inline">&lt;a&gt;</code> and <code class="md-code md-code-inline">&lt;form&gt;</code> tags.</em></p> </blockquote> <p>For <code class="md-code md-code-inline">gradual</code> to behave properly, you need to add support to your back-end so that <code class="md-code md-code-inline">&lt;form&gt;</code> submission responses <em>(these aren&#x2019;t managed by Taunus)</em> use a <code class="md-code md-code-inline">Content-Type</code> of <code class="md-code md-code-inline">text/plain</code> if the request contains <code class="md-code md-code-inline">as-text</code> as a query string parameter. This is due to <code class="md-code md-code-inline">formium</code>, which makes form submissions against an <code class="md-code md-code-inline">&lt;iframe&gt;</code> because it&#x2019;s better than AJAX <em>(you get a loading spinner and form autofill values are persisted in the browser)</em>. Some browsers render <code class="md-code md-code-inline">application/json</code> responses inside <code class="md-code md-code-inline">&lt;pre&gt;&lt;code&gt;</code> tags or even prettier HTML pages, if the human has some sort of browser extension that does that.</p> <p>Gradual also lays out <strong>a few conventions</strong> of its own. See, Taunus is a strong proponent of conventions, as they drastically simplify what you have to do as the implementor. That&#x2019;s why we build sites in this way. You set up an anchor tag, then it becomes an AJAX request that fetches a model, renders a view, and executes a controller. But you don&#x2019;t care about <em>how</em>, you just want it to <em>work</em>. Same goes for <code class="md-code md-code-inline">&lt;form&gt;</code> submissions, you just want them to feel quicker.</p> <p>Forms usually end up in a redirect. Given that you&#x2019;re using Taunus, you&#x2019;re probably using the <a href="http://taunus.bevacqua.io/api#-taunus-redirect-req-res-url-options-" target="_blank" aria-label="Check out the taunus.redirect documentation">taunus.redirect</a> API in the server-side for all your form redirection needs. That method is just an abstraction that either does an HTTP redirect or responds with a JSON payload that denotes a redirect. If <code class="md-code md-code-inline">gradual</code> receives one such response, it&#x2019;ll make sure to follow the redirect. This is probably the easiest way to handle a form submission&#x2019;s response. You just redirect somewhere else, if it was made by the browser using plain HTML, then the redirect is followed by the browser, and if Taunus made the submission, then the <em>(JSON)</em> redirect is followed by <code class="md-code md-code-inline">gradual</code>.</p> <p>Another <em>very</em> common kind of response is validation. In the traditional web you simply add some messages to the <code class="md-code md-code-inline">session</code> and discard them after one use <em>(a so-called session &#x201C;flash&#x201D;)</em>. Gradual is keen on taking these validation messages from <a href="https://github.com/taunus/gradual#custom-validation" target="_blank" aria-label="Custom validation in Gradual documentation on GitHub">a variety of places</a> in your response and displaying them accordingly.</p> <p>So what is it you should do in a server-side controller that handles a form submission?</p> <ul> <li>Flash via session</li> <li>Redirect via Taunus</li> </ul> <p>Taunus will then grab the flash messages <em>(if any)</em> and display them using the <code class="md-code md-code-inline">partials/form-validation</code> view template.</p> <h1 id="realtime-communication-with-skyrocket">Realtime Communication with Skyrocket</h1> <p>Here is where things get really interesting. It takes some setup <em>(we&#x2019;re definitely <strong>trying</strong> to make this one simpler)</em>, but when you do set it up, <strong>it&#x2019;s pretty awesome</strong>.</p> <p>The idea is that a form submission can end up in a view update, instead of a full redirect, because even if the redirect goes through Taunus, it <em>still has to hit the server again</em>. In <code class="md-code md-code-inline">skyrocket</code> we came up <a href="https://github.com/taunus/skyrocket#skyrocket-schema" target="_blank" aria-label="The Skyrocket realtime update schema on GitHub">with a schema</a> where you&#x2019;re able to respond with <code class="md-code md-code-inline">model</code> updates you want to apply to a <code class="md-code md-code-inline">model</code>, or <em>operations</em> you want to apply to a certain <em>path</em> on the <code class="md-code md-code-inline">model</code>.</p> <p>Consider for example the following response:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">{
  updates: [{
    rooms: [<span class="md-code-string">&apos;/issues/34&apos;</span>],
    model: {
      title: <span class="md-code-string">&apos;Implement realtime communication via skyrocket&apos;</span>
    },
    operations: [{
      op: <span class="md-code-string">&apos;edit&apos;</span>,
      concern: <span class="md-code-string">&apos;todos.1&apos;</span>,
      model: {
        completed: <span class="md-code-literal">true</span>
      }
    }]
  }]
}
</code></pre> <p>This works in a pretty straightforward manner. If the person getting this response to a form submission that marked a TODO as completed, is listening for events on the <code class="md-code md-code-inline">/issues/34</code> rooms, he gets back an update that will be automatically applied against the model in his view controller. He&#x2019;ll then get a callback where he can re-render parts of the view as he deems necessary. The client-side controller might look like this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> $ = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;dominus&apos;</span>);
<span class="md-code-keyword">var</span> skyrocket = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;skyrocket&apos;</span>);

<span class="md-code-built_in">module</span>.exports = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">controller</span> <span class="md-code-params">(model, container, route)</span> </span>{
  <span class="md-code-keyword">var</span> rocket = skyrocket.scope(container, model);

  rocket.on(<span class="md-code-string">&apos;/issues/34&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">reaction</span> <span class="md-code-params">()</span> </span>{
    <span class="md-code-comment">// the model has been updated at this point</span>
    <span class="md-code-keyword">var</span> todos = $.findOne(<span class="md-code-string">&apos;.todos&apos;</span>, container);
    <span class="md-code-keyword">var</span> action = <span class="md-code-string">&apos;issues/todos&apos;</span>;
    taunus.partial(todos, action, model);
  });
};
</code></pre> <p>That&#x2019;ll be enough to apply changes to the view when the model changes, immediately, as the response comes through, without the need for a redirection. We can also do one better. If you&#x2019;ve configured Skyrocket for realtime, then you&#x2019;re also able to broadcast this update, using <strong>the exact same schema</strong>, to other connected clients interested in the <code class="md-code md-code-inline">/issues/34</code> room <em>(or &#x201C;entity&#x201D;)</em>, and they&#x2019;ll also be able to handle that just as well, because the code is routed through the same handlers, except that the data is getting routed through WebSockets <em>(e.g <code class="md-code md-code-inline">socket.io</code>)</em> in realtime.</p> <p>You don&#x2019;t have magical data binding in Taunus, other than the magical model updates via <a href="https://github.com/taunus/skyrocket" target="_blank" aria-label="Skyrocket on GitHub">Skyrocket</a>, but you do get the ability to easily update portions of your view via WebSocket just by implementing an HTML <code class="md-code md-code-inline">&lt;form&gt;</code> response handler.</p> <p>That&#x2019;s pretty rad.</p> <p><em>P.S: I&#x2019;m running a little survey regarding the content direction in this blog, if you&#x2019;d like to help me with your feedback, <a href="https://docs.google.com/forms/d/1pccaq_Tq0QSGKbP9czdEq0uPbFzthKmBY1Kvkjl2Slc/viewform" target="_blank" aria-label="The survey is on Google Forms">come this way</a>.</em></p></div>
