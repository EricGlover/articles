<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/immutable-npm-dependencies">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/immutable-npm-dependencies"><div><img src="https://i.imgur.com/VxABgaq.jpg" alt="Keeping Your npm Dependencies Immutable"></div></a>

<h1>Keeping Your npm Dependencies Immutable</h1>

<p><kbd>semver</kbd> <kbd>immutability</kbd> <kbd>npm</kbd></p>

<blockquote><p>I&#x2019;ve been bitten a few times by dependencies using semver ranges such as <code>^1.0.1</code> where the dependency introduced a &#x201C;non-breaking&#x201D; change that ended &#x2026;</p></blockquote>

<div><p>I&#x2019;ve been bitten a few times by dependencies using semver ranges such as <code class="md-code md-code-inline">^1.0.1</code> where the dependency introduced a &#x201C;non-breaking&#x201D; change that ended up actually breaking somewhere in the dependency chain because an undocumented feature was being used, a workaround stopped working, and similar undesirable situations.</p></div>

<blockquote></blockquote>

<div><p>In theory, semantic versioning is a great way of keeping our packages up to date all the time, but in reality it&#x2019;s not all peaches and cream. If you or anyone in the dependency chain is relying on an undocumented feature <em>(we shouldn&#x2019;t do this, but it happens)</em> and the package in question changes their internals, or inadvertently introduces a bug <em>(we shouldn&#x2019;t do this, but it happens)</em>, or mistakenly breaks their API <em>(we shouldn&#x2019;t do this, but it happens)</em>, you&#x2019;re screwed.</p> <blockquote> <p>Even if you follow semver strictly someone somewhere up the chain is going to use your code in a way that you&#x2019;ll break.</p> </blockquote> <p>I wrote about this topic <a href="https://ponyfoo.com/articles/semver" aria-label="Pragmatic Semantic Versioning on Pony Foo">a while back</a>, and then again over the past few days on Twitter, but in this case I&#x2019;m arguing that the current model is broken and we should pin dependencies for all the modules, or find a better way of making <code class="md-code md-code-inline">npm</code> users <code class="md-code md-code-inline">shrinkwrap</code> their &#x201C;final&#x201D; packages <em>(like CLI apps or web apps)</em>.</p></div>

<div><h2 id="npm-as-a-platform"><code class="md-code md-code-inline">npm</code> as a Platform</h2> <p>I concede getting bug fixes through quickly is great, but it might be best to leave those things to platforms such as <a href="http://greenkeeper.io/" target="_blank" aria-label="Your software, up to date, all the time.">greenkeeper.io</a> to notify us of updates, so that we can implement them and bump packages up the dependency chain.</p> <p>When it comes to the &quot;but you&#x2019;d have to wait for a fix to <code class="md-code md-code-inline">dep-c</code> until <code class="md-code md-code-inline">dep-b</code> bumps <code class="md-code md-code-inline">dep-c</code>&quot; case, I&#x2019;d argue that <strong><code class="md-code md-code-inline">dep-b</code> is already working with <code class="md-code md-code-inline">dep-c</code></strong>, so why change it? At least <code class="md-code md-code-inline">dep-b</code> wouldn&#x2019;t be <strong>mutable</strong>. If we ignored version ranges, all packages would be immutable and installing them would always yield the same bits of code.</p> <p>Yes, semantic versioning ranges help with the version flattening hell but it&#x2019;s not exactly perfect either, you still end up with several different versions of programs even when you support ranges <em>(less of them, but still)</em>. If we ignored version ranges, we should find better ways to flatten the dependency tree. The way I see it, this is only a problem when using <code class="md-code md-code-inline">browserify</code> with large applications, but not so much in the server-side.</p> <p>In contrast, when <code class="md-code md-code-inline">dep-c</code> or even <code class="md-code md-code-inline">dep-d</code> introduce a bug, we&#x2019;d have to fix <code class="md-code md-code-inline">dep-b</code> and update our dependency on it, or we&#x2019;d be screwed. This means that effectively our package is as safe as the most recent published packages. If we ignored version ranges, we&#x2019;d be in charge of how <code class="md-code md-code-inline">dep-b</code> works, and <strong><code class="md-code md-code-inline">dep-b</code> would always be installed in the exact same way.</strong></p> <h2 id="security">Security</h2> <p>This would also fix the case where a package down the dependency chain &#x201C;goes dark&#x201D; and is silently included into already published, trusted, popular packages. Sure everyone trusts <code class="md-code md-code-inline">express</code>, but what if one of their dependencies deep down the chain suddenly decided to <code class="md-code md-code-inline">publish</code> a version with malicious code in it? It would immediately creep into the user&#x2019;s application.</p> <p>This isn&#x2019;t an easy problem to fix, but if we ignored version ranges, these security flaws wouldn&#x2019;t be automatically included into future installs of modules that were published <strong>before the flaw was introduced</strong>.</p> <h2 id="shrinkwrap">Shrinkwrap</h2> <p>I don&#x2019;t think <a href="https://docs.npmjs.com/cli/shrinkwrap" target="_blank" aria-label="Shrinkwrap API documentation"><code class="md-code md-code-inline">npm shrinkwrap</code></a> is the solution to all of these problems. First, I&#x2019;ve never seen a CLI app in the wild that&#x2019;s shrink-wrapped. That means CLI apps are prone to bugs caused by unexpected dependency updates. To use <code class="md-code md-code-inline">shrinkwrap</code> when distributing CLI apps over <code class="md-code md-code-inline">npm</code> would mean that you also have to decouple those CLI modules from any public API that they expose, as according to the semver logic, you wouldn&#x2019;t want to pin your API dependencies. Of course, decoupling CLI from API is a great idea, but also one only a handful of module authors follow.</p> <p>Second, even with <code class="md-code md-code-inline">shrinkwrap</code> at the application level, suppose somebody develops a perfectly working <code class="md-code md-code-inline">dep-b</code> that depends on <code class="md-code md-code-inline">dep-c</code>, and publishes it. If <code class="md-code md-code-inline">dep-c</code> introduces an unexpected change that would break <code class="md-code md-code-inline">dep-b</code>, those who installed <code class="md-code md-code-inline">dep-b</code> before-hand and have a shrinkwrap handy will be protected. Those who install <code class="md-code md-code-inline">dep-b</code> after <code class="md-code md-code-inline">dep-c</code> introduced its breaking change will have a broken <code class="md-code md-code-inline">dep-b</code>. The tests passed on <code class="md-code md-code-inline">dep-b</code> at publish time, and there&#x2019;s no reason <em>(well, there shouldn&#x2019;t be a reason)</em> for you to be writing unit tests that ensure <code class="md-code md-code-inline">dep-b</code> works as expected. In this sense, semver is comparable to an infectious disease. You didn&#x2019;t have it before, and all was well, but now that you have it you&#x2019;re infecting everyone who comes near you.</p> <p>Third, and really a reiteration of the first point, not a lot of people use <code class="md-code md-code-inline">shrinkwrap</code>. If nobody uses <code class="md-code md-code-inline">shrinkwrap</code>, does it really fix anything? Is the user to blame or should we come up with a better solution that doesn&#x2019;t place the burden on the user?</p> <h2 id="should-we-ditch-version-ranges">Should we Ditch Version Ranges?</h2> <p>A proposal to ignore semver ranges starting in the next major <code class="md-code md-code-inline">npm</code> release might not be as crazy as it sounds. When a range is encountered, the oldest available version in the range could be used instead of the latest. This would effectively <em>&#x201C;turn off&#x201D;</em> version ranges and make <code class="md-code md-code-inline">npm</code> package installations more predictable. Predictability would prevent fringe, hard-to-trace bugs. We can still get fixes by collaborating, using tools like <a href="http://greenkeeper.io/" target="_blank" aria-label="Your software, up to date, all the time.">greenkeeper.io</a>, and finding better solutions for semi-automatic dependency chain updates than semver-style <em>&#x201C;humans are trustworthy!&#x201D;</em> &#x2013; maybe something like the <a href="https://medium.com/greenkeeper-blog/announcing-real-time-dependency-break-detection-for-greenkeeper-4f7558c10d77" target="_blank" aria-label="Announcing &#x201C;Real Time Dependency Break Detection&#x201D; for Greenkeeper">&#x201C;real-time break detection&#x201D;</a> feature in greenkeeper.</p> <blockquote class="twitter-tweet"><p>Best fix to unpredictable/mutable npm installs - Ignore semver ranges in npm@latest - greenkeeper.io all the modules <a href="https://t.co/dtDgAbKtJm">https://t.co/dtDgAbKtJm</a></p>&#x2014; Nicolas Bevacqua (@nzgb) <a href="https://twitter.com/nzgb/status/652208794097815552">October 8, 2015</a></blockquote> <p>I understand that that wouldn&#x2019;t prevent mutability in dependencies that point to git repos, but those aren&#x2019;t as frequent in the wild and are most often found in application-level <code class="md-code md-code-inline">package.json</code>. I don&#x2019;t have any hard data for that last bit, other than my experience with seeing very few <code class="md-code md-code-inline">git+https</code> dependencies in <code class="md-code md-code-inline">package.json</code> manifests in the wild.</p> <p>The biggest problem with this approach is that we&#x2019;d be losing the benefits of semver, and we&#x2019;re already deeply invested in semver as a community, so this is <strong>probably not going to happen</strong> and we&#x2019;ll have to embrace that mutable dependencies are pretty much a fact.</p> <p>Here are some <em>actionable</em> recommendations about what we can do in practice, instead.</p> <h2 id="immutable-dependencies-with-shrinkwrap">Immutable Dependencies with Shrinkwrap</h2> <p>If you are distributing a CLI application and you don&#x2019;t want your users to get unexpected patches that might break the CLI at any time, it&#x2019;s best to pin versions using a <code class="md-code md-code-inline">npm shrinkwrap</code> step and then verifying the CLI works as expected before publishing. The same goes for applications. You should <code class="md-code md-code-inline">shrinkwrap</code> and test applications before deployments to ensure everything is working properly before going to production. That way, you avoid unpleasant surprises down the road.</p> <h3 id="using-npm-shrinkwrap-for-distribution">Using <code class="md-code md-code-inline">npm shrinkwrap</code> for Distribution</h3> <p>The easiest way to pin dependencies with shrinkwrap is adding a <code class="md-code md-code-inline">prepublish</code> step to your <code class="md-code md-code-inline">package.json</code>. This will ensure that before publishing your application, your dependencies are pinned.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">{
  <span class="md-code-string">&quot;scripts&quot;</span>: {
    <span class="md-code-string">&quot;prepublish&quot;</span>: <span class="md-code-string">&quot;npm shrinkwrap&quot;</span>
  }
}
</code></pre> <p>You probably want to omit <code class="md-code md-code-inline">npm-shrinkwrap.json</code> from your git repository, as shrinkwrap is mostly meant to be <em>a release device</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;npm-shrinkwrap.json&quot;</span> &gt;&gt; .gitignore
</code></pre> <p>Note that you should <code class="md-code md-code-inline">shrinkwrap</code> your modules only if you&#x2019;re dealing with an top-level application &#x2013; be it web, a CLI, or something else that&#x2019;s not meant to be consumed by other modules_. If we&#x2019;re talking about a CLI, that means you probably want to split the CLI itself from the API that powers it, and shrinkwrap only the CLI. The reason for that is that its API might be intended to be consumed as a library by other modules.<br> If anything, keeping your CLI separated from the API that powers it is a good practice and you should be doing that anyways!</p> <blockquote> <p>Thanks to <a href="https://twitter.com/ljharb" target="_blank" aria-label="@ljharb on Twitter">Jordan Harband</a> for reviewing drafts of this article.</p> </blockquote></div>
