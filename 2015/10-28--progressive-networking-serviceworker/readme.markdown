<div></div>

<h1>ServiceWorker and Progressive Networking</h1>

<p><kbd>serviceworker</kbd> <kbd>progressive-networking</kbd></p>

<blockquote><p>I&#x2019;ve been toying with <a href="https://ponyfoo.com/articles/serviceworker-revolution" aria-label="ServiceWorker: Revolution of the Web Platform on Pony Foo"><code>ServiceWorker</code></a> for a while. The single most complicated issue when it comes to <code>ServiceWorker</code> has been dealing with caching in a &#x2026;</p></blockquote>

<div><p>I&#x2019;ve been toying with <a href="https://ponyfoo.com/articles/serviceworker-revolution" aria-label="ServiceWorker: Revolution of the Web Platform on Pony Foo"><code class="md-code md-code-inline">ServiceWorker</code></a> for a while. The single most complicated issue when it comes to <code class="md-code md-code-inline">ServiceWorker</code> has been dealing with caching in a straightforward way. In <a href="https://ponyfoo.com/articles/serviceworker-revolution" aria-label="ServiceWorker: Revolution of the Web Platform on Pony Foo">my previous article</a> &#x2013; an introduction to <code class="md-code md-code-inline">ServiceWorker</code> &#x2013; I wrote about a few different strategies: hitting the network first, hitting the cache first, and hitting the cache but going to the network nevertheless to get <em>&#x201C;eventually fresh&#x201D;</em> content. The last one I mentioned was hitting the cache, going to the network nevertheless, and somehow using <code class="md-code md-code-inline">postMessage</code> to relay updates back to web pages showing stale content. In this article, we&#x2019;ll explore how to communicate from a <code class="md-code md-code-inline">ServiceWorker</code> to a web page and back.</p></div>

<div></div>

<div><p>This article expands on my newfound experience in dealing with stale cached content in a <code class="md-code md-code-inline">ServiceWorker</code>. A follow-up article will contain details on how these communication channels can be laid out, while this one mostly discusses the strategies while relying upon <a href="https://github.com/bevacqua/swivel" target="_blank" aria-label="bevacqua/swivel on GitHub"><code class="md-code md-code-inline">swivel</code></a>, a message passing library I made that simplifies communication between <code class="md-code md-code-inline">ServiceWorker</code> and its clients.</p></div>

<div><h1 id="progressive-networking">Progressive Networking</h1> <p>I firmly believe the <a href="https://ponyfoo.com/articles/serviceworker-revolution#cached-then-network-and-postmessage" aria-label="Cached then Network and postMessage - ServiceWorker: Revolution of the Web Platform on Pony Foo">&quot;Cached then Network and <code class="md-code md-code-inline">postMessage</code>&quot;</a> strategy I published earlier is one of the best approaches to leveraging <code class="md-code md-code-inline">ServiceWorker</code>.</p> <p>The killer feature in <code class="md-code md-code-inline">ServiceWorker</code> is offline &#x201C;first&#x201D; &#x2013; even if I&#x2019;d strongly prefer calling it something else, like <strong>progressive networking</strong> or whatever. It&#x2019;s not really offline <em>&#x201C;first&#x201D;</em>, because ServiceWorker has to be installed, thus JavaScript has to run. That means server-side rendering on initial page load is still just as important, and it also means there&#x2019;s nothing <em>&#x201C;first&#x201D;</em> about offline first. <code class="md-code md-code-inline">&lt;/rant&gt;</code></p> <p>As <a href="https://ponyfoo.com/articles/serviceworker-revolution#cached-then-network-and-postmessage" aria-label="Cached then Network and postMessage - ServiceWorker: Revolution of the Web Platform on Pony Foo">Jake Archibald</a> often insists on, going to the network first may result in <em>a very poor experience</em> for clients with very low connectivity that are nevertheless considered to be &#x201C;online&#x201D; by web browsers &#x2013; even though they&#x2019;re barely able to download any content. Timeouts are a very poor solution to the <em>&#x201C;barely online&#x201D;</em> issue, and serving whatever content we have in the cache immediately is a way better alternative. After all, the &#x201C;instant&#x201D; aspect is what makes <strong>progressive networking</strong> a killer feature. The simple explanation is that that&#x2019;s what happens in native apps, and what humans have eventually come to expect in mobile browsers <em>(and will soon come to expect from desktop applications as well, because transitivity)</em>.</p> <h1 id="updating-stale-cached-content">Updating Stale Cached Content</h1> <p>If we want to be strict about progressive networking, that means we&#x2019;re always going to hit the cache, and if there&#x2019;s a hit we&#x2019;re going to serve that. No matter what. Anything, immediately. Way better than the right stuff, but later. The problem, then, is that the cached content may be stale. The strategy I proposed last week was as follows.</p> <ul> <li>Query the cache, if we hit something, return that immediately</li> <li>Query the network, even if the cache was hit <ul> <li>Use the network response if the cache was a miss</li> <li><mark class="md-mark">Notify clients about the updated content if the cache was a hit</mark></li> </ul> </li> </ul> <p>Today I want to focus on that last bullet point.</p> <p>First, we probably need to decide what warrants an update. Unfortunately, that&#x2019;s mostly application-specific. For example, an image editing website may consider images to be critical content and would thus like to update images whenever they&#x2019;re revalidated in the <code class="md-code md-code-inline">ServiceWorker</code> cache. In the case of this measly blog, as a case study, the content that changes most frequently are comments, and occasionally articles are edited, too.</p> <blockquote> <p>The single most important thing we should update in most applications is <strong>views</strong>. Unfortunately, the mechanism for doing that is application-specific <em>&#x2013; framework-specific at best.</em></p> </blockquote> <p>Suppose a web page fetches a model via JSON through some kind of client-side router, and then renders a view. In our current situation, that&#x2019;d be almost instantaneous if an active <code class="md-code md-code-inline">ServiceWorker</code> had a cached copy of the response to that request. Later, the <code class="md-code md-code-inline">ServiceWorker</code> would get the response from the network and update the cache. By that time, though, our client happily received and rendered the <em>(now stale, maybe)</em> previously cached response.</p> <p>Here&#x2019;s something like what we used to have. The cached response is returned immediately if available, otherwise we return the networked promise. Once the <code class="md-code md-code-inline">fetch</code> response comes through, we store it in the cache.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">queriedCache</span> <span class="md-code-params">(cached)</span> </span>{
  <span class="md-code-keyword">var</span> networked = fetch(request)
    .then(fetchedFromNetwork, unableToResolve)
    .catch(unableToResolve);
  <span class="md-code-keyword">return</span> cached || networked;

  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">fetchedFromNetwork</span> <span class="md-code-params">(response)</span> </span>{
    <span class="md-code-keyword">var</span> cacheCopy = response.clone();
    caches.open(version + <span class="md-code-string">&apos;pages&apos;</span>).then(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span> <span class="md-code-params">(cache)</span> </span>{
      cache.put(request, cacheCopy);
    });
    <span class="md-code-keyword">return</span> response;
  }
}
</code></pre> <p>We need to reconfigure the <code class="md-code md-code-inline">ServiceWorker</code>, letting clients know when a previously cached response has been updated. In the <code class="md-code md-code-inline">fetchedFromNetwork</code> callback we could test to see if <code class="md-code md-code-inline">cached</code> is truthy, whether the request matches our origin, and whether the response is JSON. This is specific to the case study, you might need to filter on something else, as to avoid treating <code class="md-code md-code-inline">GET</code> API calls as &#x201C;view updates&#x201D;. You might also want to check whether the responses are actually different in some way <em>&#x2013; maybe just content length, for instance</em> &#x2013; so you don&#x2019;t waste your clients time.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> url = <span class="md-code-keyword">new</span> URL(request.url);
<span class="md-code-keyword">var</span> json = response.headers.get(<span class="md-code-string">&apos;Content-Type&apos;</span>).indexOf(<span class="md-code-string">&apos;application/json&apos;</span>) !== -<span class="md-code-number">1</span>;
<span class="md-code-keyword">if</span> (cached &amp;&amp; url.origin === location.origin &amp;&amp; json) {
  <span class="md-code-comment">// let the client know we have an updated response</span>
}
</code></pre> <p>A generalized approach such as this is much more effective than trying to modularize these efforts into updates that are specific to particular views or components, as that&#x2019;d involve significant more effort in both implementation and future maintainability. More focused approaches are probably better in terms of UX, and as with all things, user testing is king &#x2013; or, should be. After all, you&#x2019;re reading this because you care about your humans and that they get the content they deserve, fast and fresh.</p> <p>Note also that you should <code class="md-code md-code-inline">.clone</code> another copy of the response for messaging purposes. The original goes to the client, the first copy goes to the cache, and the second one is for reading and passing along to clients looking for updates. How do you pass that along exactly? We&#x2019;ll cover that in the next section, for now we&#x2019;ll just refer to the <a href="https://github.com/bevacqua/swivel" target="_blank" aria-label="bevacqua/swivel on GitHub"><code class="md-code md-code-inline">swivel</code></a> library I made that simplifies and unifies the messaging API.</p> <p>The following bit of code assumes you&#x2019;ve created a copy of the response like <code class="md-code md-code-inline">updateCopy = response.clone()</code>. For performance reasons, it&#x2019;s better to try and extract the logic around figuring out whether you&#x2019;ll actually need to notify clients, as that way you can clone the response only in those cases, reducing strain on the CPU.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> url = <span class="md-code-keyword">new</span> URL(request.url);
<span class="md-code-keyword">var</span> json = response.headers.get(<span class="md-code-string">&apos;Content-Type&apos;</span>).indexOf(<span class="md-code-string">&apos;application/json&apos;</span>) !== -<span class="md-code-number">1</span>;
<span class="md-code-keyword">if</span> (cached &amp;&amp; url.origin === location.origin &amp;&amp; json) {
  <mark class="md-mark md-code-mark">updateCopy.json()</mark>.then(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">parsed</span> <span class="md-code-params">(data)</span> </span>{
    <mark class="md-mark md-code-mark">swivel.broadcast</mark>(<span class="md-code-string">&apos;view-update&apos;</span>, request.url, data);
  });
}
</code></pre> <p>In an ideal world, we&#x2019;d unicast the updated view model to the client who made the request, instead of broadcasting every client, but alas, the mechanism to associate <code class="md-code md-code-inline">fetch</code> requests with specific clients is still a moving part of the <code class="md-code md-code-inline">ServiceWorker</code> specification and hasn&#x2019;t been implemented in browsers yet.</p> <p>On the client-side, the web pages, we can now register a <a href="https://github.com/bevacqua/swivel" target="_blank" aria-label="bevacqua/swivel on GitHub"><code class="md-code md-code-inline">swivel</code></a> event handler for <code class="md-code md-code-inline">view-update</code> that refreshes the view. Again, we&#x2019;ll discuss later how <code class="md-code md-code-inline">swivel</code> works under the hood.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">navigator.serviceWorker
  .register(<span class="md-code-string">&apos;/service-worker.js&apos;</span>)
  .then(navigator.serviceWorker.ready)
  .then(setupMessaging);

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">setupMessaging</span> <span class="md-code-params">()</span> </span>{
  swivel.on(<span class="md-code-string">&apos;view-update&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">renderUpdate</span> <span class="md-code-params">(context, href, data)</span> </span>{
    <span class="md-code-comment">// use data to re-render view</span>
  });
}
</code></pre> <p>When it comes to updating the view, that&#x2019;s up to the implementation. If you&#x2019;re using a framework like React or Taunus, it&#x2019;s a really easy thing to do, you just re-apply the model to the view component and let the framework render that. Updating server-rendered HTML is a bit trickier, as the updated response is also HTML, and the client-side JavaScript probably hasn&#x2019;t been executed yet when the <code class="md-code md-code-inline">fetch</code> response comes through, meaning you&#x2019;ll have to use a different mechanism to update views in this case.</p> <p>A possible solution might be to take the opposite route: have the client ask the <code class="md-code md-code-inline">ServiceWorker</code> for an update from the cache as soon as the client-side JavaScript executes. If your view rendering framework is flexible enough, you could even reuse the <code class="md-code md-code-inline">renderUpdate</code> method by having the <code class="md-code md-code-inline">ServiceWorker</code> reply with an updated JSON view.</p> <p>On the client-side, when the page first loads, you could run the following code, telling the ServiceWorker you want an update on the cached content that was just rendered.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">swivel.emit(<span class="md-code-string">&apos;active-client&apos;</span>, location.href);
</code></pre> <p>The <code class="md-code md-code-inline">ServiceWorker</code> could then listen for these messages and reply with a JSON response for that page.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">swivel.on(<span class="md-code-string">&apos;active-client&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">activeClient</span> <span class="md-code-params">(context, href)</span> </span>{
  caches
    .match(href)
    .then(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(response)</span> </span>{
      <span class="md-code-keyword">return</span> response.json();
    }).then(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(data)</span> </span>{
      <mark class="md-mark md-code-mark">context.reply(<span class="md-code-string">&apos;view-update&apos;</span>, href, data)</mark>;
    });
});
</code></pre> <p>Then the client, in turn, applies the changes to the view as needed. Note that you don&#x2019;t necessarily have to immediately update the view. Even if you&#x2019;re using React or some other virtual DOM powered engine, the UX may be weird if you just update the site, and you may want to consider partially applying updates or even showing a message indicating there&#x2019;s more content, and the human could click that message to get the updates &#x2013; for example. As usual, there&#x2019;s a ton of options here.</p> <p>What do you think would work best in your use case? I&#x2019;d love to hear some opinions on this subject.</p></div>
