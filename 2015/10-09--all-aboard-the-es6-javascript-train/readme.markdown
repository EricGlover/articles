<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/all-aboard-the-es6-javascript-train">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/all-aboard-the-es6-javascript-train"><div><img src="https://i.imgur.com/QWCsOQC.jpg" alt="All Aboard the ES6 JavaScript Train"></div></a>

<h1>All Aboard the ES6 JavaScript Train</h1>

<p><kbd>es6</kbd> <kbd>tutorial</kbd></p>

<blockquote><p>The sixth ECMAScript specification has been <strong>finalized last june</strong>, and there&#x2019;s a flurry of JavaScript features coming our way.</p>
<p>I&#x2019;ll be covering the most exciting new features.</p>
</blockquote>

<div><p>The sixth ECMAScript specification has been <strong>finalized last june</strong>, and there&#x2019;s a flurry of JavaScript features coming our way. You can start using these features today, provided that you know the right set of tools for the job. Today I&#x2019;ll be covering the most exciting new features as well as a couple of different ways how you can get started using them right away.</p></div>

<blockquote></blockquote>

<div><p>Understanding the new language features, and how they can be used, will help you decide whether to adopt ES6 or stay in the ES5 camp. You may want to be on the bleeding edge and consider ES6 a critical addition to the productivity of your team, but it comes at the cost of you and your team learning ES6. To date, no browser has 100% coverage on ES6. The specification is still fresh, and implementations are under active development. Relying solely on JavaScript engines of today means that you&#x2019;ll find many ES6 features work improperly, are only partially implemented, or are completely missing. The solution is to use a transpiler.</p> <p>Transpilation is just a fancy way of saying compilation between similar languages. By using a transpiler to transform ES6 code into ES5, browsers &#x2013; which have great ES5 support nowadays &#x2013; can interpret ES6 without complaining, since you feed them the compiled ES5 code. Transpilers provide a consistent baseline for your ES6 programs, but they aren&#x2019;t perfect. Proxies, for example, are very hard to represent in ES5 code, and are unavailable to transpilers.</p> <p>You can use the online <a href="http://babeljs.io/repl/" target="_blank">Babel REPL</a> to try out the examples in this article. You can write ES6 code on the left, and see the transpiled version change in real-time on the right. It&#x2019;s a treat when it comes to learning ES6! As for developing entire applications in ES6, your best bet is to pair the Babel transpiler with Webpack or Browserify to handle multiple interconnected small modules.</p></div>

<div><h1 id="what-about-es6-and-nodejs">What about ES6 and Node.js?</h1> <p>On the server-side, you <em>(as opposed to your customers when it comes to browsers)</em> are in charge of picking the runtime version. The most recent versions of Node.js have aggressively updated their dependency on <code class="md-code md-code-inline">v8</code>, the JavaScript engine that powers Google Chrome, to the latest and greatest. That means if you&#x2019;re using one of the latest versions of Node.js <em>(<code class="md-code md-code-inline">v4.x.x</code> at the time of this writing)</em>, you have all the same ES6 goodies that are available in your Google Chrome browser.</p> <p>Sometimes you want to keep your existing version of Node.js for most projects but also want to use a recent version because of ES6. In those cases, you can use <a href="https://github.com/creationix/nvm" target="_blank" aria-label="creationix/nvm on GitHub"><code class="md-code md-code-inline">nvm</code></a> to manage multiple versions of Node.js, allowing you to keep your existing projects intact while adopting the latest ES6 features in your newer projects. It&#x2019;s easy to use <code class="md-code md-code-inline">nvm</code>, you just open up a command-line, type commands such as <code class="md-code md-code-inline">nvm install $VERSION</code> or <code class="md-code md-code-inline">nvm use $VERSION</code>, and you&#x2019;re set.</p> <p>Juggling many different versions of <code class="md-code md-code-inline">node</code> may prove to be too much of a hassle to you. An alternative may be to use <code class="md-code md-code-inline">babel-node</code>, a CLI utility that transpiles your ES6 code before executing it through <code class="md-code md-code-inline">node</code>. You can install <code class="md-code md-code-inline">babel-node</code>, along with the standalone Babel transpiler, using the command shown below.</p> <p><code class="md-code md-code-inline">js npm install babel --global</code></p> <p>While <code class="md-code md-code-inline">babel-node</code> works great in development, it&#x2019;s not recommended for production as it can introduce significant lag in startup time. A better approach might be to precompile your modules before every deployment. That way your application won&#x2019;t need to recompile itself at startup.</p> <p><img alt="A babel-node CLI demonstration" class="" src="https://i.imgur.com/m346jQz.png"></p> <p><sub>Using babel-node can add ES6 support to older versions of Node.js. Upgrading to the latest version of Node.js, where possible, is always recommendable.</sub></p> <p>The latest version of the language includes features such as arrow functions, template literals, block scoping, collections, native promises, and many more. I can&#x2019;t possibly cover all of it in one go, but we&#x2019;ll go over my favorites: the most practical.</p> <h2 id="template-literals">Template Literals</h2> <p>In ES6 we get templates that are similar to those in Mustache, but native to JavaScript. In their purest form, they are almost indistinguishable from regular JavaScript strings, except that they use backticks as a delimiter instead of single or double quotes. All the strings found below are equivalent.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>
<span class="md-code-string">&apos;The quick brown fox jumps over the lazy dog&apos;</span>
`The quick brown fox jumps over the lazy dog`
</code></pre> <p>Backticks aren&#x2019;t convenient just because they rarely appear in text. These strings can be multiline without any extra work on your behalf! That means you no longer need to concatenate strings using <code class="md-code md-code-inline">+</code> or join them using an array.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = `This is
  a multi-line
      string.`;
</code></pre> <p>Template literals also let you add variables into the mix by wrapping them in an interpolation, as seen below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> color = <span class="md-code-string">&apos;brown&apos;</span>;
<span class="md-code-keyword">var</span> target = <span class="md-code-string">&apos;lazy dog&apos;</span>;
`The quick ${color} fox jumps over the ${target}`;
<span class="md-code-comment">// &lt;- &apos;The quick brown fox jumps over the lazy dog&apos;</span>
</code></pre> <p>You&#x2019;re not limited to variables, you can interpolate any expression in your templates.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> input = -<span class="md-code-number">10</span>;
<span class="md-code-keyword">var</span> modifier = <span class="md-code-number">2</span>;
`The result of multiplying ${input} by ${modifier} is ${input * modifier}`;
<span class="md-code-comment">// &lt;- &apos;The result of multiplying -10 by 2 is -20&apos;</span>
`The absolute value <span class="md-code-keyword">for</span> ${input} is ${<span class="md-code-built_in">Math</span>.abs(input)}`;
<span class="md-code-comment">// &lt;- &apos;The absolute value for -10 is 10&apos;</span>
</code></pre> <p>Let&#x2019;s move onto a some other practical features.</p> <h2 id="block-scoping-let-and-const">Block Scoping, <code class="md-code md-code-inline">let</code>, and <code class="md-code md-code-inline">const</code></h2> <p>The <code class="md-code md-code-inline">let</code> statement is one of the most well-known features in ES6. It works like a <code class="md-code md-code-inline">var</code> statement, but it has different scoping rules. JavaScript has always had a complicated ruleset when it came to scoping, driving many programmers crazy when they were first trying to figure out how variables work in the language. Declarations using <code class="md-code md-code-inline">var</code> are function-scoped. That means <code class="md-code md-code-inline">var</code> declarations are accessible from anywhere in the function they were declared in. On the other hand, <code class="md-code md-code-inline">let</code> declarations are <em>block.scoped</em>. Block scoping is new to JavaScript in ES6, but it&#x2019;s fairly commonplace in other languages, like Java or C#.</p> <p>Let&#x2019;s look at some of the differences. If you had to declare a variable using <code class="md-code md-code-inline">var</code> in a code branch for an <code class="md-code md-code-inline">if</code>, your code would look like in the following snippet.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sortCoordinates</span> <span class="md-code-params">(x, y)</span> </span>{
  <span class="md-code-keyword">if</span> (y &gt; x) {
    <span class="md-code-keyword">var</span> temp = y;
    y = x;
    x = temp;
  }
  <span class="md-code-keyword">return</span> [x, y];
}
</code></pre> <p>That represents a problem because &#x2013; as we know &#x2013; the process known as hoisting means that the declaration for <code class="md-code md-code-inline">temp</code> will be &#x201C;pulled&#x201D; to the top of its scope. Effectively, our code behaves as if we wrote the snippet below. For this reason, <code class="md-code md-code-inline">var</code> is ineffective when dealing with variables that were meant to be scoped to code branches.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sortCoordinates</span> <span class="md-code-params">(x, y)</span> </span>{
  <span class="md-code-keyword">var</span> temp;
  <span class="md-code-keyword">if</span> (y &gt; x) {
    temp = y;
    y = x;
    x = temp;
  }
  <span class="md-code-keyword">return</span> [x, y];
}
</code></pre> <p>The solution to that problem is using <code class="md-code md-code-inline">let</code>. A <code class="md-code md-code-inline">let</code> declaration is also hoisted to the top of its scope, but its scope is the immediate block (denoted by the nearest pair of brackets), meaning that hoisting won&#x2019;t result in behavior you may not expect or variables getting mixed up.</p> <p>Even though <code class="md-code md-code-inline">let</code> declarations are still hoisted to the top of their scope, attempts to access them in any way before the actual <code class="md-code md-code-inline">let</code> statement is reached will throw. This mechanism is known as the &#x201C;temporal dead zone&#x201D;. Most often than not, this will catch errors in user code rather than represent a problem, though. Attempts to access variables before they were declared usually lead to unexpected behavior when using <code class="md-code md-code-inline">var</code>, so it&#x2019;s a good thing that <code class="md-code md-code-inline">let</code> prevents it entirely.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(there); <span class="md-code-comment">// &lt;- runtime error, temporal dead zone</span>
<span class="md-code-keyword">let</span> there = <span class="md-code-string">&apos;dragons&apos;</span>;
</code></pre> <p>In addition to <code class="md-code md-code-inline">let</code> declarations, we can also observe <code class="md-code md-code-inline">const</code> declarations being added to the language. In contrast with <code class="md-code md-code-inline">var</code> and <code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code> declarations must be assigned to upon declaration.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> pi = <span class="md-code-number">3.141592653589793</span>;
<span class="md-code-keyword">const</span> max; <span class="md-code-comment">// &lt;- SyntaxError</span>
</code></pre> <p>Attempts to assign to a different value to a <code class="md-code md-code-inline">const</code> variable will result in syntax errors, as the compiler is able to tell that you&#x2019;re trying to assign to a <code class="md-code md-code-inline">const</code> variable.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> max = <span class="md-code-number">123</span>;
max = <span class="md-code-number">456</span>; <span class="md-code-comment">// &lt;- SyntaxError</span>
</code></pre> <p>Note that <code class="md-code md-code-inline">const</code> only means that the declaration is a <em>constant reference</em>, but it doesn&#x2019;t mean that the referenced object becomes immutable. If we assign an object to a <code class="md-code md-code-inline">const</code> variable <code class="md-code md-code-inline">client</code>, we won&#x2019;t be able to change <code class="md-code md-code-inline">client</code> into a reference to something else, but we <em>will</em> be able to change properties on <code class="md-code md-code-inline">client</code> like we&#x2019;re used to with other declaration styles.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> client = getHttpClient(<span class="md-code-string">&apos;http://ponyfoo.com&apos;</span>);
client.maxConcurrency = <span class="md-code-number">3</span>;
<span class="md-code-comment">// works because we&apos;re not assigning to client</span>
</code></pre> <h2 id="arrow-functions">Arrow Functions</h2> <p>These are probably the best known feature in ES6. Instead of declaring a function using the <code class="md-code md-code-inline">function</code> keyword, you can use the <em>&#x201C;arrow&#x201D;</em> notation, as seen below. Note how the <code class="md-code md-code-inline">return</code> is implicit, as well as the parenthesis around the <code class="md-code md-code-inline">x</code> parameter.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>].map(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(x)</span> </span>{ <span class="md-code-keyword">return</span> x * <span class="md-code-number">2</span> }); <span class="md-code-comment">// ES5</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>].map(x =&gt; x * <span class="md-code-number">2</span>); <span class="md-code-comment">// ES6</span>
</code></pre> <p>Arrow functions have a flexible syntax. If you have a single parameter you can get away without the parenthesis, but you&#x2019;ll need them for methods with zero, two, or more parameters. Note that you can still use the parenthesis when you have a single parameter, but it&#x2019;s more concise to omit them.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>].map((x, i) =&gt; x * <span class="md-code-number">2</span> + i); <span class="md-code-comment">// &lt;- [2, 5]</span>
</code></pre> <p>If your method does more than return the results of evaluating an expression, you could wrap the right-hand part of the declaration in a block, and spend as many lines as you need. If that&#x2019;s the case, you&#x2019;ll need to add the <code class="md-code md-code-inline">return</code> keyword back again.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">x =&gt; {
  <span class="md-code-comment">// multiple statements</span>
  <span class="md-code-keyword">return</span> result
}
</code></pre> <p>An important aspect of arrow functions is that they are lexically scoped. That means you can kiss your <code class="md-code md-code-inline">var self = this</code> statements goodbye. The example below increases a counter and prints the current value, every second. Without lexical scoping you&#x2019;d have to <code class="md-code md-code-inline">.bind</code> the method call, use <code class="md-code md-code-inline">.call</code>, <code class="md-code md-code-inline">.apply</code>, or the <code class="md-code md-code-inline">self</code> hack we mentioned earlier.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">count</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">this</span>.counter = <span class="md-code-number">0</span>;
  setInterval(() =&gt; <span class="md-code-built_in">console</span>.log(++<span class="md-code-keyword">this</span>.counter), <span class="md-code-number">1000</span>);
}
count(); <span class="md-code-comment">// &lt;- 1, .. 2, .. 3, ...</span>
</code></pre> <p>Arrow functions are recommended for short methods, like those typically provided to <code class="md-code md-code-inline">.map</code> and <code class="md-code md-code-inline">.filter</code> iterators.</p> <h1 id="further-reading">Further Reading</h1> <p>Here are some resources that will help you start taking advantage of ES6 today.</p> <h2 id="es6-in-depth">ES6 in Depth</h2> <p>I wrote <a href="https://ponyfoo.com/articles/tagged/es6-in-depth" aria-label="ES6 in Depth on Pony Foo">a series of over 20 articles</a> that will give you a comprehensive understanding of ES6. Each article covers a specific feature or aspect of the language that changes in ES6, and they&#x2019;re easy to navigate with tons of examples and practical considerations. These articles cover everything we&#x2019;ve discussed so far in this article, in addition to promises, rest and spread, iterators, generators, proxies, collections, changes to <code class="md-code md-code-inline">Math</code>, <code class="md-code md-code-inline">Number</code>, <code class="md-code md-code-inline">Object</code>, and <code class="md-code md-code-inline">String</code>, classes, symbols and reflection. It&#x2019;s a great way to dive head first into ES6.</p> <p><a href="https://ponyfoo.com/articles/tagged/es6-in-depth" aria-label="ES6 in Depth on Pony Foo"><img alt="Screenshot of article headlines on Pony Foo" class="" src="https://i.imgur.com/miWiB6s.png"></a></p> <p><sub>The articles on Pony Foo in the ES6 series cover topics, ranging from getting started to mastering Proxies and Generators.</sub></p> <p>If in-depth series are your thing, you might also want to check out these two resources.</p> <ul> <li>Axel Rauschmayer&#x2019;s <a href="http://www.2ality.com/search/label/esnext" target="_blank" aria-label="Articles tagged esnext on 2ality.com">Blog Posts</a> &#x2013; While he doesn&#x2019;t have a formal series on ES6, he wrote dozens of detailed articles describing the technical depths of ES6.</li> <li><a href="https://hacks.mozilla.org/category/es6-in-depth/" target="_blank" aria-label="ES6 in Depth on Mozilla Hacks">ES6 in Depth</a> by Mozilla Hacks &#x2013; Written by several authors affiliated with Mozilla, it covers many of the same topics as the series on Pony Foo.</li> </ul> <h2 id="ecmascript-6-compatibility-table">ECMAScript 6 Compatibility Table</h2> <p>When you get started with ES6, you&#x2019;ll quickly realize no browser quite supports ES6 100% in their stable distribution and without any flags. In the meantime, you can leverage <a href="http://kangax.github.io/compat-table/es6/" target="_blank" aria-label="ES6 compatibility table by @kangax">these compatibility tables</a> to understand what features are implemented across what browsers. Alas, these tables are mostly useful for research as your best bet when it comes to using ES6 today is to rely on a transpiler like Babel.</p> <h2 id="quick-start">Quick Start</h2> <p>If you want to get started right away, your best bet might be to hop into the <a href="http://babeljs.io/repl/" target="_blank">Babel REPL</a> and start toying around with it. They also have <a href="http://babeljs.io/docs/learn-es2015/" target="_blank" aria-label="A detailed overview of ECMAScript 6 features.">a great article</a> for learning the basics about ES6 language features and syntax.</p></div>
