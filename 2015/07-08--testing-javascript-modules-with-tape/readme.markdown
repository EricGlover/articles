<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/testing-javascript-modules-with-tape">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/testing-javascript-modules-with-tape"><div></div></a>

<h1>Testing JavaScript Modules with Tape</h1>

<p><kbd>tape</kbd> <kbd>proxyquire</kbd> <kbd>sinon</kbd></p>

<blockquote><p>I held a survey last monday where I asked for feedback about the kinds of things you want me to write about. It was quite useful, and one of the topics that seem to &#x2026;</p></blockquote>

<div><p>I held a survey last monday where I asked for feedback about the kinds of things you want me to write about. It was quite useful, and one of the topics that seem to interest quite a few people is regarding module testing. Using <a href="https://github.com/substack/tape" target="_blank">tape</a>, <a href="https://github.com/thlorenz/proxyquire" target="_blank">proxyquire</a>, and <a href="https://github.com/cjohansen/Sinon.JS" target="_blank">sinon</a> is the best possible combination of modules when it comes to testing JavaScript applications, regardless of them being server-side or front-end code.</p></div>

<div></div>

<div><p>In this article well get an in-depth look at these three modules <em>(<a href="https://github.com/substack/tape" target="_blank">tape</a>, <a href="https://github.com/thlorenz/proxyquire" target="_blank">proxyquire</a>, and <a href="https://github.com/cjohansen/Sinon.JS" target="_blank">sinon</a>)</em>, learn why they are better than the competition, how to use them, what each of them is good for, and how they complement each other to provide the ultimate <em>&#x201C;testing harness&#x201D;</em>, figuratively speaking, <strong>no test harness is actually needed!</strong></p> <p>While everything else in the JavaScript universe seems to be moving at blisteringly fast speeds, <em>and accelerating</em>, testing is in this weird place where globals are mystically okay. Frameworks like <a href="https://github.com/mochajs/mocha" target="_blank">mocha</a> and <a href="https://github.com/jasmine/jasmine" target="_blank">jasmine</a> dominate the field, while they require a test harness, <strong>litter the global object with variables</strong>, and generally go against established best practices. I&#x2019;ve always found it kind of <em>really</em> weird that test frameworks, which are supposed to be used to <em>improve the code quality</em> around a codebase, may end up doing the exact same opposite by encouraging the usage of globals and awkward monkey patching.</p> <p>Nevertheless, let&#x2019;s jump into the awesome world of testing with <a href="https://github.com/substack/tape" target="_blank">tape</a>, <a href="https://github.com/thlorenz/proxyquire" target="_blank">proxyquire</a>, and <a href="https://github.com/cjohansen/Sinon.JS" target="_blank">sinon</a>, right after a brief note about the survey I ran last monday.</p> <blockquote> <h2 id="a-quick-note-about-the-survey">A Quick Note About the Survey</h2> <p><strong>Many <em>thanks</em></strong> to everyone who took the time to answer <a href="https://docs.google.com/forms/d/1pccaq_Tq0QSGKbP9czdEq0uPbFzthKmBY1Kvkjl2Slc/viewform" target="_blank">the survey</a>. You gave me a few ideas about the kind of content I could write, and I also got some very useful insight into what people reading this blog enjoy <em>(and dislike)</em> the most.</p> <p>I suppose the results themselves aren&#x2019;t that interesting to anyone that&#x2019;s not myself, but <a href="https://docs.google.com/forms/d/1pccaq_Tq0QSGKbP9czdEq0uPbFzthKmBY1Kvkjl2Slc/viewanalytics" target="_blank">here they are anyways</a>, for the sake of transparency. In general, people would like to learn more best practices, guidelines, code quality, tutorials, and in-depth articles, and not so much about rants.</p> <p><a href="https://docs.google.com/forms/d/1pccaq_Tq0QSGKbP9czdEq0uPbFzthKmBY1Kvkjl2Slc/viewanalytics" target="_blank"><img src="https://i.imgur.com/Dgw2mxI.png" alt="What type of content is liked the most" title="Screen Shot 2015-07-06 at 21.19.30.png"></a></p> <p><em>I&#x2019;ll do my best to keep the rants in check, but keep in mind the tagline of this blog!</em></p> </blockquote></div>

<div><h1 id="a-brief-rant-about-mocha-et-al">A Brief Rant About <em>Mocha</em> et al</h1> <p><a href="https://en.wikipedia.org/wiki/Caff%C3%A8_mocha" target="_blank" aria-label="Caff&#xE8; Mocha on Wikipedia">Mocha coffee</a> is espresso mixed with hot milk, but <em>with added chocolate</em>. Now, I know <a href="https://ponyfoo.com/articles/we-dont-want-your-coffee" aria-label="We don&apos;t want your Coffee">what you must be thinking</a>, but this doesn&#x2019;t have anything to do with coffee. Rather, it&#x2019;s all about the <a href="https://github.com/mochajs/mocha" target="_blank" aria-label="mochajs/mocha on GitHub">mocha</a>. <em>Mocha ain&#x2019;t that good for you either.</em> Suppose you are considering to implement tests in that project of yours at work. <em>*Finally!*</em>, you can hear your superiors whispering. At long last will your project be validated by a battery of tests that can be executed on every build. We&#x2019;ll be able to <a href="http://martinfowler.com/ieeeSoftware/failFast.pdf" target="_blank" aria-label="A random &apos;Fail Fast&apos; article">fail fast</a> by stopping deployments on their tracks <em>whenever a single test fails</em>. Our production systems won&#x2019;t crash as often <em>(hopefully <strong>never</strong> at all)</em>, and code quality overall will improve a thousandfold!</p> <p>There&#x2019;s plenty of testing suites out there, large and small, but in this article we&#x2019;ll have to focus on the small ones, the unit testing libraries of the JavaScript universe. You have a choice to make. You need to pick the systems that will define your application&#x2019;s quality standard from here on out.</p> <p>Faced with this choice, should you pick a framework like Mocha? Let&#x2019;s see.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> should = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;should&apos;</span>);
<span class="md-code-keyword">var</span> personCtrl = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;../controllers/person&apos;</span>);

describe(<span class="md-code-string">&apos;personCtrl&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  it(<span class="md-code-string">&apos;is literally littered with globals everywhere&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
    should(personCtrl.mouth).not.throw(Up);
  });
});
</code></pre> <p>Mocha has plenty of globals like <code class="md-code md-code-inline">describe</code>, <code class="md-code md-code-inline">it</code>, <code class="md-code md-code-inline">beforeEach</code>, <code class="md-code md-code-inline">before</code>, <code class="md-code md-code-inline">after</code>. Evidently, they couldn&#x2019;t make up their mind with regards to assertion flavors, because testers <em>love</em> <a href="https://en.wikipedia.org/wiki/Behavior-driven_development" target="_blank" aria-label="Behavior-driven Development">BDD</a> while developers often prefer <em>precise assertions</em>. It&#x2019;s up to you to pick the assertion engine, you do get the globals though! There&#x2019;s no question about <em>that</em>! One unspoken problem about globals is that they make it that much harder to infer the API for a library just <em>from usage alone</em>. If the API is contained behind a module-wall like <code class="md-code md-code-inline">require(&apos;assert&apos;)</code>, you can at least investigate: <code class="md-code md-code-inline">keys(assert)</code> gives you the API methods <em>(use <code class="md-code md-code-inline">Object.keys</code> outside of the browser console)</em>, and you can do some blind poking. When the API is <strong>a fiery global-spilling ball of death</strong>, it&#x2019;s much harder to tell. Sure, you can poke around the <code class="md-code md-code-inline">global</code> object instead, but why go through the trouble?</p> <blockquote> <p>If <code class="md-code md-code-inline">describe</code>, <code class="md-code md-code-inline">before</code> and <code class="md-code md-code-inline">it</code> are globals, <strong>who knows</strong> what else is a global? Or why the hell <code class="md-code md-code-inline">assert</code> is <em>not one of them</em>?</p> </blockquote> <p>Setting aside the fact that <code class="md-code md-code-inline">should</code> extends the <code class="md-code md-code-inline">Object</code> prototype, there&#x2019;s the whole <em>&#x201C;test harness&#x201D;</em> thing. You need to take some <strong>densely specific steps</strong> in order to be able to actually execute your tests. Want tests to run in the server and the browser? You&#x2019;re going to have <em>a hell of a time!</em></p> <p><img alt="Mocha test runner example" title="Screen Shot 2015-07-08 at 12.01.04.png" class="" src="https://i.imgur.com/KLESZQN.png"></p> <p><sub><em>Running tests via the Mocha test harness in a single, succint command.</em></sub></p> <p>That&#x2019;s enough caff&#xE8; mocha for the day. Let&#x2019;s shift our attention to a pleasant test engine that isn&#x2019;t actually <em>detrimental</em> to the overall code quality in your applications.</p> <h1 id="introducing-tape">Introducing Tape</h1> <p>It&#x2019;s much better to go for a modular testing library, and <a href="https://github.com/substack/tape" target="_blank" aria-label="substack/tape on GitHub">tape</a> fits the bill, so that&#x2019;s what I&#x2019;ve been using for the better part of the last few years.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> test = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;tape&apos;</span>);
<span class="md-code-keyword">var</span> personCtrl = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;../controllers/person&apos;</span>);

test(<span class="md-code-string">&apos;we are the new anti-globalization protest front&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(t)</span> </span>{
  t.doesNotThrow(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
    personCtrl.mouth();
  });
  t.end();
});
</code></pre> <p>Needless to say, you don&#x2019;t <em>have</em> to use <code class="md-code md-code-inline">tape</code>&apos;s built in assertions. You could use <code class="md-code md-code-inline">should</code> <em>(more like shouldn&#x2019;t)</em>, but at least you get <em>a default</em> assertion engine. The <code class="md-code md-code-inline">describe</code> aspect of the <strong>de-facto thousand-line long test file</strong> is translated into making smaller test files that are named just like the module you intend to unit test. <code class="md-code md-code-inline">it</code> becomes <code class="md-code md-code-inline">test</code>, and the only awkward piece of the puzzle is naming <code class="md-code md-code-inline">require(&apos;tape&apos;)</code> <code class="md-code md-code-inline">test</code> instead of <code class="md-code md-code-inline">tape</code>.</p> <p>Of course, you could always just name it <code class="md-code md-code-inline">tape</code> if that weirds you out.</p> <h4 id="how-is-tape-better">How is Tape better?</h4> <p>Besides not endorsing <code class="md-code md-code-inline">global</code> warming, there&#x2019;s a few other differences in how Tape operates. One of them, is how you define your tests. You may have noted that I used <code class="md-code md-code-inline">t.end</code> in my example. That method is used to signal that a test method has ended. If your test is asynchronous, simply call <code class="md-code md-code-inline">t.end</code> in your callback.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> test = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;tape&apos;</span>);
<span class="md-code-keyword">var</span> personCtrl = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;../controllers/person&apos;</span>);

test(<span class="md-code-string">&apos;munching chews 50 times before swallowing a piece of food&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(t)</span> </span>{
  personCtrl.munch(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">munched</span> <span class="md-code-params">(err, result)</span> </span>{
    t.equal(err, <span class="md-code-literal">null</span>);
    t.equal(result.timing.pieces, <span class="md-code-number">1</span>);
    t.equal(result.timing.chewing, <span class="md-code-number">50</span>);
    t.end();
  });
});
</code></pre> <p>Another approach to setting <code class="md-code md-code-inline">t.end</code> might be using <code class="md-code md-code-inline">t.plan(count)</code>. Plan lets you specify how many assertions you expect your test to execute. This comes in handy sometimes, and can double as an extra assertion where you verify that all the other assertions are executed. Note that the test will fail if the count is off even by one, meaning that most of the time going for simply <code class="md-code md-code-inline">t.end</code> will save you the hassle of updating <code class="md-code md-code-inline">t.plan</code> statements with the correct assertion count. That being said, <code class="md-code md-code-inline">t.plan</code> is a useful <em>&#x201C;guard clause&#x201D;</em> when you&#x2019;re unsure whether a callback <em>(presumably containing much needed assertions)</em> will run or not.</p> <p>Tape allows you to quickly turn off tests by changing <code class="md-code md-code-inline">test</code> statements into <code class="md-code md-code-inline">test.skip</code>, which is something that you can do with most test engines.</p> <p>I&#x2019;ve always been baffled about <code class="md-code md-code-inline">before</code>, <code class="md-code md-code-inline">afterEach</code>, and friends. I presume these were copied from mature test frameworks in other languages, but they&#x2019;re largely useless in the dynamic prairie that is JavaScript.</p> <p>You could just replicate those things with a few lines of code, <em>for example:</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">wrapper</span> <span class="md-code-params">(description, fn)</span> </span>{
  test(description, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(t)</span> </span>{
    setup();
    fn(t);
    teardown();
  });
}
</code></pre> <p>Then you could just use <code class="md-code md-code-inline">wrapper</code> instead of <code class="md-code md-code-inline">test</code> for those tests that you want to prepare and then dispose of. This is more transparent than just invoking the <code class="md-code md-code-inline">beforeEach</code> global method inside the <code class="md-code md-code-inline">before</code> and <code class="md-code md-code-inline">it</code> globals and hoping for the best.</p> <p>Given that this is just code and there aren&#x2019;t mystifying globals laying around, you could <em>easily come up with composable modules</em> that are able to, for example, <a href="http://github.com/bevacqua/mongotape" target="_blank" aria-label="bevacqua/mongotape on GitHub">create a MongoDB database and drop it</a> before and after every single test, providing the necessary isolation to individual integration tests.</p> <h4 id="look-ma-no-harness">Look ma, no harness!</h4> <p>Once you&#x2019;re done writing your tests, you can simply execute them using <code class="md-code md-code-inline">node</code>, <em>no harness or test runners involved</em>, imagine that!</p> <pre class="md-code-block"><code class="md-code md-lang-bash">node <span class="md-code-built_in">test</span>/*.js
</code></pre> <p>If you need to run the tests on a browser you could use <a href="https://github.com/substack/testling" target="_blank" aria-label="substack/testling on GitHub">testling</a> after browserifying the test files.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">browserify <span class="md-code-built_in">test</span>/*.js | testling
</code></pre> <p>Testling also offers the ability to run the tests <a href="https://github.com/substack/testling/blob/master/doc/testling_field.markdown" target="_blank" aria-label="Testling package.json configuration documentation">in many different browsers</a> by configuring the <code class="md-code md-code-inline">testling</code> field in your <code class="md-code md-code-inline">package.json</code> file.</p> <h4 id="tap-out-reporters">Tap Out Reporters</h4> <p>Tape produces <code class="md-code md-code-inline">TAP</code> output. <a href="https://testanything.org/" target="_blank" aria-label="TAP: Test Anything Protocol">TAP</a> is a well-defined format that <em>kind of looks like this:</em></p> <pre class="md-code-block"><code class="md-code">1..9
ok 1 concurrent() should return the results as expected
ok 2 map() should return the results as expected
ok 3 waterfall() should run tasks in a waterfall
ok 4 series() should run tasks in a series as array
ok 5 series() should run tasks in a series as object
ok 6 series() should short-circuit on error
ok 7 concurrent() should run tasks concurrently as array
ok 8 concurrent() should run tasks concurrently as object
ok 9 concurrent() should short-circuit on error
# tests 9
# pass 9
# fail 0
1..1
ok 1 Test was run
#TAP meta information
0 errors
</code></pre> <p>Just like Mocha, Tape provides you with a bunch of <a href="https://github.com/substack/tape#pretty-reporters" target="_blank" aria-label="Pretty reporters for Tape">reporters that display fancier output</a> than machine-readable TAP. One of the benefits of the protocol is that you could use these reporters with anything that produces TAP output, not just <code class="md-code md-code-inline">tape</code>.</p> <h1 id="leveraging-proxyquire-to-mock-modules">Leveraging <code class="md-code md-code-inline">proxyquire</code> to mock modules</h1> <p>Besides using test databases, you could also mock services and libraries you don&#x2019;t want to have an influence on the outcome of a particular test. There are plenty of ways of doing this, but I find that the best of them is to grab the dependency by its roots and remove it altogether. The <a href="https://github.com/thlorenz/proxyquire" target="_blank" aria-label="thlorenz/proxyquire on GitHub">proxyquire</a> module makes the process quite easy for both the server and the browser.</p> <p>There are some <a href="https://github.com/buildfirst/buildfirst/tree/master/ch08/05_proxying-your-dependencies" target="_blank" aria-label="Proxying Your Dependencies, Chapter 8, JavaScript Application Design">samples on how to use proxyquire</a> in my book. Suppose you have a module <code class="md-code md-code-inline">./timesTen</code> like the one below:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> multiply = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;./multiply&apos;</span>);

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">timesTen</span> <span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">return</span> multiply(input, <span class="md-code-number">10</span>);
}

<span class="md-code-built_in">module</span>.exports = timesTen;
</code></pre> <p>Suppose also that you want to create some tests for <code class="md-code md-code-inline">./timesTen</code>, but you&#x2019;ve already taken care of tests for <code class="md-code md-code-inline">./multiply</code> in another test file. Thus, you can mock <code class="md-code md-code-inline">./multiply</code> using <code class="md-code md-code-inline">proxyquire</code> in your tests.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> proxyquire = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;proxyquire&apos;</span>);
<span class="md-code-keyword">var</span> test = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;tape&apos;</span>);

test(<span class="md-code-string">&apos;timesTen returns output from multiply&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(t)</span> </span>{
  <span class="md-code-comment">// arrange</span>
  <span class="md-code-keyword">var</span> multiplyStub = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(input)</span> </span>{
    <span class="md-code-keyword">return</span> <span class="md-code-literal">Infinity</span>;
  };
  <span class="md-code-keyword">var</span> timesTen = proxyquire(<span class="md-code-string">&apos;../timesTen&apos;</span>, {
    <span class="md-code-string">&apos;./multiply&apos;</span>: multiplyStub
  });
  
  <span class="md-code-comment">// act</span>
  <span class="md-code-keyword">var</span> result = timesTen(<span class="md-code-number">20</span>);

  <span class="md-code-comment">// assert</span>
  t.equal(result, <span class="md-code-literal">Infinity</span>);
  t.end();
});
</code></pre> <p>Of course, that&#x2019;s <strong>a horrendously simplistic way of testing</strong> something out, but it was also a very contrived example. In the real world you probably want to mock up a service that ends up accessing a database, <strong>Amazon S3</strong>, the <em>Imgur API</em>, or some other external service you really don&#x2019;t want affecting the outcome of your tests. If we&#x2019;re talking about the client-side, even better. You can use <code class="md-code md-code-inline">proxyquire</code> to hide away interaction with the <em>DOM</em>, <em>XHR</em>, <em>WebSockets</em>, <em>or anything</em> that&#x2019;s not pertinent to the test case.</p> <h1 id="complementing-proxyquire-with-sinonjs">Complementing <code class="md-code md-code-inline">proxyquire</code> with Sinon.JS</h1> <p><a href="http://sinonjs.org/" target="_blank" aria-label="Standalone test spies, stubs and mocks for JavaScript">Sinon.JS</a> provides you with many ways in which you can mock objects in JavaScript. While <code class="md-code md-code-inline">proxyquire</code> is the best thing you could be using to replace an entire module with a stub, <code class="md-code md-code-inline">sinon</code> makes it quite easy to <em>create</em> the stubs that you&#x2019;ll be <em>providing</em> to <code class="md-code md-code-inline">proxyquire</code>.</p> <p>For example, suppose a method you want to mock within a module is supposed to end up calling <code class="md-code md-code-inline">done(null, user)</code>. Using <code class="md-code md-code-inline">sinon</code>, that becomes:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> sinon = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;sinon&apos;</span>);
<span class="md-code-keyword">var</span> user = { username: <span class="md-code-string">&apos;ponyfoo&apos;</span>, id: <span class="md-code-number">1234</span> };
<span class="md-code-keyword">var</span> getUser = sinon.stub().yields(<span class="md-code-literal">null</span>, user);
<span class="md-code-keyword">var</span> userService = {
  getUser: getUser
};
</code></pre> <p>Now you can assert that the user is being properly utilized by comparing whatever you get back to the <code class="md-code md-code-inline">user</code> mock you&#x2019;ve defined that <code class="md-code md-code-inline">getUser</code> should yield. Assuming you&#x2019;re consuming the user service from within a controller, the snippet below could very well be a unit test for the controller, where you want to ensure that the response doesn&#x2019;t contain the user&#x2019;s <code class="md-code md-code-inline">id</code> field.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> proxyquire = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;proxyquire&apos;</span>);
<span class="md-code-keyword">var</span> userController = proxyquire(<span class="md-code-string">&apos;../controllers/user&apos;</span>, {
  <span class="md-code-string">&apos;../services/user&apos;</span>: userService
});
userController.prepareModel(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(err, model)</span> </span>{
  t.equal(err, <span class="md-code-literal">null</span>);
  t.equal(model.username, <span class="md-code-string">&apos;ponyfoo&apos;</span>);
  t.notOk(<span class="md-code-string">&apos;id&apos;</span> <span class="md-code-keyword">in</span> model);
  t.end();
});
</code></pre> <p>A user controller that passes the test <em>might look something like the following piece of code.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> userService = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;../services/user&apos;</span>);

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">prepareModel</span> <span class="md-code-params">(done)</span> </span>{
  userService.getUser(<span class="md-code-number">1234</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(err, user)</span> </span>{
    <span class="md-code-keyword">if</span> (err) {
      done(err); <span class="md-code-keyword">return</span>;
    }
    done(<span class="md-code-literal">null</span>, { username: user.username });
  });
}

<span class="md-code-built_in">module</span>.exports = {
  prepareModel: prepareModel
};
</code></pre> <p>Just like it provides an excellent stubbing facility, <code class="md-code md-code-inline">sinon</code> also allows you to spy on callbacks.</p> <h1 id="using-sinon-to-spy-on-callbacks">Using <code class="md-code md-code-inline">sinon</code> to spy on callbacks</h1> <p>You can create a method that&#x2019;s able to tell you how many times it was called, what arguments were used each time, and so on. Suppose that we just want to make sure the user controller calls <code class="md-code md-code-inline">userService.getUser</code> at all. We can write a test like so:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> test = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;tape&apos;</span>);
<span class="md-code-keyword">var</span> sinon = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;sinon&apos;</span>);
<span class="md-code-keyword">var</span> proxyquire = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;proxyquire&apos;</span>);

test(<span class="md-code-string">&apos;userController calls userService.getUser&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(t)</span> </span>{
  <span class="md-code-keyword">var</span> getUser = sinon.spy();
  <span class="md-code-keyword">var</span> userController = proxyquire(<span class="md-code-string">&apos;../controllers/user&apos;</span>, {
    <span class="md-code-string">&apos;../services/user&apos;</span>: { getUser: getUser }
  });

  userController.prepareModel(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{});

  t.equal(getUser.callCount, <span class="md-code-number">1</span>);
  t.end();
});
</code></pre> <p>Just making sure the method was called once might not be enough, but you can also verify the precise arguments that were used.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">t.equal(getUser.firstCall.args[<span class="md-code-number">0</span>], <span class="md-code-number">1234</span>);
t.equal(<span class="md-code-keyword">typeof</span> getUser.firstCall.args[<span class="md-code-number">1</span>], <span class="md-code-string">&apos;function&apos;</span>);
t.end();
</code></pre> <p>At that point you might go the extra mile and invoke the callback yourself. Effectively setting up a <em>&#x201C;step-through&#x201D;</em> right in your test case, as you can control the exact timing with which your callbacks get invoked.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> user = { username: <span class="md-code-string">&apos;ponyfoo&apos;</span>, id: <span class="md-code-number">1234</span> };
getUser.firstCall.args[<span class="md-code-number">1</span>](<span class="md-code-literal">null</span>, user);
</code></pre> <p>All together now:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> test = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;tape&apos;</span>);
<span class="md-code-keyword">var</span> sinon = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;sinon&apos;</span>);
<span class="md-code-keyword">var</span> proxyquire = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;proxyquire&apos;</span>);

test(<span class="md-code-string">&apos;userController calls userService.getUser&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(t)</span> </span>{
  <span class="md-code-keyword">var</span> user = { username: <span class="md-code-string">&apos;ponyfoo&apos;</span>, id: <span class="md-code-number">1234</span> };
  <span class="md-code-keyword">var</span> getUser = sinon.spy();
  <span class="md-code-keyword">var</span> userController = proxyquire(<span class="md-code-string">&apos;../controllers/user&apos;</span>, {
    <span class="md-code-string">&apos;../services/user&apos;</span>: { getUser: getUser }
  });

  userController.prepareModel(wrapUp);

  t.equal(getUser.firstCall.args[<span class="md-code-number">0</span>], <span class="md-code-number">1234</span>);
  t.equal(<span class="md-code-keyword">typeof</span> getUser.firstCall.args[<span class="md-code-number">1</span>], <span class="md-code-string">&apos;function&apos;</span>);

  getUser.firstCall.args[<span class="md-code-number">1</span>](<span class="md-code-literal">null</span>, user);

  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">wrapUp</span> <span class="md-code-params">(err, model)</span> </span>{
    t.equal(err, <span class="md-code-literal">null</span>);
    t.equal(model.username, <span class="md-code-string">&apos;ponyfoo&apos;</span>);
    t.notOk(<span class="md-code-string">&apos;id&apos;</span> <span class="md-code-keyword">in</span> model);
    t.end();
  }
});
</code></pre> <p>Using this technique you could make assertions about the callback that gets passed in <code class="md-code md-code-inline">userController</code> to the <code class="md-code md-code-inline">userService.getUser</code> method. Of course, this is not always necessary, as you typically want to be testing inputs against outputs, and <em>never implementation details</em>.</p> <p>That way, if the underlying implementation changes, you won&#x2019;t be invalidating tens of ineffective tests. As long as the inputs match the expected outputs, all should be well.</p> <h1 id="conclusions">Conclusions</h1> <p>I realize that frameworks like Jasmine were <strong>probably built with testers in mind</strong>. You know, the kind of people who favor BDD and <a href="https://cucumber.io/" target="_blank" aria-label="Cucumber framework">the Cucumber plain text human-readable DSL</a>. More modular alternatives should be favored by developers.</p> <p>The benefits of modular test frameworks like <code class="md-code md-code-inline">tape</code> far outweight those of global-sprinklers such as Jasmine or Mocha, when it comes to developers writing maintainable tests. Regardless of your choice, <code class="md-code md-code-inline">sinon</code> is an obvious inclusion in your test suites, as is <code class="md-code md-code-inline">proxyquire</code> if you&#x2019;re dealing with CommonJS modules.</p></div>
